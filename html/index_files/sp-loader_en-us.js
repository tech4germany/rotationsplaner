var spModuleLoader =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
  var strings = {
    "_gIErrcTokcw+/VVwa+ReIA": {
      "invalidEnvironmentTypeError": "***EnvironmentType is invalid",
      "invalidGuidStringError": "***Invalid GUID string: \"{0}\"",
      "isFalseValidateError": "***The value for \"{0}\" is false",
      "isNullValidateError": "***The value for \"{0}\" must not be null",
      "isUndefinedValidateError": "***The value for \"{0}\" must not be undefined",
      "isEmptyStringValidateError": "***The value for \"{0}\" must not be an empty string",
      "invalidVersionStringError": "***Invalid version string: \"{0}\"",
      "logVerboseLevelMessage": "***{0}: VERBOSE {1}",
      "logInfoLevelMessage": "***{0}: {1}",
      "logWarningLevelMessage": "***{0}: WARNING {1}",
      "logErrorLevelMessage": "***{0}: ERROR: {1}",
      "serviceScopeConsumingBeforeFinished": "***Cannot consume services because the scope is not finished yet",
      "serviceScopeConsumingDuringAutoCreation": "***Cannot consume services during ServiceScope autocreation",
      "serviceScopeAlreadyFinishedError": "***The ServiceScope is already finished",
      "serviceScopeProvideServiceAfterFinishedError": "***Cannot register service because the scope is already finished",
      "serviceScopeProvideServiceThatAlreadyExists": "***The service key \"{0}\" has already been registered in this scope",
      "spErrorInnerErrorText": "***INNERERROR:",
      "spErrorCallStackText": "***CALLSTACK:",
      "spErrorLogPropertiesText": "***LOGPROPERTIES:"
    },
    "_nQNACBeQ34aV6bVwtFBayA": {
      "loaderUserFriendlyError": "Can't load the application on this page. Use the browser Back button to retry. If the problem persists, contact the administrator of the site and give them the information in Technical Details.",
      "platformFailedToLoadError": "***Platform failed to load. Id: \"{0}\", name: \"{1}\"",
      "platformFailedToLoadWithMessageError": "***Platform failed to load. Id: \"{0}\", name: \"{1}\".\r\nError: {2}",
      "applicationFailedToLoadError": "***Application failed to load. Id: \"{0}\", name: \"{1}\"",
      "applicationFailedToLoadWithMessageError": "***Application failed to load. Id: \"{0}\", name: \"{1}\".\r\nError: {2}",
      "applicationFailedToInitializeError": "***Error initializing application. Error: {0}",
      "invalidPreloadedDataError": "***Invalid preloaded data.",
      "missingApplicationIdError": "***Missing application id.",
      "manifestNotFoundByIdError": "***Manifest not found for component id \"{0}\".",
      "manifestNotFoundError": "***Manifest not found for component id \"{0}\" and version \"{1}\".",
      "systemConfigDisabledError": "***System.config() is not supported. Use a manifest to specify the configuration.",
      "loadComponentLog": "***Loading component \"{0}\" ({1}).",
      "loadComponentEndLog": "***Component \"{0}\" ({1}) loaded.",
      "loadComponentRetryLog": "***Loading component \"{0}\" ({1}). Attempt {2} of {3}.",
      "loadComponentError": "***Failed to load component \"{0}\" ({1}).\r\nOriginal error: {2}",
      "loadComponentMaxRetriesError": "***Attempted to load component \"{0}\" ({1}) {2} times without success.",
      "loadComponentDependencyError": "***Failed to load component dependency \"{0}\" from component \"{1}\" ({2}).\r\nOriginal error: {3}",
      "loadComponentDependencyFailoverPathError": "***Failed to load component dependency \"{0}\" with failover path \"{1}\" from component \"{2}\" ({3}).\r\nOriginal error: {4}",
      "loadPathDependencyLog": "***Loading path dependency \"{0}\" from component \"{1}\" ({2})",
      "loadPathDependencyError": "***Failed to load path dependency \"{0}\" from component \"{1}\" ({2}).\r\nOriginal error: {3}",
      "loadPathDependencyBlockedByAnotherDependencyError": "***Failed to load path dependency \"{0}\" from component \"{1}\" ({2}) due to another dependency that failed to load.",
      "loadEntryPointError": "***Failed to load entry point from component \"{0}\" ({1}).\r\nOriginal error: {2}",
      "loadComponentReturnsEmptyError": "***loadComponent() returned an empty object for component \"{0}\" ({1}).",
      "loadComponentReturnsDefaultEmptyError": "***loadComponent() returned an object with an empty default property for component \"{0}\" ({1}).",
      "moduleHasUndeclaredDependencyError": "***The entry point for component \"{0}\" ({1}) has a dependency on \"{2}\" that is not declared in the manifest.",
      "loadScriptWithStringError": "***loadScript function doesn't allow a string as 2nd parameter. Use ILoadScriptOptions instead.",
      "tooManyManifestsError": "***{0} manifests (versions {1}) found for component \"{2}\".",
      "tooManyCompatibleVersionsError": "***{0} compatible versions ({1}) found for component \"{2}\" version \"{3}\".",
      "tooManyComponentsError": "***Too many components found for id \"{0}\".",
      "noComponentFoundError": "***No component found for id \"{0}\".",
      "deleteComponentLog": "***Deleting component \"{0}\" version \"{1}\" from the store.",
      "browserNotSupportedError": "***This version of your browser is not supported.\r\nPlease update your browser to the latest version.",
      "ie9OrOlderNotSupportedError": "***This page does not support Internet Explorer releases older than version 10. Please update your web browser.",
      "resourceNotFoundError": "***Resource \"{0}\" not found in loader configuration of manifest for component \"{1}\" ({2}).",
      "noFailoverPathError": "***Cannot call resolveAddress() on a component with no failover path",
      "urlStatusLocalhostFileNotFoundError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). The file was not found in the server.\r\nMake sure that you are running 'gulp serve'.",
      "urlStatusFileNotFoundError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). The file was not found in the server.",
      "urlStatusForbiddenError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). The access to the file is forbidden.",
      "urlStatusClientErrorError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). There was an error requesting the file.",
      "urlStatusServerErrorError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). There was a problem in the server.",
      "urlStatusLocalhostNetworkErrorError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). There was a network problem.\r\nMake sure that you have run 'gulp trust-dev-cert'.",
      "urlStatusHttpsNetworkErrorError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). There was a network problem.\r\nThis may be a problem with a HTTPS certificate. Make sure you have the right certificate.",
      "urlStatusNetworkErrorError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}). There was a network problem.",
      "urlStatusUndefinedError": "***Failed to load URL '{3}' for resource '{2}' in component '{0}' ({1}) because of unknown problems."
    },
    "_kf4jigwPPCxeciwsfHc9rA": {
      "errorLoadingDebugManifestHTTPS": "***Error loading debug manifest script. Ensure the server is running and the \"debugManifestsFile\" parameter URL is correct.",
      "errorLoadingDebugManifestHTTP": "***Error loading debug manifest script. Ensure the server is running, the \"debugManifestsFile\" parameter URL is correct, and loading unsafe scripts is allowed. Also consider using a development certificate and serving debug scripts over HTTPS.",
      "errorLoadingDebugManifestMalformed": "***Error loading debug manifest script. The debug URL ({0}) appears to be malformed."
    },
    "_RPELcTeq3ZByqi3N5dt18w": {
      "missingDeveloperToolsTabInitFunctionError": "***Missing component or initializer function.",
      "closeDeveloperToolsAriaLabel": "***Close developer tools."
    },
    "_CmyT6Anz+yC/KJh8Pcbu5g": {
      "developerToolsKeyComboDeprecationMessage": "***The \"ctrl+shift+`\" key combination for opening the developer tools has been deprecated and will be removed soon. Use the \"ctrl+F12\" key combo instead."
    },
    "_fwMQe6Xe08yEeCPNxngd+g": {
      "warningHeading": "Warning!",
      "warningLine1": "Use of this tool exposes you to potential security threats which can result in others gaining access to your personal Office 365 data (documents, emails, conversations and more). Make sure you trust the person or organization that asked you to access this tool before proceeding.",
      "warningLine2": "Learn more here: {0}"
    },
    "_mraBnnuq2J9WjrAcnw9QNA": {
      "debugManifestErrorTitle": "***Error loading debug manifests.",
      "debugManifestErrorDetail": "***An error occured loading debug manifests.",
      "debugManifestErrorDismissButtonText": "***Dismiss"
    },
    "_upo3vfLFBbnbzl2hKy2TwA": {
      "debugManifestLoadingTitle": "Allow Debug Manifests?",
      "debugManifestLoadingWarning": "WARNING: This page is requesting to load unsafe scripts, which could potentially harm your computer! Do not proceed unless you trust the developer and understand the risks.",
      "debugManifestLoadingWarning2": "If you are unsure, click \"{0}.\"",
      "debugManifestLoadingConfirm": "Load debug scripts",
      "debugManifestLoadingCancel": "Don't load debug scripts",
      "debugManifestLoadingCalloutText": "If you don't know what to do, click here."
    },
    "_SxImp5ewsUToxeAHBkB+pw": {
      "developerToolsTabLoadingText": "***Loading...",
      "developerToolsTabLoadingUnknownError": "***Unknown error loading developer tools module."
    },
    "_sovI4qDAUPMnD4jg3Vsyfg": {
      "tabTitle": "Manifests",
      "noManifestSelected": "No manifest selected"
    },
    "_g7G0QHJ5bQYlxe+lk+DcxA": {
      "TabTitle": "Performance",
      "ErrorAccessingPerfDataErrorMessage": "Unable to retrieve performance data: object is null or undefined.",
      "ErrorAccessingRedirectDataErrorMessage": "There was a problem accessing the HTTP redirect performance data.",
      "ErrorParsingPercievedLatencyErrorMessage": "An error was caught when parsing the percieved latency data.",
      "ErrorParsingApiDataErrorMessage": "An error was caught when parsing the API data.",
      "UnkownPerformanceDataErrorMessage": "An unknown error has occured: {0}",
      "DefaultWebPartName": "Web Part",
      "ServerResponseLabel": "Server Response",
      "ApplicationInitializationLabel": "Application Initialization",
      "ScriptFetchEvalLabel": "Script fetch and evaluation",
      "SpLoaderStartLabel": "SPFx initialization",
      "PageRenderLabel": "Page Render",
      "LeftNavRenderLabel": "Left Navigation Render",
      "CanvasRenderLabel": "Canvas Render",
      "LayoutRenderLabel": "Layout Render",
      "RedirectResponseLabel": "Redirect Response",
      "AppLoadLabel": "Application Load",
      "RenderWebPartsLabel": "Web Parts Render",
      "TotalRenderTimeLabel": "Total",
      "GeneralErrorMessage": "Sorry, something went wrong while retrieving the performance data.",
      "ErrorMessagePrefix": "Error Message: {0}",
      "PerformanceDataHint": "Note: After adding or removing a web part, refresh the page to see updated performance data.",
      "ModulesLoadedLegendLabel": "Modules Loaded",
      "InitializationLegendLabel": "Initialization",
      "RenderTimeLegendLabel": "Render Time",
      "InitializationTimeLabel": "***Initialization time",
      "ModuleLoadingTimeLabel": "***Module loading time",
      "ModuleLazyLoadingDelayLabel": "***Module loading delayed",
      "DataFetchTimeLabel": "***Data fetch time",
      "DataFetchLegendLabel": "Data Fetch",
      "ItemsColumnHeader": "Items",
      "DurationColumnHeader": "Duration",
      "MillisecondsUnitLabel": "{0} ms",
      "NAPlaceholder": "N/A"
    },
    "_gqinlPQb8HZprTeCpwNz2w": {
      "TabTitle": "Trace",
      "EmptyTraceData": "No traces loaded.",
      "ExportCSVButtonLabel": "Export CSV",
      "LevelHeaderLabel": "Level",
      "MessageHeaderLabel": "Message",
      "ScopeHeaderLabel": "Scope",
      "SourceHeaderLabel": "Source",
      "TimestampHeaderLabel": "Timestamp",
      "TimestampFormat": "{0}/{1}/{2} {3}:{4}:{5}.{6}",
      "ErrorAccessingTraceDataErrorMessage": "There was a problem accessing the trace data."
    }
  };

  strings.default = strings;
  return strings;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function(__WEBPACK_EXTERNAL_MODULE_30__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonpspModuleLoader"];
/******/ 	window["webpackJsonpspModuleLoader"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length)
/******/ 			resolves.shift()();
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		3: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return Promise.resolve();
/******/
/******/ 		// an Promise means "currently loading".
/******/ 		if(installedChunks[chunkId]) {
/******/ 			return installedChunks[chunkId][2];
/******/ 		}
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + ({"0":"developer-tools","1":"debug-prompt-components","2":"sp-client-telemetry"}[chunkId]||chunkId) + "_" + {"0":"c272c4769cd3c1e91393","1":"79c217e2c3c57307fcf3","2":"742ab100f2767ae8426a"}[chunkId] + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunks[chunkId][2] = promise;
/******/
/******/ 		head.appendChild(script);
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Set the webpack public path
/******/ 	(function () {
/******/ 	  var scripts = document.getElementsByTagName('script');
/******/ 	  var regex = new RegExp('sp-loader_?[a-zA-Z0-9-_]*.js', 'i');
/******/ 	  var found = false;
/******/ 	
/******/ 	  if (scripts && scripts.length) {
/******/ 	    for (var i = 0; i < scripts.length; i++) {
/******/ 	      if (!scripts[i]) continue;
/******/ 	      var path = scripts[i].getAttribute('src');
/******/ 	      if (path && path.match(regex)) {
/******/ 	        __webpack_require__.p = path.substring(0, path.lastIndexOf('/') + 1);
/******/ 	        found = true;
/******/ 	        break;
/******/ 	      }
/******/ 	    }
/******/ 	  }
/******/ 	
/******/ 	  if (!found) {
/******/ 	    for (var global in window.__setWebpackPublicPathLoaderSrcRegistry__) {
/******/ 	      if (global && global.match(regex)) {
/******/ 	        __webpack_require__.p = global.substring(0, global.lastIndexOf('/') + 1);
/******/ 	        break;
/******/ 	      }
/******/ 	    }
/******/ 	  }
/******/ 	})();
/******/ 	
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 464);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BrowserDetection_1 = __webpack_require__(445);
exports._BrowserDetection = BrowserDetection_1.default;
exports._Browser = BrowserDetection_1.Browser;
exports._OS = BrowserDetection_1.OS;
var DisplayMode_1 = __webpack_require__(446);
exports.DisplayMode = DisplayMode_1.default;
var Guid_1 = __webpack_require__(112);
exports.Guid = Guid_1.default;
var IBrowserCompatibility_1 = __webpack_require__(448);
exports.BrowserSupportLevel = IBrowserCompatibility_1.BrowserSupportLevel;
var JsonUtilities_1 = __webpack_require__(449);
exports.JsonUtilities = JsonUtilities_1.default;
var Text_1 = __webpack_require__(29);
exports.Text = Text_1.default;
var Version_1 = __webpack_require__(194);
exports.Version = Version_1.default;
var Validate_1 = __webpack_require__(14);
exports.Validate = Validate_1.default;
var UrlUtilities_1 = __webpack_require__(458);
exports.UrlUtilities = UrlUtilities_1.default;
var UrlQueryParameterCollection_1 = __webpack_require__(114);
exports.UrlQueryParameterCollection = UrlQueryParameterCollection_1.default;
var TimeProvider_1 = __webpack_require__(457);
exports.TimeProvider = TimeProvider_1.default;
var RandomNumberGenerator_1 = __webpack_require__(456);
exports.RandomNumberGenerator = RandomNumberGenerator_1.default;
var ServiceKey_1 = __webpack_require__(113);
exports.ServiceKey = ServiceKey_1.default;
var ServiceScope_1 = __webpack_require__(455);
exports.ServiceScope = ServiceScope_1.default;
var Session_1 = __webpack_require__(453);
exports.Session = Session_1.default;
var Environment_1 = __webpack_require__(447);
exports.Environment = Environment_1.default;
exports.EnvironmentType = Environment_1.EnvironmentType;
var SPFlight_1 = __webpack_require__(451);
exports._SPFlight = SPFlight_1.default;
var SPKillSwitch_1 = __webpack_require__(452);
exports._SPKillSwitch = SPKillSwitch_1.default;
var SPError_1 = __webpack_require__(450);
exports.SPError = SPError_1.default;
var Log_1 = __webpack_require__(195);
exports.Log = Log_1.default;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EngagementLogger_1 = __webpack_require__(190);
exports._EngagementLogger = EngagementLogger_1.default;
var TraceLogger_1 = __webpack_require__(73);
exports._TraceLogger = TraceLogger_1.default;
var LogEntry_1 = __webpack_require__(438);
exports._LogEntry = LogEntry_1.default;
var LogSource_1 = __webpack_require__(111);
exports._LogSource = LogSource_1.default;
exports._logSourceServiceKey = LogSource_1.logSourceServiceKey;
var LogType_1 = __webpack_require__(193);
exports._LogType = LogType_1.default;
var QosMonitor_1 = __webpack_require__(440);
exports._QosMonitor = QosMonitor_1.default;
var PerformanceLogger_1 = __webpack_require__(200);
exports._PerformanceLogger = PerformanceLogger_1.default;
var Telemetry_1 = __webpack_require__(444);
exports._Telemetry = Telemetry_1.default;
var SPTelemetryLogHandler_1 = __webpack_require__(443);
exports._SPTelemetryLogHandler = SPTelemetryLogHandler_1.default;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_telemetry_1 = __webpack_require__(2);
var telemetryConstants_1 = __webpack_require__(6);
var sp_core_library_1 = __webpack_require__(0);
var confirmDebugAllowed_1 = __webpack_require__(121);
var componentConstants = __webpack_require__(21);
var normalizeComponentId_1 = __webpack_require__(50);
var sp_core_library_2 = __webpack_require__(0);
var SPLoader_resx_1 = __webpack_require__(5);
var ManifestStore = (function () {
    function ManifestStore() {
        this._manifestVersions = new Map();
        this._manifests = new Map();
    }
    Object.defineProperty(ManifestStore, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new ManifestStore();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    ManifestStore.prototype.registerPreloadedManifests = function (preloadedData) {
        if (preloadedData) {
            if (preloadedData.clientSideApplicationManifest) {
                this._addManifest(preloadedData.clientSideApplicationManifest, true);
            }
            if (preloadedData.manifests && preloadedData.manifests.length) {
                this.registerManifests(preloadedData.manifests, true);
            }
        }
        var globalManifests = window.g_webPartManifests;
        if (globalManifests && globalManifests.length) {
            this.registerManifests(globalManifests, true);
        }
    };
    ManifestStore.prototype.registerDebugManifests = function (manifests) {
        if (manifests) {
            for (var id in manifests) {
                this._addDebugManifest(manifests[id]);
            }
        }
    };
    ManifestStore.prototype.tryGetManifest = function (id, version, shouldLog) {
        if (shouldLog === void 0) { shouldLog = true; }
        try {
            return this._getManifest(id, version, shouldLog);
        }
        catch (e) {
            return undefined;
        }
    };
    ManifestStore.prototype.getManifest = function (id, version) {
        return this._getManifest(id, version, true);
    };
    ManifestStore.prototype.getRegisteredManifests = function () {
        var _this = this;
        var result = [];
        this._manifests.forEach(function (manifestEntry) {
            var manifest = _this._getManifestFromStoreEntry(manifestEntry);
            if (manifest) {
                result.push(manifest);
            }
        });
        return result;
    };
    ManifestStore.prototype._getManifestMap = function () {
        return this._manifests;
    };
    ManifestStore.prototype.registerManifests = function (manifests, overwriteExisting) {
        var _this = this;
        manifests.forEach(function (manifest) { return _this._addManifest(manifest, overwriteExisting); });
    };
    ManifestStore.prototype._getManifest = function (id, version, shouldLog) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        if ((id === componentConstants.reactComponentId ||
            id === componentConstants.reactDomComponentId) && version === '0.14.8') {
            version = '15.4.2';
        }
        var index = this._getExistingIndex(id, version);
        if (!index) {
            if (shouldLog) {
                sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants_1.manifestStoreLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.manifestNotFoundError, id, version));
            }
            throw new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.manifestNotFoundError, id, version));
        }
        var manifestEntry = this._manifests.get(index);
        if (manifestEntry) {
            var manifest = this._getManifestFromStoreEntry(manifestEntry);
            if (manifest) {
                return manifest;
            }
        }
        throw new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.manifestNotFoundError, id, version));
    };
    ManifestStore.prototype._getManifestFromStoreEntry = function (manifestEntry) {
        var allowDebug = confirmDebugAllowed_1.peek();
        if (manifestEntry) {
            if (allowDebug && manifestEntry.debugManifest) {
                return manifestEntry.debugManifest;
            }
            else {
                return manifestEntry.manifest;
            }
        }
        else {
            return undefined;
        }
    };
    ManifestStore.prototype._addManifest = function (manifest, overwriteExisting) {
        this._internalAddManifest(manifest, false, overwriteExisting);
    };
    ManifestStore.prototype._addDebugManifest = function (manifest) {
        this._internalAddManifest(manifest, true);
    };
    ManifestStore.prototype._internalAddManifest = function (manifest, isDebug, overwriteExisting) {
        var index = this._getExistingIndex(manifest.id, manifest.version);
        var existingEntry = index ? this._manifests.get(index) : undefined;
        if (existingEntry) {
            if (isDebug) {
                existingEntry.debugManifest = manifest;
            }
            else {
                if (overwriteExisting || !existingEntry.manifest) {
                    existingEntry.manifest = manifest;
                }
            }
        }
        else {
            this._addManifestToVersionsMap(manifest);
            var newIndex = this._createIndexFromManifest(manifest);
            this._manifests.set(newIndex, {
                id: manifest.id,
                version: manifest.version,
                manifest: isDebug ? undefined : manifest,
                debugManifest: isDebug ? manifest : undefined
            });
        }
    };
    ManifestStore.prototype._addManifestToVersionsMap = function (manifest) {
        var version = sp_core_library_1.Version.parse(manifest.version);
        if (!this._manifestVersions.has(manifest.id)) {
            this._manifestVersions.set(manifest.id, [version]);
        }
        else {
            var versions = this._manifestVersions.get(manifest.id);
            for (var _i = 0, versions_1 = versions; _i < versions_1.length; _i++) {
                var existingVersion = versions_1[_i];
                if (existingVersion.equals(version)) {
                    return; 
                }
            }
            this._manifestVersions.set(manifest.id, versions.concat(version));
        }
    };
    ManifestStore.prototype._getExistingIndex = function (id, versionString) {
        var _this = this;
        if (!versionString) {
            return this._getUniqueManifestStoreIndex(id);
        }
        if (this._manifestVersions.has(id)) {
            var versions = this._manifestVersions.get(id);
            var version_1 = sp_core_library_1.Version.parse(versionString);
            var validVersions = versions.filter(function (currentVersion) { return _this._satisfies(currentVersion, version_1); });
            if (!validVersions || validVersions.length < 1) {
                return undefined;
            }
            else if (validVersions.length === 1) {
                return this._createIndex(id, validVersions[0]);
            }
            else {
                var debugIndex = this._findSingleDebugVersion(id, validVersions);
                if (debugIndex) {
                    return debugIndex;
                }
                else {
                    var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.tooManyCompatibleVersionsError, validVersions.length, validVersions.join(', '), id, versionString));
                    sp_telemetry_1._TraceLogger.logError(telemetryConstants_1.manifestStoreLogSource, error);
                    var returnVersion = validVersions.sort(function (version1, version2) {
                        return -1 * sp_core_library_1.Version.compare(version1, version2);
                    })[0];
                    return this._createIndex(id, returnVersion);
                }
            }
        }
        return undefined;
    };
    ManifestStore.prototype._satisfies = function (existingVersion, versionNeeded) {
        sp_core_library_1.Validate.isNotNullOrUndefined(versionNeeded, 'versionNeeded');
        if (versionNeeded.major === 0) {
            return !existingVersion.lessThan(versionNeeded) && existingVersion.major <= 1;
        }
        else {
            return existingVersion.satisfies(versionNeeded);
        }
    };
    ManifestStore.prototype._getUniqueManifestStoreIndex = function (id) {
        var versions = this._manifestVersions.get(id);
        if (!versions || versions.length < 1) {
            return undefined;
        }
        else if (versions.length === 1) {
            return this._createIndex(id, versions[0]);
        }
        else {
            var debugIndex = this._findSingleDebugVersion(id, versions);
            if (debugIndex) {
                return debugIndex;
            }
            else {
                var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.tooManyManifestsError, versions.length, versions.join(', '), id));
                sp_telemetry_1._TraceLogger.logError(telemetryConstants_1.manifestStoreLogSource, error);
                return undefined;
            }
        }
    };
    ManifestStore.prototype._createIndexFromManifest = function (manifest) {
        return this._createIndex(manifest.id, sp_core_library_1.Version.parse(manifest.version));
    };
    ManifestStore.prototype._createIndex = function (id, version) {
        return normalizeComponentId_1.default(id, version.toString());
    };
    ManifestStore.prototype._findSingleDebugVersion = function (id, versions) {
        var _this = this;
        return versions.reduce(function (previous, validVersion) {
            var index = _this._createIndex(id, validVersion);
            if (_this._manifests.get(index).debugManifest || previous) {
                return index;
            }
            else {
                return undefined;
            }
        }, undefined);
    };
    return ManifestStore;
}());
exports.default = ManifestStore;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings =  false
    ? require('resx-strings/en-us.json')
    : __webpack_require__(30);
exports.default = strings['_nQNACBeQ34aV6bVwtFBayA'];


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.startQosScenarioName = 'SPComponentLoader.start';
exports.platformFailedToLoadFailure = 'PlatformFailedToLoad';
exports.applicationFailedToLoadFailure = 'ApplicationFailedToLoad';
exports.shellStartFailure = 'SPShell.Start';
exports.missingPlatformManifestFailure = 'MissingPlatformManifest';
exports.missingApplicationManifestFailure = 'MissingApplicationManifest';
exports.missingApplicationIdFailure = 'MissingApplicationId';
exports.invalidPreloadedDataFailure = 'InvalidPreloadedData';
exports.timeoutExpectedFailure = 'Timeout';
exports.loadComponentQosScenarioName = 'SPComponentLoader.loadComponent';
exports.loadComponentImplQosScenarioName = 'SPComponentLoader._loadComponentImpl';
exports.loadPathDependencyQosScenarioName = 'SPComponentLoader.loadPathDependency';
exports.emptyComponentErrorTagName = 'EmptyComponent';
exports.configureSystemJsErrorTagName = 'ConfigureSystemJs';
exports.loadComponentDependenciesErrorTagName = 'LoadComponentDependencies';
exports.loadPathDependenciesErrorTagName = 'LoadPathDependencies';
exports.spStarterLogSource = { id: 'SPStarter.start' };
exports.startLogSource = { id: 'SPComponentLoader.start' };
exports.loadComponentLogSource = { id: 'SPComponentLoader.loadComponent' };
exports.loadScriptLogSource = { id: 'SPComponentLoader.loadScript' };
exports.resolveAddressLogSource = { id: 'resolveAddress' };
exports.componentStoreLogSource = { id: 'ComponentStore' };
exports.manifestStoreLogSource = { id: 'ManifestStore' };


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:CoverageThreshold(72)

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EventBase_1 = __webpack_require__(22);
function logData(data, parent) {
    return new this(data, EventBase_1.ClonedEventType.Single, parent);
}
function logEmptyData(parent) {
    return new this(null, EventBase_1.ClonedEventType.Single, parent);
}
function createSingleEvent(props, metadata, baseClass) {
    var SingleEvent = (function (_super) {
        __extends(SingleEvent, _super);
        function SingleEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SingleEvent;
    }(EventBase_1.EventBase));
    SingleEvent.logData = metadata ? logData : logEmptyData;
    EventBase_1.addEventProps(SingleEvent.prototype, props, metadata || {}, baseClass);
    return SingleEvent;
}
exports.createSingleEvent = createSingleEvent;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(62);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var CaughtError_event_1 = __webpack_require__(87);
var QosError_event_1 = __webpack_require__(136);
var Verbose_event_1 = __webpack_require__(140);
var CircularBuffer_1 = __webpack_require__(256);
var ObjectUtil_1 = __webpack_require__(17);
var MAX_VERBOSE_LOGS = 50;
var ErrorHelper = (function () {
    function ErrorHelper() {
    }
    ErrorHelper.verbose = function (message, eventName) {
        ErrorHelper._verboseLogs.push({
            name: eventName,
            message: message
        });
    };
    ErrorHelper.logError = function (error, extraData, qosData) {
        if (!error || error._handled) {
            return;
        }
        var message = this.getErrorMessage(error);
        var stack = error && error.stack ? error.stack : "";
        var schema;
        while (Boolean(schema = ErrorHelper._verboseLogs.popOldest())) {
            Verbose_event_1.Verbose.logData(schema);
        }
        if (qosData && qosData.eventName) {
            QosError_event_1.QosError.logData({
                name: qosData.eventName,
                resultCode: qosData.resultCode,
                resultType: qosData.resultType,
                extraData: extraData || undefined,
                message: message,
                stack: stack
            });
        }
        else {
            CaughtError_event_1.CaughtError.logData({
                extraData: extraData || undefined,
                message: message,
                stack: stack
            });
        }
    };
    ErrorHelper.log = function (error, eventName, resultCode, resultType) {
        this.logError(error, null, { eventName: eventName, resultCode: resultCode, resultType: resultType });
    };
    /**
     * Extract the error message from the error
     */
    ErrorHelper.getErrorMessage = function (error) {
        var message = '';
        if (error) {
            if (error.message) {
                message = error.message;
            }
            else if (error.description) {
                message = error.description;
            }
            else if (typeof (error) === 'object') {
                message = ObjectUtil_1.safeSerialize(error);
            }
            else if (error.toString) {
                message = error.toString();
            }
        }
        return message;
    };
    return ErrorHelper;
}());
ErrorHelper._verboseLogs = new CircularBuffer_1.default(MAX_VERBOSE_LOGS);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ErrorHelper;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(173);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(159),
    baseKeys = __webpack_require__(289),
    isArrayLike = __webpack_require__(12);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(105),
    isLength = __webpack_require__(106);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {};
function setStrings(newStrings) {
    for (var key in newStrings) {
        if (newStrings.hasOwnProperty(key)) {
            strings[key] = newStrings[key];
        }
    }
}
exports.setStrings = setStrings;
if (false) {
    setStrings(require('./SPCoreLibraryStrings.resx').default);
}
exports.default = strings; 


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Text_1 = __webpack_require__(29);
var StringsProxy_1 = __webpack_require__(13);
var Validate = (function () {
    function Validate() {
    }
    Validate.isTrue = function (value, variableName) {
        if (!value) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.isFalseValidateError, variableName));
        }
    };
    Validate.isNotNullOrUndefined = function (value, variableName) {
        if (value === null) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.isNullValidateError, variableName));
        }
        if (value === undefined) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.isUndefinedValidateError, variableName));
        }
    };
    Validate.isNonemptyString = function (value, variableName) {
        Validate.isNotNullOrUndefined(value, variableName);
        if (!value || value && value.length === 0) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.isEmptyStringValidateError, variableName));
        }
    };
    return Validate;
}());
exports.default = Validate;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
 * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
 *
 * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
 * new instance of the class and remember to call dispose() during your code's dispose handler.
 */

function noop() {
    // Do nothing.
}
var Async = (function () {
    function Async(parent, onError) {
        this._isDisposed = false;
        this._parent = parent || null;
        this._onErrorHandler = onError;
        this._timeoutIds = null;
        this._immediateIds = null;
        this._animationFrameIds = null;
        this._intervalIds = null;
    }
    /**
     * Dispose function, clears all async operations.
     */
    Async.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._parent = null;
        // Clear timeouts.
        if (this._timeoutIds) {
            for (var _i = 0, _a = Object.keys(this._timeoutIds); _i < _a.length; _i++) {
                var id = _a[_i];
                this.clearTimeout(Number(id));
            }
            this._timeoutIds = null;
        }
        // Clear immediates.
        if (this._immediateIds) {
            for (var _b = 0, _c = Object.keys(this._immediateIds); _b < _c.length; _b++) {
                var id = _c[_b];
                this.clearImmediate(Number(id));
            }
            this._immediateIds = null;
        }
        // Clear intervals.
        if (this._intervalIds) {
            for (var _d = 0, _e = Object.keys(this._intervalIds); _d < _e.length; _d++) {
                var id = _e[_d];
                this.clearInterval(Number(id));
            }
            this._intervalIds = null;
        }
        // Clear animation frames.
        if (this._animationFrameIds) {
            for (var _f = 0, _g = Object.keys(this._animationFrameIds); _f < _g.length; _f++) {
                var id = _g[_f];
                this.cancelAnimationFrame(Number(id));
            }
            this._animationFrameIds = null;
        }
    };
    /**
     * SetTimeout override, which will auto cancel the timeout during dispose.
     * @param callback Callback to execute.
     * @param duration Duration in milliseconds.
     * @return The setTimeout id.
     */
    Async.prototype.setTimeout = function (callback, duration) {
        var _this = this;
        var timeoutId = 0;
        if (!this._isDisposed) {
            var timeoutIds_1 = this._timeoutIds || (this._timeoutIds = {});
            /* tslint:disable:ban-native-functions */
            timeoutId = setTimeout(function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    delete timeoutIds_1[timeoutId];
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            timeoutIds_1[timeoutId] = true;
        }
        return timeoutId;
    };
    /**
     * Clears the timeout.
     * @param id Id to cancel.
     */
    Async.prototype.clearTimeout = function (id) {
        var timeoutIds = this._timeoutIds;
        if (timeoutIds && timeoutIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete timeoutIds[id];
        }
    };
    /**
     * SetImmediate override, which will auto cancel the immediate during dispose.
     * @param callback Callback to execute.
     * @return The setTimeout id.
     */
    Async.prototype.setImmediate = function (callback) {
        var _this = this;
        var immediateId = 0;
        if (!this._isDisposed) {
            var immediateIds_1 = this._immediateIds || (this._immediateIds = {});
            var setImmediateCallback = function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    delete immediateIds_1[immediateId];
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            /* tslint:disable:ban-native-functions */
            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);
            /* tslint:enable:ban-native-functions */
            immediateIds_1[immediateId] = true;
        }
        return immediateId;
    };
    /**
     * Clears the immediate.
     * @param id Id to cancel.
     */
    Async.prototype.clearImmediate = function (id) {
        var immediateIds = this._immediateIds;
        if (immediateIds && immediateIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);
            delete immediateIds[id];
        }
    };
    /**
     * SetInterval override, which will auto cancel the timeout during dispose.
     * @param callback Callback to execute.
     * @param duration Duration in milliseconds.
     * @return The setTimeout id.
     */
    Async.prototype.setInterval = function (callback, duration) {
        var _this = this;
        var intervalId = 0;
        if (!this._isDisposed) {
            if (!this._intervalIds) {
                this._intervalIds = {};
            }
            /* tslint:disable:ban-native-functions */
            intervalId = setInterval(function () {
                // Time to execute the interval callback, enqueue it as a foreground task to be executed.
                try {
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._intervalIds[intervalId] = true;
        }
        return intervalId;
    };
    /**
     * Clears the interval.
     * @param id Id to cancel.
     */
    Async.prototype.clearInterval = function (id) {
        if (this._intervalIds && this._intervalIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearInterval(id);
            delete this._intervalIds[id];
        }
    };
    /**
     * Creates a function that, when executed, will only call the func function at most once per
     * every wait milliseconds. Provide an options object to indicate that func should be invoked
     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
     * function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the throttled function is invoked more than once during the wait timeout.
     *
     * @param func The function to throttle.
     * @param wait The number of milliseconds to throttle executions to. Defaults to 0.
     * @param options The options object.
     * @param options.leading Specify execution on the leading edge of the timeout.
     * @param options.trailing Specify execution on the trailing edge of the timeout.
     * @return The new throttled function.
     */
    Async.prototype.throttle = function (func, wait, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this._isDisposed) {
            return noop;
        }
        var waitMS = wait || 0;
        var _a = options.leading, leading = _a === void 0 ? true : _a, _b = options.trailing, trailing = _b === void 0 ? true : _b;
        var lastExecuteTime = 0;
        var lastResult;
        var lastArgs;
        var timeoutId = null;
        var callback = function (userCall) {
            var now = (new Date()).getTime();
            var delta = now - lastExecuteTime;
            var waitLength = leading ? waitMS - delta : waitMS;
            if (delta >= waitMS && (!userCall || leading)) {
                lastExecuteTime = now;
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastResult = func.apply(_this._parent, lastArgs);
            }
            else if (timeoutId === null && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        var resultFunction = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    };
    /**
     * Creates a function that will delay the execution of func until after wait milliseconds have
     * elapsed since the last time it was invoked. Provide an options object to indicate that func
     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
     * to the debounced function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the debounced function is invoked more than once during the wait
     * timeout.
     *
     * @param func The function to debounce.
     * @param wait The number of milliseconds to delay.
     * @param options The options object.
     * @param options.leading Specify execution on the leading edge of the timeout.
     * @param options.maxWait The maximum time func is allowed to be delayed before it's called.
     * @param options.trailing Specify execution on the trailing edge of the timeout.
     * @return The new debounced function.
     */
    Async.prototype.debounce = function (func, wait, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this._isDisposed) {
            return noop;
        }
        var waitMS = wait || 0;
        var _a = options.leading, leading = _a === void 0 ? false : _a, _b = options.trailing, trailing = _b === void 0 ? true : _b, _c = options.maxWait, maxWait = _c === void 0 ? NaN : _c;
        var lastCallTime = 0;
        var lastExecuteTime = (new Date()).getTime();
        var lastResult;
        var lastArgs;
        var timeoutId = null;
        var callback = function (userCall) {
            var now = (new Date()).getTime();
            var executeImmediately = false;
            if (userCall) {
                if (leading && now - lastCallTime >= waitMS) {
                    executeImmediately = true;
                }
                lastCallTime = now;
            }
            var delta = now - lastCallTime;
            var waitLength = waitMS - delta;
            var maxWaitDelta = now - lastExecuteTime;
            var maxWaitExpired = false;
            if (!isNaN(maxWait)) {
                // maxWait only matters when there is a pending callback
                if (maxWaitDelta >= maxWait && timeoutId) {
                    maxWaitExpired = true;
                }
                else {
                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
                }
            }
            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastExecuteTime = now;
                lastResult = func.apply(_this._parent, lastArgs);
            }
            else if ((timeoutId === null || !userCall) && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        var resultFunction = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    };
    Async.prototype.requestAnimationFrame = function (callback) {
        var _this = this;
        var animationFrameId = 0;
        if (!this._isDisposed) {
            var animationFrameIds_1 = this._animationFrameIds || (this._animationFrameIds = {});
            var animationFrameCallback = function () {
                try {
                    // Now delete the record and call the callback.
                    delete animationFrameIds_1[animationFrameId];
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            /* tslint:disable:ban-native-functions */
            animationFrameId = window.requestAnimationFrame ? window.requestAnimationFrame(animationFrameCallback) : window.setTimeout(animationFrameCallback, 0);
            /* tslint:enable:ban-native-functions */
            animationFrameIds_1[animationFrameId] = true;
        }
        return animationFrameId;
    };
    Async.prototype.cancelAnimationFrame = function (id) {
        var animationFrameIds = this._animationFrameIds;
        if (animationFrameIds && animationFrameIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete animationFrameIds[id];
        }
    };
    Async.prototype._logError = function (e) {
        if (this._onErrorHandler) {
            this._onErrorHandler(e);
        }
    };
    return Async;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Async;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:CoverageThreshold(75)

var ObjectUtil_1 = __webpack_require__(17);
var handlers = [];
var buffer = [];
var maxBufferSize = 100;
function getStartDate() {
    'use strict';
    if (window.performance && window.performance.timing && window.performance.timing.navigationStart) {
        return new Date(window.performance.timing.navigationStart);
    }
    else {
        return new Date();
    }
}
var startDate = getStartDate();
var Manager = (function () {
    function Manager() {
    }
    Manager.getTime = function () {
        return (new Date()).getTime();
    };
    /** This is the overrideable clean string function */
    Manager.cleanString = function (str) {
        return str;
    };
    Manager.addLogHandler = function (handler) {
        handlers.push(handler);
        // Return the buffer so the handler can get missed events
        return buffer;
    };
    Manager.removeLogHandler = function (handler) {
        for (var x = 0; x < handlers.length; x++) {
            if (handlers[x] === handler) {
                // Remove the handler
                handlers.splice(x, 1);
                break;
            }
        }
    };
    Manager.logEvent = function (event, eventType) {
        // Clone the object (do it natively because the browser can mark it as a type)
        var clonedEvent = Object.freeze({
            data: ObjectUtil_1.deepCopy(event.data),
            id: event.id,
            enabled: event.enabled,
            critical: event.critical,
            endTime: event.endTime,
            eventName: event.eventName,
            shortEventName: event.shortEventName,
            parentId: event.parentId,
            startTime: event.startTime,
            eventType: eventType,
            metadata: event.metadata,
            vector: event.vector,
            validationErrors: event.validationErrors
        });
        // Add to the buffer
        buffer.push(clonedEvent);
        if (buffer.length > maxBufferSize) {
            buffer = buffer.slice(1);
            // Make sure we have a handler before the buffer is overrun
            if (handlers.length === 0) {
                this.handleBaseLoggingError(new Error("Logging buffer overflow hit before any logging handler was registered"));
            }
        }
        // Let handlers know the log event has completed
        for (var x = 0; x < handlers.length; x++) {
            try {
                handlers[x](clonedEvent);
            }
            catch (e) {
                this.handleBaseLoggingError(e);
            }
        }
    };
    Manager.logValidationError = function (event, type) {
        // Do nothing so that we can intialize around circular reference issue
    };
    Manager.getStack = function () {
        var error;
        try {
            var w = window;
            w["______ExpectedError______"]();
        }
        catch (e) {
            error = e;
        }
        return error.stack;
    };
    Manager.handleBaseLoggingError = function (error) {
        // TODO: Log somewhere
    };
    return Manager;
}());
Manager.startDate = startDate;
Manager.startTime = startDate.getTime();
exports.Manager = Manager;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Manager;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UriEncoding_1 = __webpack_require__(84);
exports.DEFAULT_DELIMITER = '&';
exports.KEYVALUE_DELIMITER = '=';
// Returns a copy of the specified object by deeply cloning all of its properties.
function deepCopy(object) {
    var refsCopied = [];
    var copyRecurse = function (obj) {
        var result = null;
        if (obj) {
            if (Array.isArray(obj)) {
                result = [];
            }
            else {
                // create clone of the object with same prototype chain
                result = Object.create(Object.getPrototypeOf(obj));
            }
            // iterate over all the properties in the object
            Object.keys(obj).forEach(function (key) {
                // recursively copy the object's properties if the property is an object
                var value = obj[key];
                if (typeof value === "object") {
                    if (refsCopied.indexOf(value) !== -1) {
                        throw new Error("Cannot perform DeepCopy() because a circular reference was encountered, object: " + String(obj) + ", property: " + String(key));
                    }
                    refsCopied.push(value);
                    result[key] = copyRecurse(value);
                    refsCopied.pop();
                }
                else {
                    result[key] = value;
                }
            });
        }
        return result;
    };
    return copyRecurse(object);
}
exports.deepCopy = deepCopy;
// Deeply compares the objects by recursively comparing all their properties, objects with circular references are not supported, prototype members and functions are ignored
function deepCompare(objA, objB, equivalent) {
    // keep track of references that have been compared to find circular references while walking down either object
    var refsComparedA = [];
    var refsComparedB = [];
    var compare = Boolean(equivalent) ? equivalent : function (a, b) { return (a === b); };
    var equals = function (a, b) {
        // try a simple equality test first
        if (a === b) {
            return true;
        }
        if ((a === null) || (b === null)) {
            return false;
        }
        // if both are objects, then further comparison is required
        if ((typeof (a) === "object") && (typeof (b) === "object")) {
            // perform deep comparison over object's properties
            var aKeys = Object.keys(a).sort();
            var bKeys_1 = Object.keys(b).sort();
            // does one object have a different number of properties?
            if (aKeys.length !== bKeys_1.length) {
                return false;
            }
            var keysMatch = aKeys.every(function (key, index) {
                // key names should match
                if (key !== bKeys_1[index]) {
                    return false;
                }
                else if (typeof (a[key]) === 'function' || typeof (b[key]) === 'function') {
                    //skip comparison of function properties
                    return true;
                }
                else if (!compare(a[key], b[key])) {
                    // if this is an Object then recursive testing is needed on its properties
                    if (typeof a[key] === "object") {
                        // if this property was encountered before then we're going in circles, give up
                        if (refsComparedA.indexOf(a[key]) !== -1) {
                            throw new Error("Cannot perform DeepCompare() because a circular reference was encountered, object: " + String(a) + ", property: " + key);
                        }
                        refsComparedA.push(a[key]);
                        if (refsComparedB.indexOf(b[key]) !== -1) {
                            throw new Error("Cannot perform DeepCompare() because a circular reference was encountered, object: " + String(b) + ", property: " + key);
                        }
                        refsComparedB.push(b[key]);
                        // recursive compare object's properties
                        if (!equals(a[key], b[key])) {
                            return false;
                        }
                        refsComparedA.pop();
                        refsComparedB.pop();
                        return true;
                    }
                    else {
                        // properties don't match
                        return false;
                    }
                }
                else {
                    return true;
                }
            });
            if (!keysMatch) {
                return false;
            }
        }
        else {
            // parameters aren't equal, and at least one is not an Object
            return false;
        }
        // everything is equal
        return true;
    };
    return equals(objA, objB);
}
exports.deepCompare = deepCompare;
/**
 * This is a function you can call to safely serialize anything to JSON.
 * The built-in JSON.stringify() throws an exception for circular references and can't handle
 * many built-ins such as HTMLElements and the global window object.
 */
function safeSerialize(obj) {
    var str;
    try {
        var seenObjects_1 = [];
        str = JSON.stringify(obj, function (key, value) {
            if (value === window) {
                return "[window]";
            }
            else if (value instanceof HTMLElement) {
                return "[HTMLElement]";
            }
            else if (typeof value === "function") {
                return "[function]";
            }
            else if (typeof value === "object") {
                if (value === null) {
                    return value;
                }
                else if (seenObjects_1.indexOf(value) === -1) {
                    seenObjects_1.push(value);
                    return value;
                }
                else {
                    return "[circular]";
                }
            }
            else {
                return value;
            }
        });
    }
    catch (err) {
        // Note: we make this be a JSON string, so that consumers
        // can always call JSON.parse.
        str = JSON.stringify("[object]");
    }
    return str;
}
exports.safeSerialize = safeSerialize;
/**
 * Serializes the object Name Values Pairs (Depth of 1).
 * Used for Query Strings and Cookie Values
 * @param {any} obj Object with name value pairs
 * @param {string} delimeter  Delimiter seperates the pairs
 * @param {boolean} skipEncoding True to skip encoding
 */
function serialize(obj, delimiter, skipEncoding) {
    delimiter = delimiter || exports.DEFAULT_DELIMITER;
    var values = Object.keys(obj).map(function (name) {
        // Get the value and convert it to a string
        var value = obj[name];
        value = value ? value.toString() : "";
        if (!skipEncoding) {
            value = UriEncoding_1.default.encodeURIComponent(value);
        }
        // Add the encoded value to the array
        return name + exports.KEYVALUE_DELIMITER + value;
    });
    return values.join(delimiter);
}
exports.serialize = serialize;
/**
 * Copy the values of all enumerable own properties from one or more source objects to a target object.
 */
function extend(target, source) {
    if (source) {
        for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
            var prop = _a[_i];
            target[prop] = source[prop];
        }
    }
    return target;
}
exports.extend = extend;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(291),
    baseMatchesProperty = __webpack_require__(292),
    identity = __webpack_require__(72),
    isArray = __webpack_require__(3),
    property = __webpack_require__(403);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(434));
__export(__webpack_require__(433));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.reactComponentId = '0d910c1c-13b9-4e1c-9aa4-b008c5e42d7d';
exports.reactDomComponentId = 'aa0a46ec-1505-43cd-a44a-93f3a5aa460a';
exports.officeUiFabricReactComponentId = '02a01e42-69ab-403d-8a16-acd128661f8e';
exports.spApplicationBaseComponentId = '4df9bb86-ab0a-4aab-ab5f-48bf167048fb';
exports.spLoaderComponentId = '1c6c9123-7aac-41f3-a376-3caea41ed83f';
exports.spCoreLibraryComponentId = '7263c7d0-1d6a-45ec-8d85-d4d1d234171b';
exports.spLodashSubsetComponentId = '73e1dc6c-8441-42cc-ad47-4bd3659f8a3a';
exports.spTelemetryComponentId = '8217e442-8ed3-41fd-957d-b112e841286a';
exports.odspUtilitiesBundleComponentId = 'cc2cc925-b5be-41bb-880a-f0f8030c6aff';
exports.spApplicationBaseName = '@microsoft/sp-application-base';


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:CoverageThreshold(96)

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var Manager_1 = __webpack_require__(16);
var CorrelationVector_1 = __webpack_require__(133);
var ObjectUtil_1 = __webpack_require__(17);
var Features_1 = __webpack_require__(52);
var _id = 0;
var ClonedEventType;
(function (ClonedEventType) {
    ClonedEventType[ClonedEventType["Single"] = 0] = "Single";
    ClonedEventType[ClonedEventType["Start"] = 1] = "Start";
    ClonedEventType[ClonedEventType["End"] = 2] = "End";
})(ClonedEventType = exports.ClonedEventType || (exports.ClonedEventType = {}));
var ValidationErrorType;
(function (ValidationErrorType) {
    ValidationErrorType[ValidationErrorType["NoParent"] = 1] = "NoParent";
})(ValidationErrorType = exports.ValidationErrorType || (exports.ValidationErrorType = {}));
var AccountType;
(function (AccountType) {
    AccountType[AccountType["Consumer"] = 0] = "Consumer";
    AccountType[AccountType["ConsumerAnonymous"] = 1] = "ConsumerAnonymous";
    AccountType[AccountType["Business"] = 2] = "Business";
    AccountType[AccountType["BusinessAnonymous"] = 3] = "BusinessAnonymous";
    AccountType[AccountType["Unknown"] = 4] = "Unknown";
})(AccountType = exports.AccountType || (exports.AccountType = {}));
function addEventProps(eventPrototype, props, metadata, baseClass) {
    ObjectUtil_1.extend(eventPrototype, props);
    var resultMetadata = {};
    for (var key in metadata) {
        var item = metadata[key];
        var result = resultMetadata[key] = (typeof item === 'number' ? { type: item } : item);
        result.definedInName = props.shortEventName;
        if (result.type === 2 /* Number */) {
            result.isMetric = true;
        }
    }
    eventPrototype.metadata = baseClass ? __assign({}, baseClass.prototype.metadata, resultMetadata) : resultMetadata;
}
exports.addEventProps = addEventProps;
var EventBase = (function () {
    function EventBase(data, startType, parent) {
        this.validationErrors = 0;
        this.data = {};
        this.id = _id++;
        this.enabled = this._isEnabled();
        // Set the parent id if needed
        if (parent) {
            this.parentId = parent.id;
        }
        else if (this.requiresParent) {
            this.addValidationError(ValidationErrorType.NoParent);
        }
        // Set the start time
        this.startTime = Manager_1.Manager.getTime();
        this.vector = new CorrelationVector_1.default(parent ? parent.vector : CorrelationVector_1.default.RootVector);
        // Set the data if we have it
        if (data) {
            this._setData(data);
        }
        // Send the start event
        this._logEvent(startType);
    }
    /**
     * This will return true if the event is enabled
     */
    EventBase.enabled = function () {
        return this.prototype._isEnabled();
    };
    /**
     * This will return true if the event is of this type
     * @param event {IEvent} The event to compare
     */
    EventBase.isTypeOf = function (event) {
        return event.eventName.indexOf(this.prototype.shortEventName + ',') >= 0;
    };
    EventBase.prototype._isEnabled = function () {
        // All events are enabled by default
        return !this.samplingFeature || Features_1.default.isFeatureEnabled(this.samplingFeature);
    };
    EventBase.prototype._setData = function (data) {
        var stored = this.data;
        for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key in this.metadata) {
                var value = data[key];
                switch (typeof value) {
                    case 'string':
                        stored[key] = Manager_1.Manager.cleanString(value);
                        break;
                    case 'undefined':
                        break;
                    default:
                        stored[key] = value;
                        break;
                }
            }
        }
    };
    EventBase.prototype._logEvent = function (eventType) {
        Manager_1.Manager.logEvent(this, eventType);
    };
    EventBase.prototype.addValidationError = function (type) {
        this.validationErrors = this.validationErrors | type;
        Manager_1.Manager.logValidationError(this, type);
    };
    return EventBase;
}());
exports.EventBase = EventBase;
var proto = EventBase.prototype;
proto.eventName = 'EventBase,';
proto.shortEventName = 'EventBase';
// All events are not critical by default
proto.critical = false;
// All events require parents by default
proto.requiresParent = true;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

// Regex that finds {#} so it can be replaced by the arguments in string format
var FORMAT_REGEX = /\{(\d+)\}/g;
/**
 * String Format is like C# string format. Use template strings instead unless the string is dynamic.
 * Usage Example: "hello {0}!".format("mike") will return "hello mike!"
 * Calling format on a string with less arguments than specified in the format will substitute "undefined"
 */
function format(template) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    return template.replace(FORMAT_REGEX, function (match, valueIndex) {
        var value = values[valueIndex];
        // Checking null for consistency with old behavior, all other values pass through.
        return value === null ? '' : value;
    });
}
exports.format = format;
/**
 * Returns an array made of replacemant values and string literal values, in order.
 * @param template Base string with replacement tokens.
 * @param values Array of values to insert into corresponding replacement token.
 */
function formatToArray(template) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var parts = [];
    var regexResult;
    var lastIndex = 0;
    while ((regexResult = FORMAT_REGEX.exec(template))) {
        // The full string of characters matched.
        var match = regexResult[0];
        // Get replacement value.
        var valueIndex = parseInt(match.replace(/\{|\}+/g, ''), 10);
        var replacementValue = values[valueIndex];
        // Get text between tokens and add to our array.
        if (regexResult.index > lastIndex) {
            parts.push(template.substring(lastIndex, regexResult.index));
        }
        // Save last index.
        lastIndex = FORMAT_REGEX.lastIndex;
        // Add replacement value to our array.
        parts.push(replacementValue);
    }
    // Grab any remaining text after the last match.
    if (lastIndex !== template.length) {
        parts.push(template.substring(lastIndex, template.length));
    }
    return parts;
}
exports.formatToArray = formatToArray;
/**
 * Returns true if s ends with suffix.
 */
function doesStringEndWith(s, suffix) {
    return s.substr(s.length - suffix.length) === suffix;
}
exports.doesStringEndWith = doesStringEndWith;
/**
 * Returns true if s starts with prefix.
 */
function doesStringStartWith(s, prefix) {
    return s.substr(0, prefix.length) === prefix;
}
exports.doesStringStartWith = doesStringStartWith;
/**
 * Return a string of the given length, using 0s to pad in from the right.
 */
function rightPad(data, length) {
    var result = data.toString();
    while (result.length < length) {
        result = result + "0";
    }
    return result;
}
exports.rightPad = rightPad;
/**
 * Look for any of the chars in searchValues in str.
 * Returns the index of the char found or -1 if nothing is found.
 */
function findOneOf(str, searchValues) {
    for (var idx = 0; idx < str.length; idx++) {
        if (searchValues.indexOf(str[idx]) >= 0) {
            return idx;
        }
    }
    return -1; //none of the searchValues exist in string
}
exports.findOneOf = findOneOf;
/**
 * Determines if two strings are equal when both converted to uppercase.
 */
function equalsCaseInsensitive(a, b) {
    if (a && b) {
        return a.toUpperCase() === b.toUpperCase();
    }
    return a === b;
}
exports.equalsCaseInsensitive = equalsCaseInsensitive;
/**
 * Capitalizes the first letter of str.
 */
function capitalize(str) {
    if (str) {
        return str[0].toUpperCase() + str.substr(1);
    }
    return str;
}
exports.capitalize = capitalize;
/**
 * De-capitalizes the first letter of str.
 */
function decapitalize(str) {
    if (str) {
        return str[0].toLowerCase() + str.substr(1);
    }
    return str;
}
exports.decapitalize = decapitalize;
/**
 * Selects a string based on plurality.
 *
 * @param count - The value to base selection on
 * @param single - The string to select when it's a singular value
 * @param multiple - The string to select when it's a plural value
 *
 * @deprecated This method does NOT give accurate results for many languages!!
 *             Use getLocalizedCountValue instead.
 */
function pluralSelect(count, single, plural) {
    return count === 1 ? single : plural;
}
exports.pluralSelect = pluralSelect;
/**
 * Given a specially formatted localized text, a set of intervals, and a count,
 * return the localized text which corresponds to the first interval the
 * count falls into.
 *
 * Please see https://microsoft.sharepoint.com/teams/OISGPortal/LocKits/_layouts/15/start.aspx#/Lockit%20Instructions/SharePoint%20Core%20Localization.aspx
 * for more details.
 *
 * @param {string} locText - || deliminated blocks of localized texts, representing
 *  the various singular and plural forms of the string  being localized
 * @param {string} intervals - || deliminated blocks of numeric intervals, defining the ranges
 *  of that interval. Has special support for , * and -.
 * @param {number} count - The count used to determine which interval to return.
 *
 * @return
 * The localized block which corresponds to the first interval the count falls into.
 *
 * @example
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 0)
 *   returns items
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 1)
 *   returns item
 * StringHelper.getLocalizedCountValue('items||item||items', '0||1||2-', 2)
 *   returns items
 */
function getLocalizedCountValue(locText, intervals, count) {
    'use strict';
    count = Number(count); // defensively make sure count is a number
    // !!!IMPORTANT!!! changes in this function need to be in sync with
    // the methods with the same name located at:
    // otools/inc/sts/stsom/utilities/SPLocUtility.cs
    // sts/Client/Script/Init/LocUtility.cs
    if (locText === undefined || intervals === undefined || count === undefined) {
        return null;
    }
    var ret = '';
    var locIndex = -1;
    var intervalsArray = intervals.split('||');
    for (var i = 0, length_1 = intervalsArray.length; i < length_1; i++) {
        var interval = intervalsArray[i];
        if (!interval) {
            continue;
        }
        var subIntervalsArray = interval.split(',');
        for (var _i = 0, subIntervalsArray_1 = subIntervalsArray; _i < subIntervalsArray_1.length; _i++) {
            var subInterval = subIntervalsArray_1[_i];
            if (!subInterval) {
                continue;
            }
            // there are three possiblities, wildcard, interval, or number
            if (isNaN(Number(subInterval))) {
                if (subInterval.indexOf('-') !== -1) {
                    // if it's an interval the format is Number-Number
                    var range = subInterval.split('-');
                    if (range.length !== 2) {
                        continue;
                    }
                    var min = void 0;
                    var max = void 0;
                    if (range[0] === '') {
                        min = 0;
                    }
                    else {
                        if (isNaN(Number(range[0]))) {
                            continue;
                        }
                        else {
                            min = parseInt(range[0], 10);
                        }
                    }
                    if (count >= min) {
                        if (range[1] === '') {
                            locIndex = i;
                            break;
                        }
                        else {
                            if (isNaN(Number(range[1]))) {
                                continue;
                            }
                            else {
                                max = parseInt(range[1], 10);
                            }
                        }
                        if (count <= max) {
                            locIndex = i;
                            break;
                        }
                    }
                }
                else if (subInterval.indexOf('*') !== -1) {
                    // Wildcard
                    var regexExpr = subInterval.trim().replace(/\*/g, '[0-9]*');
                    var regex = new RegExp("^" + regexExpr + "$");
                    if (regex.test(count.toString())) {
                        locIndex = i;
                        break;
                    }
                }
            }
            else {
                var exactNumber = parseInt(subInterval, 10);
                if (count === exactNumber) {
                    locIndex = i;
                    break;
                }
            }
        }
        if (locIndex !== -1) {
            break;
        }
    }
    if (locIndex !== -1) {
        var locValues = locText.split('||');
        if (locValues[locIndex]) {
            ret = locValues[locIndex];
        }
    }
    return ret;
}
exports.getLocalizedCountValue = getLocalizedCountValue;
/**
 * Format the locText with the localized count value.
 */
function formatWithLocalizedCountValue(locText, intervals, count) {
    'use strict';
    var template = getLocalizedCountValue(locText, intervals, count);
    var result = format(template, count.toString());
    return result;
}
exports.formatWithLocalizedCountValue = formatWithLocalizedCountValue;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A color represented by red, green, blue, and alpha (opacity) components.
 */
var RgbaColor = (function () {
    /** Constructs a default RgbaColor. Use RgbaColor.fromRgba to specify components. */
    function RgbaColor() {
        this.R = 0;
        this.G = 0;
        this.B = 0;
        this.A = RgbaColor.maxComponent; // Default to fully opaque.
    }
    /**
     * Creates a copy of the given color.
     * @param {RgbaColor} c The color to clone.
     */
    RgbaColor.clone = function (c) {
        return RgbaColor.fromRgba(c.R, c.G, c.B, c.A);
    };
    /**
     * Returns true if the colors have identical component values of R, G, B, and A.
     * @param {RgbaColor} c1 The first color to compare.
     * @param {RgbaColor} c2 The second color to compare.
     */
    RgbaColor.equals = function (c1, c2) {
        var c1IsNull = !c1;
        var c2IsNull = !c2;
        if (c1IsNull || c2IsNull) {
            return c1IsNull && c2IsNull;
        }
        else {
            return c1.R === c2.R && c1.G === c2.G && c1.B === c2.B && c1.A === c2.A;
        }
    };
    /**
     * Creates an RgbaColor from red, green, blue, and alpha component values.
     * @param {number} r The red component value (between 0 and 255).
     * @param {number} g The green component value (between 0 and 255).
     * @param {number} b The blue component value (between 0 and 255).
     * @param {number} a The alpha component value (between 0 and 255).
     */
    RgbaColor.fromRgba = function (r, g, b, a) {
        var colorObj = new RgbaColor;
        colorObj.R = Math.round(r);
        colorObj.G = Math.round(g);
        colorObj.B = Math.round(b);
        colorObj.A = a != null ? Math.round(a) : RgbaColor.maxComponent;
        return colorObj;
    };
    /**
     * Parses an HTML color string in the formats #AARRGGBB, #RRGGBB, or #RGB.
     * @param {string} htmlColor The HTML color string to parse.
     */
    RgbaColor.fromHtmlColor = function (htmlColor) {
        function TwoHexCharsToNumber(str, index1, index2) {
            return parseInt(str.charAt(index1) + str.charAt(index2), 16);
        }
        var resultColor = new RgbaColor;
        if (typeof htmlColor === "string" && htmlColor.charAt(0) === "#") {
            switch (htmlColor.length) {
                case 9:
                    resultColor.A = TwoHexCharsToNumber(htmlColor, 1, 2);
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 3, 4);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 5, 6);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 7, 8);
                    break;
                case 7:
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 1, 2);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 3, 4);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 5, 6);
                    break;
                case 4:
                    resultColor.R = TwoHexCharsToNumber(htmlColor, 1, 1);
                    resultColor.G = TwoHexCharsToNumber(htmlColor, 2, 2);
                    resultColor.B = TwoHexCharsToNumber(htmlColor, 3, 3);
                    break;
            }
        }
        return resultColor;
    };
    /**
     * Converts an RgbaColor into an HTML string suitable for use as a CSS color value.
     * @param {RgbaColor} c The color to convert.
     * @param {boolean} bFilterValue If true, this produces a string to in the #AARRGGBB format.
     */
    RgbaColor.toHtmlString = function (c, bFilterValue) {
        function ByteToHexString(b) {
            var byte = Number(b);
            if (!(byte >= 0 && byte <= RgbaColor.maxComponent)) {
                throw new Error("Argument must be a Number in [0, 255]");
            }
            var hex = byte.toString(16);
            if (byte < 16) {
                hex = "0" + hex;
            }
            return hex;
        }
        if (c.A < RgbaColor.maxComponent && !bFilterValue) {
            return "rgba(" +
                c.R.toString(10) + ", " +
                c.G.toString(10) + ", " +
                c.B.toString(10) + ", " +
                (c.A / RgbaColor.maxComponent).toFixed(2) + ")";
        }
        else {
            return "#" +
                (bFilterValue ? ByteToHexString(c.A) : "") +
                ByteToHexString(c.R) +
                ByteToHexString(c.G) +
                ByteToHexString(c.B);
        }
    };
    return RgbaColor;
}());
/**
 * The maximum value of an R, G, B, or A component in an RgbaColor.
 */
RgbaColor.maxComponent = 255;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RgbaColor;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(271);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

module.exports = baseRest;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(286),
    getValue = __webpack_require__(332);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(12),
    isObjectLike = __webpack_require__(19);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(189);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var StringsProxy_1 = __webpack_require__(13);
var Text = (function () {
    function Text() {
    }
    Text.format = function (s) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        if (s === null) {
            throw new Error(StringsProxy_1.default.isNullValidateError.replace('{0}', 's'));
        }
        if (s === undefined) {
            throw new Error(StringsProxy_1.default.isUndefinedValidateError.replace('{0}', 's'));
        }
        return s.replace(Text.FORMAT_REGEX, function (match) {
            var matchId = parseInt(match.replace(Text.FORMAT_ARGS_REGEX, ''), 10);
            var matchValue = values[matchId];
            if (matchId >= values.length || matchId < 0) {
                matchValue = match;
            }
            if (matchValue === null) {
                matchValue = 'null';
            }
            else if (matchValue === undefined) {
                matchValue = 'undefined';
            }
            return matchValue;
        });
    };
    return Text;
}());
Text.FORMAT_REGEX = /\{\d+\}/g;
Text.FORMAT_ARGS_REGEX = /[\{\}]/g;
exports.default = Text;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_30__;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SPComponentLoaderProxy_1 = __webpack_require__(74);
exports.SPComponentLoader = SPComponentLoaderProxy_1.default;
var DeveloperToolsProxy_1 = __webpack_require__(214);
exports.DeveloperTools = DeveloperToolsProxy_1.default;
var SPStarter_1 = __webpack_require__(115);
exports.SPStarter = SPStarter_1.default;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var telemetryConstants_1 = __webpack_require__(6);
var normalizeComponentId_1 = __webpack_require__(50);
var sp_core_library_2 = __webpack_require__(0);
var SPLoader_resx_1 = __webpack_require__(5);
var ComponentStore = (function () {
    function ComponentStore() {
        this._componentMap = new Map(); 
    }
    Object.defineProperty(ComponentStore, "instance", {
        get: function () {
            if (!ComponentStore._instance) {
                ComponentStore._instance = new ComponentStore();
            }
            return ComponentStore._instance;
        },
        enumerable: true,
        configurable: true
    });
    ComponentStore.prototype.getComponent = function (id, version) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        sp_core_library_1.Validate.isNonemptyString(version, 'version');
        return this._componentMap.get(this._getKey(id, version));
    };
    ComponentStore.prototype.tryGetComponentById = function (id, shouldLog) {
        if (shouldLog === void 0) { shouldLog = true; }
        try {
            return this._getComponentById(id, shouldLog);
        }
        catch (e) {
            return undefined;
        }
    };
    ComponentStore.prototype.getComponentById = function (id) {
        return this._getComponentById(id, true);
    };
    ComponentStore.prototype.storeComponent = function (id, version, modulePromise) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        sp_core_library_1.Validate.isNonemptyString(version, 'version');
        sp_core_library_1.Validate.isNotNullOrUndefined(modulePromise, 'module');
        var key = this._getKey(id, version);
        if (!this._componentMap.has(key)) {
            this._componentMap.set(key, modulePromise);
        }
    };
    ComponentStore.prototype.deleteComponent = function (id, version) {
        var key = this._getKey(id, version);
        if (this._componentMap.has(key)) {
            sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants_1.componentStoreLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.deleteComponentLog, id, version));
            this._componentMap.delete(key);
        }
    };
    ComponentStore.prototype._getComponentById = function (id, shouldLog) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        var returnValue = undefined;
        this._componentMap.forEach(function (value, index) {
            if (index.indexOf(id) === 0) {
                if (!returnValue) {
                    returnValue = value;
                }
                else {
                    var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.tooManyComponentsError, id));
                    if (shouldLog) {
                        sp_telemetry_1._TraceLogger.logError(telemetryConstants_1.componentStoreLogSource, error);
                    }
                    throw error;
                }
            }
        });
        if (!returnValue) {
            var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.noComponentFoundError, id));
            if (shouldLog) {
                sp_telemetry_1._TraceLogger.logError(telemetryConstants_1.componentStoreLogSource, error);
            }
            throw error;
        }
        return returnValue;
    };
    ComponentStore.prototype._getKey = function (id, version) {
        return normalizeComponentId_1.default(id, version);
    };
    return ComponentStore;
}());
exports.default = ComponentStore;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var PairedEventBase_1 = __webpack_require__(86);
var ResultTypeEnum_1 = __webpack_require__(34);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
exports.Qos = PairedEventBase_1.createPairedEvent({
    eventName: 'Qos,',
    shortEventName: 'Qos'
}, {
    name: {
        isKey: true,
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    resultCode: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    resultType: {
        typeRef: ResultTypeEnum_1.ResultTypeEnum,
        isPrefixingDisabled: true,
        type: 6 /* Enum */
    },
    error: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    extraData: 4 /* Object */,
    extraMetrics: {
        isPrefixingDisabled: true,
        type: 4 /* Object */
    }
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Qos;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ResultTypeEnum;
(function (ResultTypeEnum) {
    ResultTypeEnum[ResultTypeEnum["Success"] = 0] = "Success";
    ResultTypeEnum[ResultTypeEnum["Failure"] = 1] = "Failure";
    ResultTypeEnum[ResultTypeEnum["ExpectedFailure"] = 2] = "ExpectedFailure";
})(ResultTypeEnum = exports.ResultTypeEnum || (exports.ResultTypeEnum = {}));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DataStoreCachingType;
(function (DataStoreCachingType) {
    DataStoreCachingType[DataStoreCachingType["none"] = 0] = "none";
    DataStoreCachingType[DataStoreCachingType["session"] = 1] = "session";
    DataStoreCachingType[DataStoreCachingType["local"] = 2] = "local";
    DataStoreCachingType[DataStoreCachingType["sharedMemory"] = 3] = "sharedMemory";
})(DataStoreCachingType || (DataStoreCachingType = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DataStoreCachingType;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(160),
    isFlattenable = __webpack_require__(342);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(59);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(265),
    Map = __webpack_require__(90),
    Promise = __webpack_require__(267),
    Set = __webpack_require__(155),
    WeakMap = __webpack_require__(268),
    baseGetTag = __webpack_require__(279),
    toSource = __webpack_require__(181);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(3),
    isSymbol = __webpack_require__(47);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var asciiToArray = __webpack_require__(274),
    hasUnicode = __webpack_require__(66),
    unicodeToArray = __webpack_require__(369);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(47);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLikeObject = __webpack_require__(27);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

module.exports = isArguments;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var isObjectLike = __webpack_require__(19);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var assign = __webpack_require__(371);
exports.assign = assign;
var camelCase = __webpack_require__(374);
exports.camelCase = camelCase;
var chunk = __webpack_require__(376);
exports.chunk = chunk;
var clone = __webpack_require__(377);
exports.clone = clone;
var cloneDeep = __webpack_require__(378);
exports.cloneDeep = cloneDeep;
var constant = __webpack_require__(182);
exports.constant = constant;
var debounce = __webpack_require__(183);
exports.debounce = debounce;
var difference = __webpack_require__(380);
exports.difference = difference;
var differenceBy = __webpack_require__(381);
exports.differenceBy = differenceBy;
var differenceWith = __webpack_require__(382);
exports.differenceWith = differenceWith;
var each = __webpack_require__(383);
exports.each = each;
var escape = __webpack_require__(384);
exports.escape = escape;
var extend = __webpack_require__(385);
exports.extend = extend;
var findIndex = __webpack_require__(386);
exports.findIndex = findIndex;
var flatten = __webpack_require__(387);
exports.flatten = flatten;
var forIn = __webpack_require__(389);
exports.forIn = forIn;
var fromPairs = __webpack_require__(390);
exports.fromPairs = fromPairs;
var get = __webpack_require__(184);
exports.get = get;
var has = __webpack_require__(391);
exports.has = has;
var invert = __webpack_require__(393);
exports.invert = invert;
var isElement = __webpack_require__(394);
exports.isElement = isElement;
var isEmpty = __webpack_require__(395);
exports.isEmpty = isEmpty;
var isEqual = __webpack_require__(396);
exports.isEqual = isEqual;
var keys = __webpack_require__(11);
exports.keys = keys;
var merge = __webpack_require__(400);
exports.merge = merge;
var noop = __webpack_require__(188);
exports.noop = noop;
var once = __webpack_require__(402);
exports.once = once;
var random = __webpack_require__(404);
exports.random = random;
var round = __webpack_require__(405);
exports.round = round;
var set = __webpack_require__(406);
exports.set = set;
var sortBy = __webpack_require__(407);
exports.sortBy = sortBy;
var sumBy = __webpack_require__(410);
exports.sumBy = sumBy;
var throttle = __webpack_require__(411);
exports.throttle = throttle;
var times = __webpack_require__(412);
exports.times = times;
var toArray = __webpack_require__(413);
exports.toArray = toArray;
var toPairs = __webpack_require__(414);
exports.toPairs = toPairs;
var trimEnd = __webpack_require__(416);
exports.trimEnd = trimEnd;
var trimStart = __webpack_require__(417);
exports.trimStart = trimStart;
var truncate = __webpack_require__(418);
exports.truncate = truncate;
var unescape = __webpack_require__(419);
exports.unescape = unescape;
var uniq = __webpack_require__(420);
exports.uniq = uniq;
var update = __webpack_require__(421);
exports.update = update;
var without = __webpack_require__(424);
exports.without = without;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
function normalizeComponentId(id, version) {
    id = (typeof id === 'string') ? sp_core_library_1.Guid.parse(id) : id;
    version = (typeof version === 'string') ? sp_core_library_1.Version.parse(version) : version;
    return id.toString() + "_" + version.toString();
}
exports.default = normalizeComponentId;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * This file was originally ported from WinJS.
 */

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Async_1 = __webpack_require__(15);
var EventGroup_1 = __webpack_require__(127);
var async = new Async_1.default();
function doneHandler(value) {
    async.setImmediate(function () {
        throw value;
    });
}
var errorET = "error";
var canceledName = "Canceled";
var events;
//
// Global error counter, for each error which enters the system we increment this once and then
// the error number travels with the error as it traverses the tree of potential handlers.
//
// When someone has registered to be told about error [using EventGroup.on(Promise, 'error')] promises
// which are in error will get tagged with a ._errorId field. This tagged field is the
// contract by which nested promises with errors will be identified as chaining for the
// purposes of the callonerror semantics. If a nested promise in error is encountered without
// a ._errorId it will be assumed to be foreign and treated as an interop boundary and
// a new error id will be minted.
//
var error_number = 1;
;
var state_created; // -> working
var state_working; // -> error | error_notify | success | success_notify | canceled | waiting
var state_waiting; // -> error | error_notify | success | success_notify | waiting_canceled
var state_waiting_canceled; // -> error | error_notify | success | success_notify | canceling
var state_canceled; // -> error | error_notify | success | success_notify | canceling
var state_canceling; // -> error_notify
var state_success_notify; // -> success
var state_success; // -> .
var state_error_notify; // -> error
var state_error; // -> .
// Noop function, used in the various states to indicate that they don't support a given
// message. Named with the somewhat cute name '_' because it reads really well in the states.
function _() {
    "use strict";
}
// Initial state
//
state_created = {
    name: "created",
    enter: function (promise) {
        promise._setState(state_working);
    },
    cancel: _,
    done: _,
    then: _,
    _completed: _,
    _error: _,
    _notify: _,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Ready state, waiting for a message (completed/error), able to be canceled
//
state_working = {
    name: "working",
    enter: _,
    cancel: function (promise) {
        promise._setState(state_canceled);
    },
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Waiting state, if a promise is completed with a value which is itself a promise
// (has a then() method) it signs up to be informed when that child promise is
// fulfilled at which point it will be fulfilled with that value.
//
state_waiting = {
    name: "waiting",
    enter: function (promise) {
        var waitedUpon = promise._value;
        // We can special case our own intermediate promises which are not in a
        //  terminal state by just pushing this promise as a listener without
        //  having to create new indirection functions
        if (waitedUpon instanceof ThenPromise &&
            waitedUpon._state !== state_error &&
            waitedUpon._state !== state_success) {
            pushListener(waitedUpon, { promise: promise });
        }
        else {
            var error_1 = function (value) {
                if (waitedUpon._errorId) {
                    promise._chainedError(value, waitedUpon);
                }
                else {
                    // Because this is an interop boundary we want to indicate that this
                    //  error has been handled by the promise infrastructure before we
                    //  begin a new handling chain.
                    //
                    callonerror(promise, value, detailsForHandledError, waitedUpon, error_1);
                    promise._error(value);
                }
            };
            error_1.handlesOnError = true;
            waitedUpon.then(promise._completed.bind(promise), error_1);
        }
    },
    cancel: function (promise) {
        promise._setState(state_waiting_canceled);
    },
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Waiting canceled state, when a promise has been in a waiting state and receives a
// request to cancel its pending work it will forward that request to the child promise
// and then waits to be informed of the result. This promise moves itself into the
// canceling state but understands that the child promise may instead push it to a
// different state.
//
state_waiting_canceled = {
    name: "waiting_canceled",
    enter: function (promise) {
        // Initiate a transition to canceling. Triggering a cancel on the promise
        // that we are waiting upon may result in a different state transition
        // before the state machine pump runs again.
        promise._setState(state_canceling);
        var waitedUpon = promise._value;
        if (waitedUpon.cancel) {
            waitedUpon.cancel();
        }
    },
    cancel: _,
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Canceled state, moves to the canceling state and then tells the promise to do
// whatever it might need to do on cancelation.
//
state_canceled = {
    name: "canceled",
    enter: function (promise) {
        // Initiate a transition to canceling. The _cancelAction may change the state
        // before the state machine pump runs again.
        promise._setState(state_canceling);
        promise._cancelAction();
    },
    cancel: _,
    done: done,
    then: then,
    _completed: completed,
    _error: error,
    _notify: _,
    _setCompleteValue: setCompleteValue,
    _setErrorValue: setErrorValue
};
// Canceling state, commits to the promise moving to an error state with an error
// object whose 'name' and 'message' properties contain the string "Canceled"
//
state_canceling = {
    name: "canceling",
    enter: function (promise) {
        var error = new Error(canceledName);
        error.name = error.message;
        error["_handled"] = true;
        promise._value = error;
        promise._setState(state_error_notify);
    },
    cancel: _,
    done: _,
    then: _,
    _completed: _,
    _error: _,
    _notify: _,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Success notify state, moves a promise to the success state and notifies all children
//
state_success_notify = {
    name: "complete_notify",
    enter: function (promise) {
        promise.done = CompletePromise.prototype.done;
        promise.then = CompletePromise.prototype.then;
        if (promise._listeners) {
            var queue = [promise];
            var p = void 0;
            while (queue.length) {
                p = queue.shift();
                p._state._notify(p, queue);
            }
        }
        promise._setState(state_success);
    },
    cancel: _,
    done: null,
    then: null,
    _completed: _,
    _error: _,
    _notify: notifySuccess,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Success state, moves a promise to the success state and does NOT notify any children.
// Some upstream promise is owning the notification pass.
//
state_success = {
    name: "success",
    enter: function (promise) {
        promise.done = CompletePromise.prototype.done;
        promise.then = CompletePromise.prototype.then;
        promise._cleanupAction();
    },
    cancel: _,
    done: null,
    then: null,
    _completed: _,
    _error: _,
    _notify: notifySuccess,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Error notify state, moves a promise to the error state and notifies all children
//
state_error_notify = {
    name: "error_notify",
    enter: function (promise) {
        promise.done = ErrorPromise.prototype.done;
        promise.then = ErrorPromise.prototype.then;
        if (promise._listeners) {
            var queue = [promise];
            var p = void 0;
            while (queue.length) {
                p = queue.shift();
                p._state._notify(p, queue);
            }
        }
        promise._setState(state_error);
    },
    cancel: _,
    done: null,
    then: null,
    _completed: _,
    _error: _,
    _notify: notifyError,
    _setCompleteValue: _,
    _setErrorValue: _
};
// Error state, moves a promise to the error state and does NOT notify any children.
// Some upstream promise is owning the notification pass.
//
state_error = {
    name: "error",
    enter: function (promise) {
        promise.done = ErrorPromise.prototype.done;
        promise.then = ErrorPromise.prototype.then;
        promise._cleanupAction();
    },
    cancel: _,
    done: null,
    then: null,
    _completed: _,
    _error: _,
    _notify: notifyError,
    _setCompleteValue: _,
    _setErrorValue: _
};
//
// The statemachine implementation follows a very particular pattern, the states are specified
// as static stateless bags of functions which are then indirected through the state machine
// instance (a Promise). As such all of the functions on each state have the promise instance
// passed to them explicitly as a parameter and the Promise instance members do a little
// dance where they indirect through the state and insert themselves in the argument list.
//
// We could instead call directly through the promise states however then every caller
// would have to remember to do things like pumping the state machine to catch state transitions.
//
//
// Implementations of shared state machine code.
//
function completed(promise, value) {
    promise._value = value;
    promise._setState(Promise.is(value) ? state_waiting : state_success_notify);
}
function createErrorDetails(exception, error, promise, id, parent, handler) {
    return {
        exception: exception,
        error: error,
        promise: promise,
        handler: handler,
        id: id,
        parent: parent
    };
}
function detailsForHandledError(promise, errorValue, context, handler) {
    var exception = context._isException;
    var errorId = context._errorId;
    return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context, handler);
}
function detailsForChainedError(promise, errorValue, context) {
    var exception = context._isException;
    var errorId = context._errorId;
    setErrorInfo(promise, errorId, exception);
    return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context);
}
function detailsForError(promise, errorValue) {
    var errorId = ++error_number;
    setErrorInfo(promise, errorId);
    return createErrorDetails(null, errorValue, promise, errorId);
}
function detailsForException(promise, exceptionValue) {
    var errorId = ++error_number;
    setErrorInfo(promise, errorId, true);
    return createErrorDetails(exceptionValue, null, promise, errorId);
}
function done(promise, onComplete, onError) {
    pushListener(promise, { c: onComplete, e: onError });
}
function error(promise, value, onerrorDetails, context) {
    promise._value = value;
    callonerror(promise, value, onerrorDetails, context);
    promise._setState(state_error_notify);
}
function notifySuccess(promise, queue) {
    var value = promise._value;
    var listeners = promise._listeners;
    if (!listeners) {
        return;
    }
    promise._listeners = null;
    var i;
    var len;
    for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
        var listener = len === 1 ? listeners : listeners[i];
        var onComplete = listener.c;
        var target = listener.promise;
        if (target) {
            try {
                target._setCompleteValue(onComplete ? onComplete(value) : value);
            }
            catch (ex) {
                target._setExceptionValue(ex);
            }
            if (target._state !== state_waiting && target._listeners) {
                queue.push(target);
            }
        }
        else {
            CompletePromise.prototype.done.call(promise, onComplete);
        }
    }
}
function notifyError(promise, queue) {
    var value = promise._value;
    var listeners = promise._listeners;
    if (!listeners) {
        return;
    }
    promise._listeners = null;
    var i;
    var len;
    for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
        var listener = len === 1 ? listeners : listeners[i];
        var onError = listener.e;
        var target = listener.promise;
        if (target) {
            var asyncCallbackStarted = false;
            try {
                if (onError) {
                    asyncCallbackStarted = true;
                    if (!onError.handlesOnError) {
                        callonerror(target, value, detailsForHandledError, promise, onError);
                    }
                    target._setCompleteValue(onError(value));
                }
                else {
                    target._setChainedErrorValue(value, promise);
                }
            }
            catch (ex) {
                target._setExceptionValue(ex);
            }
            if (target._state !== state_waiting && target._listeners) {
                queue.push(target);
            }
        }
        else {
            ErrorPromise.prototype.done.call(promise, null, onError);
        }
    }
}
function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
    if (value instanceof Error && value.message === canceledName) {
        return;
    }
    events.raise(errorET, onerrorDetailsGenerator(promise, value, context, handler));
}
function pushListener(promise, listener) {
    var listeners = promise._listeners;
    if (listeners) {
        // We may have either a single listener (which will never be wrapped in an array)
        // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
        // we may have to wrap the single listener before adding the second.
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        listeners.push(listener);
    }
    else {
        listeners = listener;
    }
    promise._listeners = listeners;
}
// The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
// a promise directly to the success/error state without starting another notification pass (because one
// is already ongoing).
function setErrorInfo(promise, errorId, isException) {
    promise._isException = isException || false;
    promise._errorId = errorId;
}
function setErrorValue(promise, value, onerrorDetails, context) {
    promise._value = value;
    callonerror(promise, value, onerrorDetails, context);
    promise._setState(state_error);
}
function setCompleteValue(promise, value) {
    var targetState;
    if (Promise.is(value)) {
        targetState = state_waiting;
    }
    else {
        targetState = state_success;
    }
    promise._value = value;
    promise._setState(targetState);
}
function then(promise, onComplete, onError) {
    var result = new ThenPromise(promise);
    pushListener(promise, { promise: result, c: onComplete, e: onError });
    return result;
}
//
// Slim promise implementations for already completed promises, these are created
// under the hood on synchronous completion paths as well as by Promise.wrap
// and Promise.wrapError.
//
var ErrorPromise = (function () {
    function ErrorPromise(value, errorFunc) {
        if (errorFunc === void 0) { errorFunc = detailsForError; }
        this._value = value;
        callonerror(this, value, errorFunc);
    }
    ErrorPromise.prototype.cancel = function () {
        /* No-op */
    };
    ErrorPromise.prototype.done = function (unused, onError) {
        var value = this._value;
        if (onError) {
            try {
                if (!onError.handlesOnError) {
                    callonerror(null, value, detailsForHandledError, this, onError);
                }
                var result = onError(value);
                if (Promise.is(result)) {
                    // If a promise is returned we need to wait on it.
                    result.done();
                }
                return;
            }
            catch (ex) {
                value = ex;
            }
        }
        if (value instanceof Error && value.message === canceledName) {
            // suppress cancel
            return;
        }
        // force the exception to be thrown asyncronously to avoid any try/catch blocks
        //
        doneHandler(value);
    };
    ErrorPromise.prototype.then = function (unused, onError) {
        // If the promise is already in a error state and no error handler is provided
        // we optimize by simply returning the promise instead of creating a new one.
        //
        if (!onError) {
            return this;
        }
        var result;
        var value = this._value;
        try {
            if (!onError.handlesOnError) {
                callonerror(null, value, detailsForHandledError, this, onError);
            }
            result = new CompletePromise(onError(value));
        }
        catch (ex) {
            // If the value throw from the error handler is the same as the value
            // provided to the error handler then there is no need for a new promise.
            //
            if (ex === value) {
                result = this;
            }
            else {
                result = new ExceptionPromise(ex);
            }
        }
        return result;
    };
    return ErrorPromise;
}());
var ExceptionPromise = (function (_super) {
    __extends(ExceptionPromise, _super);
    function ExceptionPromise(value) {
        return _super.call(this, value, detailsForException) || this;
    }
    return ExceptionPromise;
}(ErrorPromise));
var CompletePromise = (function () {
    function CompletePromise(value) {
        if (Promise.is(value)) {
            var result = new ThenPromise(undefined);
            result._setCompleteValue(value);
            return result;
        }
        this._value = value;
    }
    CompletePromise.prototype.cancel = function () {
        /* No-op */
    };
    CompletePromise.prototype.done = function (onComplete) {
        if (!onComplete) {
            return;
        }
        try {
            var result = onComplete(this._value);
            if (Promise.is(result)) {
                result.done();
            }
        }
        catch (ex) {
            // force the exception to be thrown asynchronously to avoid any try/catch blocks
            doneHandler(ex);
        }
    };
    CompletePromise.prototype.then = function (onComplete) {
        var resultPromise;
        try {
            // If the value returned from the completion handler is the same as the value
            // provided to the completion handler then there is no need for a new promise.
            //
            var newValue = onComplete ? onComplete(this._value) : this._value;
            resultPromise = newValue === this._value ? this : new CompletePromise(newValue);
        }
        catch (ex) {
            resultPromise = new ExceptionPromise(ex);
        }
        return resultPromise;
    };
    return CompletePromise;
}());
function timeout(timeoutMS) {
    var id;
    return new Promise(function (c) {
        if (timeoutMS) {
            id = async.setTimeout(c, timeoutMS);
        }
        else {
            async.setImmediate(c);
        }
    }, function () {
        if (id) {
            async.clearTimeout(id);
        }
    });
}
function timeoutWithPromise(timeout, promise) {
    var cancelPromise = function () { promise.cancel(); };
    var cancelTimeout = function () { timeout.cancel(); };
    timeout.then(cancelPromise);
    promise.then(cancelTimeout, cancelTimeout);
    return promise;
}
function getCancelAll(values) {
    return function () {
        for (var _i = 0, _a = Object.keys(values); _i < _a.length; _i++) {
            var key = _a[_i];
            var promise = Promise.as(values[key]);
            if (typeof promise.cancel === "function") {
                promise.cancel();
            }
        }
    };
}
var staticCanceledPromise;
var Promise = (function () {
    function Promise(init, oncancel) {
        this._init(init, oncancel);
    }
    Object.defineProperty(Promise, "cancel", {
        get: function () {
            return staticCanceledPromise || (staticCanceledPromise = new ErrorPromise(canceledName));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a promise that is fulfilled when one of the input promises
     * has been fulfilled.
     */
    Promise.any = function (values) {
        return new Promise(function (complete, error) {
            var keys = Object.keys(values);
            var pending = keys.length;
            if (pending === 0) {
                complete();
            }
            var _loop_1 = function (key) {
                Promise.as(values[key]).then(function () { complete({ key: key, value: values[key] }); }, function (e) {
                    if (e instanceof Error && e.name === canceledName) {
                        if (--pending === 0) {
                            complete(Promise.cancel);
                        }
                        return;
                    }
                    error({ key: key, value: values[key] });
                });
            };
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                _loop_1(key);
            }
        }, getCancelAll(values));
    };
    /**
     * Returns a promise. If the object is already a promise it is returned;
     * otherwise the object is wrapped in a promise.
     */
    Promise.as = function (value) {
        return Promise.is(value) ? value : new CompletePromise(value);
    };
    /**
     * Determines whether a value fulfills the promise contract.
     */
    Promise.is = function (value) {
        return value && typeof value === "object" && typeof value.then === "function";
    };
    /**
     * Determines whether an error value represents a promise cancellation.
     */
    Promise.isCanceled = function (e) {
        return (e instanceof Error && e.name === canceledName);
    };
    Promise.all = function (values) {
        return new Promise(function (complete, error) {
            var keys = Object.keys(values);
            var errors = Array.isArray(values) ? [] : {};
            var results = Array.isArray(values) ? [] : {};
            var pending = keys.length;
            var argDone = function () {
                if ((--pending) === 0) {
                    var errorKeys = Object.keys(errors);
                    var errorCount = errorKeys.length;
                    if (errorCount === 0) {
                        complete(results);
                    }
                    else {
                        if (errorKeys.every(function (key) { return Promise.isCanceled(errors[key]); })) {
                            complete(Promise.cancel);
                        }
                        else {
                            error(errors);
                        }
                    }
                }
            };
            var _loop_2 = function (key) {
                var value = values[key];
                if (value === undefined) {
                    pending--;
                }
                else {
                    Promise.then(value, function (result) { results[key] = result; argDone(); }, function (error) { errors[key] = error; argDone(); });
                }
            };
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                _loop_2(key);
            }
            if (pending === 0) {
                complete(results);
            }
        }, getCancelAll(values));
    };
    Promise.then = function (value, onComplete, onError) {
        return Promise.as(value).then(onComplete, onError);
    };
    Promise.thenEach = function (values, onComplete, onError) {
        var result = Array.isArray(values) ? [] : {};
        for (var _i = 0, _a = Object.keys(values); _i < _a.length; _i++) {
            var key = _a[_i];
            result[key] = Promise.then(values[key], onComplete, onError);
        }
        return Promise.all(result);
    };
    Promise.serial = function (tasks) {
        return tasks.reduce(function (previous, task) {
            return previous.then(task);
        }, Promise.wrap());
    };
    /**
     * Creates a promise that is fulfilled after a timeout.
     */
    Promise.timeout = function (time, promise) {
        var to = timeout(time);
        return promise ? timeoutWithPromise(to, promise) : to;
    };
    /**
     * Wraps a non-promise value in a promise. You can use this function if you need
     * to pass a value to a function that requires a promise.
     */
    Promise.wrap = function (value) {
        return new CompletePromise(value);
    };
    /**
     * Wraps a non-promise error value in a promise. You can use this function if you need
     * to pass an error to a function that requires a promise.
     */
    Promise.wrapError = function (error) {
        return new ErrorPromise(error);
    };
    /**
     * Attempts to cancel the fulfillment of a promised value. If the promise hasn't
     * already been fulfilled and cancellation is supported, the promise enters
     * the error state with a value of Error("Canceled").
     */
    Promise.prototype.cancel = function () {
        this._state.cancel(this);
        this._run();
    };
    /**
     * Allows you to specify the work to be done on the fulfillment of the promised value,
     * the error handling to be performed if the promise fails to fulfill
     * a value.
     *
     * After the handlers have finished executing, this function throws any error that would have been returned
     * from then() as a promise in the error state.
     *
     * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The fulfilled value is passed as the single argument. If the value is null, the fulfilled value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while executing the function, the promise returned by then moves into the error state.
     * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. If it is null, the error is forwarded. The value returned from the function is the fulfilled value of the promise returned by then.
     */
    Promise.prototype.done = function (onComplete, onError) {
        this._state.done(this, onComplete, onError);
    };
    /**
     * Allows you to specify the work to be done on the fulfillment of the promised value,
     * the error handling to be performed if the promise fails to fulfill
     * a value.
     *
     * @param onComplete The function to be called if the promise is fulfilled successfully with a value. The value is passed as the single argument. If the value is null, the value is returned. The value returned from the function becomes the fulfilled value of the promise returned by then. If an exception is thrown while this function is being executed, the promise returned by then moves into the error state.
     * @param onError The function to be called if the promise is fulfilled with an error. The error is passed as the single argument. In different cases this object may be of different types, so it is necessary to test the object for the properties you expect. If the error is null, it is forwarded. The value returned from the function becomes the value of the promise returned by the then function.
     * @returns The promise whose value is the result of executing the complete or error function.
     */
    Promise.prototype.then = function (onComplete, onError) {
        return this._state.then(this, onComplete, onError);
    };
    Promise.prototype._init = function (init, oncancel) {
        this._oncancel = oncancel;
        this._setState(state_created);
        this._run();
        try {
            init(this._completed.bind(this), this._error.bind(this));
        }
        catch (ex) {
            this._setExceptionValue(ex);
        }
    };
    Promise.prototype._cancelAction = function () {
        if (this._oncancel) {
            try {
                this._oncancel();
            }
            catch (ex) { }
        }
    };
    Promise.prototype._cleanupAction = function () {
        this._oncancel = null;
    };
    Promise.prototype._chainedError = function (value, context) {
        var result = this._state._error(this, value, detailsForChainedError, context);
        this._run();
        return result;
    };
    Promise.prototype._completed = function (value) {
        var result = this._state._completed(this, value);
        this._run();
        return result;
    };
    Promise.prototype._error = function (value) {
        var result = this._state._error(this, value, detailsForError);
        this._run();
        return result;
    };
    Promise.prototype._setState = function (state) {
        this._nextState = state;
    };
    Promise.prototype._setCompleteValue = function (value) {
        this._state._setCompleteValue(this, value);
        this._run();
    };
    Promise.prototype._setChainedErrorValue = function (value, context) {
        var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
        this._run();
        return result;
    };
    Promise.prototype._setExceptionValue = function (value) {
        var result = this._state._setErrorValue(this, value, detailsForException);
        this._run();
        return result;
    };
    Promise.prototype._run = function () {
        while (this._nextState) {
            this._state = this._nextState;
            this._nextState = null;
            this._state.enter(this);
        }
    };
    return Promise;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Promise;
events = new EventGroup_1.default(Promise);
events.declare(errorET);
//
// Internal implementation detail promise, ThenPromise is created when a promise needs
// to be returned from a then() method.
//
var ThenPromise = (function (_super) {
    __extends(ThenPromise, _super);
    function ThenPromise(creator) {
        var _this = _super.call(this) || this;
        _this._creator = creator;
        _this._initThen();
        return _this;
    }
    ThenPromise.prototype._init = function () {
        // Override to do nothing.
    };
    ThenPromise.prototype._cancelAction = function () {
        if (this._creator) {
            this._creator.cancel();
        }
    };
    ThenPromise.prototype._cleanupAction = function () {
        this._creator = null;
    };
    ThenPromise.prototype._initThen = function () {
        this._setState(state_created);
        this._run();
    };
    return ThenPromise;
}(Promise));
var SignalPromise = (function (_super) {
    __extends(SignalPromise, _super);
    function SignalPromise(cancel) {
        var _this = _super.call(this) || this;
        _this._oncancel = cancel;
        _this._initSignal();
        return _this;
    }
    SignalPromise.prototype._init = function () {
        // Override to do nothing.
    };
    SignalPromise.prototype._cancelAction = function () {
        if (this._oncancel) {
            this._oncancel();
        }
    };
    SignalPromise.prototype._cleanupAction = function () {
        this._oncancel = null;
    };
    SignalPromise.prototype._initSignal = function () {
        this._setState(state_created);
        this._run();
    };
    return SignalPromise;
}(Promise));
exports.SignalPromise = SignalPromise;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

;
/**
 * This file contains the known list of features (a.k.a. flights or ramps).
 * The signature of one entry is:
 *  static FeatureName: IFlight = { ODB: 100, ODC: "foo", Fallback: true };
 * ODB            Is the numerical value of the flight from the ExpFeature enumeration.
 *                Omit if the flight does not have a correspondent in ODB.
 * ODC            Is the string identifier in ODC.
 *                Omit if the flight does not have a correspondent ramp in ODC.
 * Fallback       The state of the flight, true = on false = off.
 *                The fallback is used only when the ODB or ODC flight is not applicable.
 *                For example: The Flight is an ODB flight with no ODC counterpart and the app runs in ODC mode.
 *                The fallback also allows declaring app only switches that are not known to the backend.
 *                Omit if false.
 */
var Features = (function () {
    function Features() {
    }
    /**
     * Performs the initialization of the client side features for
     * SP and ODB in scenarios where the window['_spPageContextInfo']
     * is not available.
     *
     * @param {number[]} expFeatures - The bit map of the client side features
     * usually provided by the ISPPageContext.
     *
     * @example initSPExpFeatures(pageContextInfo.ExpFeatures)
     */
    Features.initSPExpFeatures = function (expFeatures) {
        Features._expFeatures = expFeatures;
    };
    /**
     * This function will return true when the feature is enabled and
     * will check the proper config for SP,ODB and/or ODC to determine.
     *
     * @requires In scenarios where the window['_spPagecontextInfo'] might not exist
     * this function requires initSPExpFeatures before checing the state of ODB features.
     *
     * @param {IFeature} feature - the feature to be checked if enabled.
     * @return {boolean} - True if the feature is found active.
     */
    Features.isFeatureEnabled = function (feature) {
        var result = !!feature.Fallback;
        // ODC initialization
        var _odcFlightInfo = window['Flight'];
        var _odcConfig = window['FilesConfig'];
        // SP/ODB: for backward compatibility,
        // if _spPageContextInfo is still available
        // this performs the initialization of the _expFeatures.
        var _flighting = window['Flighting']; // Old SharePoint pages use this.
        var _spPageContextInfo = window['_spPageContextInfo'];
        if (!Features._expFeatures && _spPageContextInfo) {
            if (!_spPageContextInfo.ExpFeatures &&
                _flighting && _flighting.ExpFeatures) {
                _spPageContextInfo.ExpFeatures = _flighting.ExpFeatures;
            }
            Features.initSPExpFeatures(_spPageContextInfo.ExpFeatures);
        }
        var odb = feature.ODB;
        if (typeof odb === 'boolean') {
            result = odb;
        }
        else if (odb > 0 && Features._expFeatures) {
            var elem = Math.floor(odb / 32);
            var mask = 1 << (odb % 32);
            result = (elem < Features._expFeatures.length) &&
                (Features._expFeatures[elem] & mask) !== 0;
        }
        if (feature.ODC && !!_odcConfig) {
            if (typeof feature.ODC === 'boolean') {
                result = feature.ODC;
            }
            else if (_odcFlightInfo && _odcFlightInfo.Ramps && _odcFlightInfo.Ramps[feature.ODC]) {
                result = true;
            }
            else if (_odcConfig && _odcConfig[feature.ODC]) {
                result = true;
            }
        }
        return result;
    };
    return Features;
}());
/* This feature is always on */
Features.On = { Fallback: true };
/* This feature is always off */
Features.Off = {};
//You should not add features here but in your own file
Features._expFeatures = null;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Features;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var PairedEventBase_1 = __webpack_require__(86);
exports.Beacon = PairedEventBase_1.createPairedEvent({
    eventName: 'Beacon,',
    shortEventName: 'Beacon',
    requiresParent: false
}, {
    name: 1 /* String */,
    status: 1 /* String */,
    success: 3 /* Boolean */,
    retryCount: 2 /* Number */,
    totalRetries: 2 /* Number */,
    eventCount: 2 /* Number */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Beacon;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.Engagement = SingleEventBase_1.createSingleEvent({
    eventName: 'Engagement,',
    shortEventName: 'Engagement'
}, {
    name: {
        isKey: true,
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    isIntentional: {
        isPrefixingDisabled: true,
        type: 3 /* Boolean */
    },
    scenario: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    location: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    usageType: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    currentPage: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    previousPage: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    experiment: {
        isPrefixingDisabled: true,
        type: 4 /* Object */
    },
    siteId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    webId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    listId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    groupId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    docId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    webTemplateId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    listTemplateId: {
        isPrefixingDisabled: true,
        type: 1 /* String */
    },
    extraData: 4 /* Object */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Engagement;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DataStoreCachingType_1 = __webpack_require__(35);
// DataStore class is used for transparent caching of data in memory and/or browser storage
// - Parameter defaultCachingType defines whether you want to use browser storage for all operations
// and which type of storage - session or local
// - Parameter dataStoreKey is used to prefix every key in browser storage. Actual key for browser storage
// will be dataStoreKey + key used in setValue method.
// - If DataStore is instantiated with some type of browser caching enabled - it will test if browser storage
// is available and use it. If it's not it will fall back to in-memory cache.
// - If DataStore is instantiated from two different places with same dataStoreKey and some type of
// browser storage caching, the memory storage will be shared as well as browser storage.
var DataStore = (function () {
    function DataStore(dataStoreKey, defaultCachingType) {
        if (defaultCachingType === void 0) { defaultCachingType = DataStoreCachingType_1.default.none; }
        DataStore.init();
        this.dataStoreKey = dataStoreKey;
        this.defaultCachingType = defaultCachingType;
        if (defaultCachingType === DataStoreCachingType_1.default.none) {
            this.dataStore = {};
        }
        else {
            var store = DataStore._dataStore[this.dataStoreKey];
            if (store === undefined) {
                DataStore._dataStore[this.dataStoreKey] = {};
            }
            this.dataStore = DataStore._dataStore[this.dataStoreKey];
        }
    }
    DataStore.hasStorageType = function (storageType) {
        DataStore.init();
        switch (storageType) {
            case DataStoreCachingType_1.default.none: return true;
            case DataStoreCachingType_1.default.sharedMemory: return true;
            case DataStoreCachingType_1.default.session: return !!DataStore._sessionStorage;
            case DataStoreCachingType_1.default.local: return !!DataStore._localStorage;
        }
        return false;
    };
    DataStore.init = function () {
        if (DataStore._initialized) {
            return;
        }
        // Need a try/catch since window.localStorage can throw.
        try {
            if ('localStorage' in window && window.localStorage && DataStore.testStorage(window.localStorage)) {
                DataStore._localStorage = window.localStorage;
            }
        }
        catch (exUsingLocalStorage) {
        }
        try {
            if ('sessionStorage' in window && window.sessionStorage && DataStore.testStorage(window.sessionStorage)) {
                DataStore._sessionStorage = window.sessionStorage;
            }
        }
        catch (exUsingSessionStorage) {
        }
        // Fallback logic
        if (DataStore._localStorage == null) {
            DataStore._localStorage = DataStore._sessionStorage;
        }
        DataStore._initialized = true;
    };
    /** Need to check whether the value in localStorage is of the correct type.
     * In Private Browsing in Safari, for example, localStorage is accessible,
     * but all of the non-built-in properties return undefined, and setting
     * such a property causes an exception.
     */
    DataStore.testStorage = function (storage) {
        var _testKey = "BrowserStorageTest";
        var _testValue = "1";
        var result = false;
        try {
            storage.setItem(_testKey, _testValue);
            if (storage.getItem(_testKey) === _testValue) {
                result = true;
            }
            storage.removeItem(_testKey);
        }
        catch (e) { }
        return result;
    };
    DataStore.prototype.setValue = function (key, value, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        this.dataStore[key] = value;
        var storage = this.getStorage(cachingTypeOverride);
        if (storage) {
            try {
                var objectsFound = [];
                var s = JSON.stringify(value, function (key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (objectsFound.indexOf(value) !== -1) {
                            // discard the key if circular dependency was found
                            return;
                        }
                        // Otherwise store value in the cache
                        objectsFound.push(value);
                    }
                    return value;
                });
                // empty cache
                objectsFound = null;
                storage.setItem(this.dataStoreKey + key, s);
            }
            catch (e) {
            }
        }
    };
    DataStore.prototype.getValue = function (key, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        var value = this.dataStore[key];
        var storage = this.getStorage(cachingTypeOverride);
        if (value === undefined && storage) {
            var s = storage.getItem(this.dataStoreKey + key);
            if (s) {
                try {
                    value = JSON.parse(s);
                    this.dataStore[key] = value;
                }
                catch (e) {
                    value = undefined;
                }
            }
        }
        return value;
    };
    DataStore.prototype.remove = function (key, cachingTypeOverride, normalizeKey) {
        if (normalizeKey === void 0) { normalizeKey = true; }
        key = normalizeKey ? this.normalizeKey(key) : key;
        var storage = this.getStorage(cachingTypeOverride);
        if (storage) {
            storage.removeItem(this.dataStoreKey + key);
        }
        delete this.dataStore[key];
    };
    DataStore.prototype.getStorage = function (cachingTypeOverride) {
        var cachingType = cachingTypeOverride ? cachingTypeOverride : this.defaultCachingType;
        switch (cachingType) {
            case DataStoreCachingType_1.default.none:
                return null;
            case DataStoreCachingType_1.default.sharedMemory:
                return null;
            case DataStoreCachingType_1.default.session:
                return DataStore._sessionStorage;
            case DataStoreCachingType_1.default.local:
                return DataStore._localStorage;
        }
        return null;
    };
    DataStore.prototype.normalizeKey = function (key) {
        return key && key.toLowerCase() || '';
    };
    return DataStore;
}());
DataStore._sessionStorage = null;
DataStore._localStorage = null;
DataStore._dataStore = {};
DataStore._initialized = false;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DataStore;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(346),
    listCacheDelete = __webpack_require__(347),
    listCacheGet = __webpack_require__(348),
    listCacheHas = __webpack_require__(349),
    listCacheSet = __webpack_require__(350);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(56),
    stackClear = __webpack_require__(360),
    stackDelete = __webpack_require__(361),
    stackGet = __webpack_require__(362),
    stackHas = __webpack_require__(363),
    stackSet = __webpack_require__(364);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 58 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(45);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

module.exports = assignValue;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(45);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(92),
    arrayIncludes = __webpack_require__(157),
    arrayIncludesWith = __webpack_require__(158),
    arrayMap = __webpack_require__(58),
    baseUnary = __webpack_require__(63),
    cacheHas = __webpack_require__(171);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    isSymbol = __webpack_require__(47);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice = __webpack_require__(169);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(343);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 66 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(45),
    isArrayLike = __webpack_require__(12),
    isIndex = __webpack_require__(68),
    isObject = __webpack_require__(1);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var LogEvent_1 = __webpack_require__(191);
var LogLevel_1 = __webpack_require__(192);
var DefaultTraceHandler_1 = __webpack_require__(441);
var TraceLogger = (function () {
    function TraceLogger() {
    }
    TraceLogger._initialize = function (logger) {
        TraceLogger._logger = logger;
    };
    TraceLogger.logError = function (source, error, eventName, resultCode) {
        sp_core_library_1.Validate.isNotNullOrUndefined(error, 'error');
        this._log(source, error, eventName, true, resultCode);
    };
    TraceLogger.logErrorData = function (data) {
        sp_core_library_1.Validate.isNotNullOrUndefined(data.error, 'error');
        var errorInfo = data.logEntry ? data.logEntry.toString() : data.error;
        this._log(data.source, errorInfo, data.eventName, true, data.resultCode, data.serviceScope);
    };
    TraceLogger.logVerbose = function (source, message, eventName) {
        sp_core_library_1.Validate.isNonemptyString(message, 'message');
        this._log(source, message, eventName, false, undefined);
    };
    TraceLogger.logVerboseData = function (data) {
        var message = data.logEntry ? data.logEntry.toString() : data.message;
        this._log(data.source, message, data.eventName, false, undefined, data.serviceScope);
    };
    TraceLogger.logErrorWithLogEntry = function (source, logEntry, eventName, resultCode) {
        sp_core_library_1.Validate.isNotNullOrUndefined(logEntry, 'LogEntry');
        this._log(source, logEntry.toString(), eventName, true, resultCode);
    };
    Object.defineProperty(TraceLogger, "shouldWriteToConsole", {
        get: function () { return TraceLogger._shouldWriteToConsole; },
        set: function (shouldWrite) { TraceLogger._shouldWriteToConsole = shouldWrite; },
        enumerable: true,
        configurable: true
    });
    TraceLogger.logVerboseWithLogEntry = function (source, logEntry, eventName) {
        sp_core_library_1.Validate.isNotNullOrUndefined(logEntry, 'LogEntry');
        this._log(source, logEntry.toString(), eventName, false, undefined);
    };
    TraceLogger._log = function (source, data, eventName, isError, resultCode, serviceScope) {
        var enhancedEventName = this._addEventPrefix(source, eventName);
        var logEvent;
        if (isError) {
            logEvent = LogEvent_1.default.log(enhancedEventName, data, LogLevel_1.LogLevel.Error, serviceScope);
            TraceLogger._logger.log(data, logEvent.prefix, resultCode);
        }
        else {
            logEvent = LogEvent_1.default.log(enhancedEventName, data.toString(), LogLevel_1.LogLevel.Verbose, serviceScope);
            TraceLogger._logger.verbose(data.toString(), logEvent.prefix);
        }
        if (TraceLogger.shouldWriteToConsole || (true && !false)) {
            this._writeToConsole(logEvent, isError, resultCode);
        }
    };
    TraceLogger._addEventPrefix = function (source, eventName) {
        if (!eventName) {
            return source.id;
        }
        else {
            return source.id + "." + eventName;
        }
    };
    TraceLogger._writeToConsole = function (logEvent, isError, resultCode) {
        var errorString = logEvent.toString();
        if (resultCode) {
            errorString += ". resultCode: " + resultCode;
        }
        if (isError) {
            console.error(errorString);
        }
        else {
            console.log(errorString);
        }
    };
    return TraceLogger;
}());
TraceLogger._logger = new DefaultTraceHandler_1.default();
TraceLogger._shouldWriteToConsole = false;
exports.default = TraceLogger;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SPComponentLoaderProxy = (function () {
    function SPComponentLoaderProxy() {
    }
    SPComponentLoaderProxy.initialize = function (componentLoader) {
        SPComponentLoaderProxy._instance = componentLoader;
    };
    SPComponentLoaderProxy.start = function (preloadedData) {
        return SPComponentLoaderProxy._instance.start(preloadedData);
    };
    SPComponentLoaderProxy.loadCss = function (url) {
        return SPComponentLoaderProxy._instance.loadCss(url);
    };
    SPComponentLoaderProxy.loadScript = function (url, options) {
        return SPComponentLoaderProxy._instance.loadScript(url, options);
    };
    SPComponentLoaderProxy.loadComponent = function (manifest) {
        return SPComponentLoaderProxy._instance.loadComponent(manifest);
    };
    SPComponentLoaderProxy.loadComponentById = function (id, version) {
        return SPComponentLoaderProxy._instance.loadComponentById(id, version);
    };
    SPComponentLoaderProxy.registerManifests = function (manifests) {
        return SPComponentLoaderProxy._instance.registerManifests(manifests);
    };
    SPComponentLoaderProxy.getManifests = function () {
        return SPComponentLoaderProxy._instance.manifests;
    };
    SPComponentLoaderProxy.tryGetManifestById = function (id, version) {
        return SPComponentLoaderProxy._instance.tryGetManifestById(id, version);
    };
    SPComponentLoaderProxy._forceLocalManifests = function () {
        return SPComponentLoaderProxy._instance._forceLocalManifests();
    };
    return SPComponentLoaderProxy;
}());
exports.default = SPComponentLoaderProxy;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var ManifestStore_1 = __webpack_require__(4);
var confirmDebugAllowed_1 = __webpack_require__(121);
var showDebugError_1 = __webpack_require__(217);
var debugManifestsFileQueryParameterName = 'debugManifestsFile';
var sessionStorageKey = 'sp-loader_debugManifests';
var queryParams = undefined;
var debugManifestProvider_resx_1 = __webpack_require__(216);
function loadDebugManifests(componentLoader, alternativeManifestsFiles, noPrompt, noCache, noWarnOnFailure, registerAsNonDebug) {
    if (noPrompt === void 0) { noPrompt = false; }
    if (noCache === void 0) { noCache = false; }
    if (noWarnOnFailure === void 0) { noWarnOnFailure = false; }
    if (registerAsNonDebug === void 0) { registerAsNonDebug = false; }
    if (noPrompt) {
        confirmDebugAllowed_1.dangerouslyForceDebug();
    }
    return exports._getDebugManifestsWrapper(componentLoader, noCache, alternativeManifestsFiles, noWarnOnFailure)
        .then(function (debugManifests) {
        if (debugManifests) {
            if (registerAsNonDebug) {
                var manifests = Object.keys(debugManifests).map(function (id) {
                    return debugManifests[id];
                });
                ManifestStore_1.default.instance.registerManifests(manifests, false);
            }
            else {
                ManifestStore_1.default.instance.registerDebugManifests(debugManifests);
            }
        }
        return confirmDebugAllowed_1.confirmDebugAllowed(!!debugManifests && Object.keys(debugManifests).length > 0).then(function (result) {
        });
    });
}
exports.loadDebugManifests = loadDebugManifests;
function _getDebugManifests(componentLoader, noCache, alternativeManifestsFiles, noWarnOnFailure) {
    if (noCache === void 0) { noCache = false; }
    if (alternativeManifestsFiles === void 0) { alternativeManifestsFiles = []; }
    if (noWarnOnFailure === void 0) { noWarnOnFailure = false; }
    return new Promise(function (resolve, reject) {
        if (window.location.search.match(/\breset\b/)) {
            _trySetSessionStorageManifests(undefined);
            resolve({});
            return;
        }
        var debugManifests = _tryGetSessionStorageManifests();
        var queryParamManifestsFile = _parseManifestsFileFromFragementQueryParameter(false);
        var manifestsFiles = queryParamManifestsFile ? [queryParamManifestsFile] : alternativeManifestsFiles;
        if (manifestsFiles.length > 0 || Object.keys(debugManifests).length > 0) {
            confirmDebugAllowed_1.confirmDebugAllowed(true).then(function (isDebugAllowed) {
                if (!isDebugAllowed) {
                    _parseManifestsFileFromFragementQueryParameter(true);
                    resolve({});
                    return;
                }
                if (manifestsFiles.length > 0) {
                    var debugManifestsScriptPromise = _getDebugManifestsFromManifestFiles(componentLoader, manifestsFiles);
                    debugManifestsScriptPromise.then(function (manifests) {
                        _parseManifestsFileFromFragementQueryParameter(true);
                        for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
                            var manifest = manifests_1[_i];
                            debugManifests[manifest.id] = manifest;
                        }
                        if (!noCache) {
                            _trySetSessionStorageManifests(debugManifests);
                        }
                        resolve(debugManifests);
                    });
                    debugManifestsScriptPromise.catch(function (error) {
                        if (!noWarnOnFailure) {
                            var isMalformed = !manifestsFiles[0].match(/^https*\:\/\//);
                            var isHttps = !isMalformed && manifestsFiles.reduce(function (state, current) { return state || !!current.match(/^https/); }, false);
                            var errorText = isMalformed
                                ? sp_core_library_1.Text.format(debugManifestProvider_resx_1.default.errorLoadingDebugManifestMalformed, manifestsFiles[0])
                                : (isHttps
                                    ? debugManifestProvider_resx_1.default.errorLoadingDebugManifestHTTPS
                                    : debugManifestProvider_resx_1.default.errorLoadingDebugManifestHTTP);
                            showDebugError_1.default(error, errorText);
                        }
                        reject(error);
                    });
                }
                else {
                    resolve(debugManifests);
                }
            });
        }
        else {
            resolve({});
        }
    });
}
exports._getDebugManifests = _getDebugManifests;
exports._getDebugManifestsWrapper = _getDebugManifests;
function _getDebugManifestsFromManifestFiles(componentLoader, manifestsFiles) {
    var tryGetDebugManifests = function (promise) { return promise.then(function (script) { return script.getManifests(); }); };
    var debugManifestsScriptPromise = tryGetDebugManifests(componentLoader.loadScript(manifestsFiles[0]));
    var _loop_1 = function (i) {
        var oldPromise = debugManifestsScriptPromise;
        debugManifestsScriptPromise = oldPromise.catch(function () {
            return tryGetDebugManifests(componentLoader.loadScript(manifestsFiles[i]));
        });
    };
    for (var i = 1; i < manifestsFiles.length; i++) {
        _loop_1(i);
    }
    return debugManifestsScriptPromise;
}
exports._getDebugManifestsFromManifestFiles = _getDebugManifestsFromManifestFiles;
function _trySetSessionStorageManifests(debugManifests) {
    try {
        if (debugManifests) {
            window.sessionStorage.setItem(sessionStorageKey, JSON.stringify(debugManifests));
        }
        else {
            window.sessionStorage.removeItem(sessionStorageKey);
        }
    }
    catch (e) {
        console.debug("Error setting session storage. Error: " + e);
    }
}
exports._trySetSessionStorageManifests = _trySetSessionStorageManifests;
function _tryGetSessionStorageManifests() {
    try {
        var serializedManifests = window.sessionStorage.getItem(sessionStorageKey);
        if (serializedManifests) {
            return JSON.parse(serializedManifests) || {};
        }
    }
    catch (e) {
        console.debug("Error querying session storage. Error: " + e);
    }
    return {};
}
exports._tryGetSessionStorageManifests = _tryGetSessionStorageManifests;
function _parseManifestsFileFromFragementQueryParameter(clearFragmentParameter) {
    return _getAndClearFragmentQueryParameter(debugManifestsFileQueryParameterName, clearFragmentParameter);
}
function _getAndClearFragmentQueryParameter(parameter, clearFragmentParameter) {
    var result = undefined;
    if (window.location.hash) {
        var fragment = window.location.hash.indexOf('#') === 0
            ? window.location.hash.substr(1)
            : window.location.hash;
        var fragmentQueryParameters = _parseQueryParameters(fragment);
        if (fragmentQueryParameters[parameter]) {
            result = decodeURIComponent(fragmentQueryParameters[parameter].value || '');
            if (clearFragmentParameter) {
                var orderedParameters = [];
                for (var key in fragmentQueryParameters) {
                    if (fragmentQueryParameters.hasOwnProperty(key)) {
                        if (key !== parameter) {
                            var value = fragmentQueryParameters[key];
                            orderedParameters[value.position] = {
                                key: key,
                                value: value.value
                            };
                        }
                    }
                }
                var newFragment = orderedParameters
                    .filter(function (value) { return !!value; })
                    .map(function (param) { return (param.value) ? param.key + "=" + param.value : param.key; })
                    .join('&');
                if (newFragment !== '') {
                    window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search + "#" + newFragment);
                }
                else {
                    window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search);
                }
            }
        }
    }
    if (result === undefined) {
        result = _getQueryParameters().getValue(parameter);
    }
    return result;
}
exports._getAndClearFragmentQueryParameter = _getAndClearFragmentQueryParameter;
function _parseQueryParameters(queryParameterString) {
    if (queryParameterString) {
        if (queryParameterString.indexOf('?') === 0 || queryParameterString.indexOf('#') === 0) {
            queryParameterString = queryParameterString.substr(1);
        }
        var queryParameters = queryParameterString.split('&');
        var result_1 = {};
        var index_1 = 0;
        queryParameters.forEach(function (queryParameter) {
            var equalsIndex = queryParameter.indexOf('=');
            if (equalsIndex === -1) {
                result_1[queryParameter] = {
                    value: undefined,
                    position: index_1++
                };
            }
            else {
                result_1[queryParameter.substr(0, equalsIndex)] = {
                    value: queryParameter.substr(equalsIndex + 1),
                    position: index_1++
                };
            }
        });
        return result_1;
    }
    else {
        return {};
    }
}
exports._parseQueryParameters = _parseQueryParameters;
function _getQueryParameters() {
    if (!queryParams) {
        queryParams = new sp_core_library_1.UrlQueryParameterCollection(window.location.href);
    }
    return queryParams;
}


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_telemetry_1 = __webpack_require__(2);
var ManifestStore_1 = __webpack_require__(4);
var AddressStore_1 = __webpack_require__(123);
var resolveAddress_1 = __webpack_require__(80);
var normalizeName_1 = __webpack_require__(77);
var telemetryConstants = __webpack_require__(6);
var RequireJsLoader = (function () {
    function RequireJsLoader() {
        this._configuredFailoverPaths = [];
    }
    Object.defineProperty(RequireJsLoader, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new RequireJsLoader();
                this._instance._initialize();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    RequireJsLoader.prototype.ensure = function (name, module) {
        this._requirejs.undef(name);
        this._define(name, [], module);
    };
    RequireJsLoader.prototype.requireConfig = function (config) {
        this._requirejs.config(config);
    };
    RequireJsLoader.prototype.requireLoad = function (name) {
        var _this = this;
        try {
            return new Promise(function (resolve, reject) {
                _this._requirejs([name], function (module) { return resolve(module); }, function (error) { return reject(error); });
            });
        }
        catch (error) {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, error, RequireJsLoader._requireEventName);
            return Promise.reject(error);
        }
    };
    RequireJsLoader.prototype.requireDelete = function (manifest) {
        this._requirejs.undef(normalizeName_1.default(manifest));
    };
    RequireJsLoader.prototype.configure = function (manifest) {
        var resources = manifest.loaderConfig.scriptResources;
        var pathConfig = {};
        var currentMapConfig = {};
        var shimConfig = {};
        for (var name_1 in resources) {
            if (resources[name_1].type === 'component') {
                var moduleConfiguration = resources[name_1];
                var resourceManifest = ManifestStore_1.default.instance.tryGetManifest(moduleConfiguration.id, moduleConfiguration.version);
                if (resourceManifest) {
                    currentMapConfig[name_1] = normalizeName_1.default(resourceManifest);
                }
                if (moduleConfiguration.failoverPath) {
                    if (this._configuredFailoverPaths.indexOf(name_1) === -1) {
                        var normalizedName = normalizeName_1.normalizeFailoverPathName(name_1);
                        pathConfig[normalizedName] = this._resolveAddress(manifest, name_1);
                        AddressStore_1.default.instance.set(normalizedName, this._resolveAddress(manifest, name_1));
                        this._configuredFailoverPaths.push(name_1);
                    }
                }
            }
            else {
                var normalizedName = void 0;
                if (name_1 === manifest.loaderConfig.entryModuleId) {
                    normalizedName = normalizeName_1.default(manifest);
                }
                else {
                    normalizedName = normalizeName_1.default(manifest, name_1);
                    currentMapConfig[name_1] = normalizedName;
                }
                pathConfig[normalizedName] = this._resolveAddress(manifest, name_1);
                AddressStore_1.default.instance.set(normalizedName, this._resolveAddress(manifest, name_1));
                var resource = resources[name_1];
                if (resource && resource.globalName) {
                    shimConfig[normalizedName] = {
                        exports: resource.globalName,
                        deps: resource.globalDependencies
                    };
                }
            }
        }
        var mapConfig = {};
        mapConfig[normalizeName_1.default(manifest)] = currentMapConfig;
        this.requireConfig({
            paths: pathConfig,
            map: mapConfig,
            shim: shimConfig
        });
    };
    RequireJsLoader.prototype._initialize = function () {
        if (!this._isRequireJsLoaded()) {
            this._loadRequireJs();
        }
        else {
            this._setRequireJsLocalVariables();
        }
    };
    RequireJsLoader.prototype._loadRequireJs = function () {
        var requirejs = __webpack_require__(206);
        RequireJsLoader._window.requirejs = requirejs.requirejs;
        RequireJsLoader._window.require = requirejs.require;
        RequireJsLoader._window.define = requirejs.define;
        var requireJsConfig = {
            baseUrl: RequireJsLoader._invalidBaseUrl
        };
        this._setRequireJsLocalVariables();
        this.requireConfig(requireJsConfig);
    };
    RequireJsLoader.prototype._isRequireJsLoaded = function () {
        return (RequireJsLoader._window.requirejs !== undefined &&
            RequireJsLoader._window.require !== undefined &&
            RequireJsLoader._window.define !== undefined);
    };
    RequireJsLoader.prototype._setRequireJsLocalVariables = function () {
        this._requirejs = RequireJsLoader._window.requirejs;
        this._define = RequireJsLoader._window.define;
    };
    RequireJsLoader.prototype._resolveAddress = function (manifest, resourceName) {
        var address = resolveAddress_1.default(manifest, resourceName);
        address = address.replace(/.js$/, '');
        return address;
    };
    return RequireJsLoader;
}());
RequireJsLoader._requireEventName = 'RequireJS.require';
RequireJsLoader._invalidBaseUrl = 'https://relative-path.invalid/';
RequireJsLoader._window = window; 
exports.default = RequireJsLoader;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var normalizeComponentId_1 = __webpack_require__(50);
function normalizeName(manifest, name) {
    if (name) {
        return _normalizeManifestId(manifest) + "/" + name;
    }
    else {
        return _normalizeManifestId(manifest);
    }
}
exports.default = normalizeName;
function _normalizeManifestId(manifest) {
    return normalizeComponentId_1.default(manifest.id, manifest.version);
}
function normalizeFailoverPathName(name) {
    return name;
}
exports.normalizeFailoverPathName = normalizeFailoverPathName;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_telemetry_1 = __webpack_require__(2);
var sp_core_library_1 = __webpack_require__(0);
var ManifestStore_1 = __webpack_require__(4);
var AddressStore_1 = __webpack_require__(123);
var resolveAddress_1 = __webpack_require__(80);
var normalizeName_1 = __webpack_require__(79);
var SPLoader_resx_1 = __webpack_require__(5);
var telemetryConstants = __webpack_require__(6);
var SystemJsLoader = (function () {
    function SystemJsLoader() {
        this._configuredFailoverPaths = [];
    }
    Object.defineProperty(SystemJsLoader, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new SystemJsLoader();
                this._instance._initialize();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    SystemJsLoader.prototype.ensure = function (name, module) {
        var system = this._system;
        if (!system.has(name)) {
            system.set(name, system.newModule(module));
        }
    };
    SystemJsLoader.prototype.delete = function (name) {
        var system = this._system;
        if (system.has(name)) {
            system.delete(name);
        }
    };
    SystemJsLoader.prototype.systemConfig = function (config) {
        this._originalSystemConfig.call(this._system, config);
    };
    SystemJsLoader.prototype.systemImport = function (name) {
        try {
            return this._system.import(name);
        }
        catch (error) {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, error, SystemJsLoader.systemImportEventName);
            return Promise.reject(error);
        }
    };
    SystemJsLoader.prototype.systemDelete = function (manifest) {
        this._system.delete(normalizeName_1.default(manifest));
    };
    SystemJsLoader.prototype.configure = function (manifest) {
        var resources = manifest.loaderConfig.scriptResources;
        var depsMap = {};
        var globalDepsMap = {};
        for (var name_1 in resources) {
            if (resources[name_1].type === 'component') {
                var moduleConfiguration = resources[name_1];
                var resourceManifest = ManifestStore_1.default.instance.tryGetManifest(moduleConfiguration.id, moduleConfiguration.version);
                if (resourceManifest) {
                    depsMap[name_1] = normalizeName_1.default(resourceManifest);
                }
                if (moduleConfiguration.failoverPath) {
                    if (this._configuredFailoverPaths.indexOf(name_1) === -1) {
                        var normalizedName = normalizeName_1.normalizeFailoverPathName(name_1);
                        AddressStore_1.default.instance.set(normalizedName, resolveAddress_1.default(manifest, name_1));
                        globalDepsMap[name_1] = normalizedName;
                        this._configuredFailoverPaths.push(name_1);
                    }
                }
            }
            else {
                var normalizedName = void 0;
                if (name_1 === manifest.loaderConfig.entryModuleId) {
                    normalizedName = normalizeName_1.default(manifest);
                }
                else {
                    normalizedName = normalizeName_1.default(manifest, name_1);
                    depsMap[name_1] = normalizedName;
                }
                AddressStore_1.default.instance.set(normalizedName, resolveAddress_1.default(manifest, name_1));
                var resource = resources[name_1];
                if (resource && resource.globalName) {
                    var meta = {};
                    meta[normalizedName] = {
                        format: 'global',
                        exports: resource.globalName
                    };
                    var globalConfig = {
                        meta: meta
                    };
                    this.systemConfig(globalConfig);
                }
            }
        }
        var packages = {};
        packages[normalizeName_1.default(manifest)] = {
            map: depsMap,
            defaultExtension: false
        };
        var config = {
            packages: packages
        };
        this.systemConfig(config);
        if (Object.keys(globalDepsMap).length) {
            this.systemConfig({
                map: globalDepsMap
            });
        }
    };
    SystemJsLoader.prototype.getDependencies = function (manifest) {
        sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
        var defined = this._system.defined; 
        var definedName = this.getDefinedId(manifest);
        var componentDefinition = defined[definedName];
        if (!componentDefinition) {
            return [];
        }
        return componentDefinition.deps;
    };
    SystemJsLoader.prototype._baseSystemConfig = function (pluginName, scriptLoad) {
        var systemConfig = {
            meta: {
                '*': {
                    loader: pluginName,
                    scriptLoad: scriptLoad
                }
            }
        };
        this.systemConfig(systemConfig);
    };
    SystemJsLoader.prototype._initialize = function () {
        this._system = this._loadSystemJs();
        this._setCustomLoader(SystemJsLoader.pluginName, this._system);
        var systemConfig = {
            baseURL: SystemJsLoader._invalidBaseUrl,
            defaultJsExtensions: false
        };
        this.systemConfig(systemConfig);
        this._baseSystemConfig(SystemJsLoader.pluginName, true);
    };
    SystemJsLoader.prototype._loadSystemJs = function () {
        var system = __webpack_require__(208);
        this._originalSystemConfig = system.config;
        system.config = function (config) {
            throw new Error(SPLoader_resx_1.default.systemConfigDisabledError);
        };
        return system;
    };
    SystemJsLoader.prototype._setCustomLoader = function (pluginName, system) {
        var loader = {
            locate: function (module) {
                var address = AddressStore_1.default.instance.get(module.name);
                if (address) {
                    return address;
                }
                else {
                    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, "Address not found for module name: " + module.name + ". Using it as absolute URL.");
                    return module.name;
                }
            }
        };
        system.set(pluginName, system.newModule(loader));
    };
    SystemJsLoader.prototype.getDefinedId = function (manifest) {
        return SystemJsLoader._invalidBaseUrl + manifest.id + '_' + manifest.version;
    };
    return SystemJsLoader;
}());
SystemJsLoader.pluginName = 'sp-loader-resolver';
SystemJsLoader.systemImportEventName = 'System.import';
SystemJsLoader._invalidBaseUrl = 'https://relative-path.invalid/';
exports.default = SystemJsLoader;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var normalizeComponentId_1 = __webpack_require__(50);
var _componentBaseUrl = 'https://component-id.invalid/';
function normalizeName(manifest, name) {
    if (name) {
        return _componentBaseUrl + [normalizeManifestId(manifest), name].join('/');
    }
    else {
        return _componentBaseUrl + normalizeManifestId(manifest);
    }
}
exports.default = normalizeName;
function normalizeManifestId(manifest) {
    return normalizeComponentId_1.default(manifest.id, manifest.version);
}
function normalizeFailoverPathName(name) {
    return _componentBaseUrl + name;
}
exports.normalizeFailoverPathName = normalizeFailoverPathName;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var LocaleStore_1 = __webpack_require__(124);
var telemetryConstants = __webpack_require__(6);
var SPLoader_resx_1 = __webpack_require__(5);
function resolveAddress(manifest, resourceName) {
    sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
    sp_core_library_1.Validate.isNonemptyString(resourceName, 'resourceName');
    if (!manifest.loaderConfig.scriptResources.hasOwnProperty(resourceName)) {
        var error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.resourceNotFoundError, resourceName, manifest.id, manifest.alias));
        sp_telemetry_1._TraceLogger.logError(telemetryConstants.resolveAddressLogSource, error);
        throw error;
    }
    var moduleConfiguration = manifest.loaderConfig.scriptResources[resourceName];
    var address = resolveModuleConfiguration(resourceName, moduleConfiguration);
    if (!address.match(/^https?\:\/\//i)) {
        var moduleBaseUrl = manifest.loaderConfig.internalModuleBaseUrls[0].replace(/\/+$/, '');
        address = moduleBaseUrl + "/" + address;
    }
    return address;
}
exports.default = resolveAddress;
function resolveModuleConfiguration(moduleName, moduleConfiguration) {
    if (moduleConfiguration) {
        switch (moduleConfiguration.type) {
            case 'component':
                var failoverPath = moduleConfiguration.failoverPath;
                if (!failoverPath) {
                    throw new Error(SPLoader_resx_1.default.noFailoverPathError);
                }
                return resolvePath(failoverPath);
            case 'path':
                return resolvePath(moduleConfiguration.path);
            case 'localizedPath':
                return resolvePath(resolveLocalizedModuleConfiguration(moduleConfiguration));
            case null: 
            case undefined:
            default:
                return moduleName;
        }
    }
    else {
        return moduleName;
    }
}
function resolvePath(path) {
    if (typeof path === 'string') {
        return path;
    }
    else {
        if (path.debug) {
            return path.debug;
        }
        else {
            return path.default;
        }
    }
}
function resolveLocalizedModuleConfiguration(moduleConfiguration) {
    var currentLocale = LocaleStore_1.default.getLocale();
    if (moduleConfiguration.paths) {
        if (currentLocale) {
            for (var locale in moduleConfiguration.paths) {
                if (locale && locale.toUpperCase() === currentLocale.toUpperCase() && moduleConfiguration.paths[locale]) {
                    return moduleConfiguration.paths[locale];
                }
            }
        }
    }
    return moduleConfiguration.defaultPath;
}


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var Promise_1 = __webpack_require__(51);
/**
 * Signal is used to manage a promise without having to pass a function to the Promise constructor.
 * Example:
 * var s = new Signal<boolean>();
 * setTimeout(() => {
 *    s.complete(true);
 * }, 1000);
 * return s.promise;
 */
var Signal = (function () {
    /**
     * Create a new Signal (also known as a Deferred in some circles.)
     * @param: oncancel A function to be called when the promise is cancelled.
     */
    function Signal(oncancel) {
        this._promise = new Promise_1.SignalPromise(oncancel);
    }
    /**
     * The underlying promise that the Signal manages.
     */
    Signal.prototype.getPromise = function () {
        return this._promise;
    };
    /**
     * Cancel the underlying promise.
     */
    Signal.prototype.cancel = function () {
        this._promise.cancel();
    };
    /**
     * Complete the underlying promise with the given value.
     */
    Signal.prototype.complete = function (value) {
        this._promise._completed(value);
    };
    /**
     * Put the underlying promise into the error state with the given value.
     */
    Signal.prototype.error = function (value) {
        this._promise._error(value);
    };
    return Signal;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Signal;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

/**
 * Use PlatformDetection to evaluate which user experience makes sense for the user's
 * platform. NOTE: This class is NOT COMPLETE! Meaning not all values are parsed out of
 * the user agent. If something is missing that you need, add it and add unit tests.
 * WARNING: Avoid using browser checks when you can use detection techniques for caps checking.
 */
var PlatformDetection = (function () {
    function PlatformDetection(agent) {
        if (!agent) {
            agent = (window && window.navigator && navigator.userAgent) || '';
        }
        var userAgent = agent;
        agent = agent.toLowerCase();
        // We want to figure out which ONE browser the user is most likely on.
        // The order of the checks is important so we're not deceived by (for example)
        // Chrome saying that it's Safari.
        // (Each regular expression captures the version number so we can parse it later.)
        var match;
        var isIE;
        var isIE9;
        var isEdge;
        var isFirefox;
        var isChrome;
        var isSafari;
        function testBrowserVersion(pattern) {
            return match = RegExp(pattern + "(\\d+)([\\d.]*)").exec(agent);
        }
        if (testBrowserVersion('msie ')) {
            // IE <= 10 has something like "MSIE 9" in the user agent.
            // This is also what newer versions do in compatibility mode.
            isIE = true;
            isIE9 = match[1] === '9';
        }
        else if (testBrowserVersion('trident.*rv:')) {
            // This is IE 11. Sample user agent contains:
            // Trident/7.0; other stuff... rv:11.0
            isIE = true;
        }
        else if (testBrowserVersion('edge/')) {
            // This is Edge (it pretends to be Chrome and Safari).
            isEdge = true;
        }
        else if (testBrowserVersion('fxios|firefox/')) {
            isFirefox = true;
        }
        else if (testBrowserVersion('(?:chrome|crios)/')) {
            // Note: lots of random browsers say they're Chrome and will end up in this bucket
            isChrome = true;
        }
        else if (/safari\/(\d+)/.test(agent)) {
            isSafari = true;
            testBrowserVersion('version/');
        }
        // Some other browser categories:
        //   IE Mobile: /iemobile\/(\d+)/
        //   IE Mobile in desktop mode: contains WPDesktop; get version from Trident version
        //   Opera (currently goes into Chrome bucket): /opr\/(\d+)/
        // Parse the captured version number for user's browser.
        var browserMajor = match && parseInt(match[1], 10) || 0;
        var browserMinor = match && match[2] && match[2].substr(1) || '0';
        // Parse device which gives hints about os / mobile state.
        // Windows Phone IE sometimes pretends to be Android, so explicitly check for Windows Phone first.
        // (wpdesktop is used by Windows Phone in desktop mode.)
        var isWinPhone = /windows phone|wpdesktop/.test(agent);
        var deviceMatch = isWinPhone || /ipad|iphone|ipod|android/.exec(agent);
        var device = deviceMatch && deviceMatch[0];
        var isAndroid = device === 'android';
        var isIPad = device === 'ipad';
        var isIOS = !!device && !isAndroid;
        var isMac = !deviceMatch && agent.indexOf('macintosh') > -1;
        var isWindows = !deviceMatch && agent.indexOf('windows nt') > -1;
        // Other operating systems:
        //   Chrome OS: /cros/
        //   Linux: /linux/ (Android can also say it's Linux, so check for Android first)
        // WARNING: Avoid using browser checks when you can use detection techniques for caps checking.
        var input = document.createElement("input");
        input.type = "file";
        var file = window['File'];
        var fileProto = file && file.prototype;
        /**
         * Checks to see if styleSheet exists as a property off of a style element.
         * This will determine if style registration should be done via cssText (<= IE9) or not
         */
        var emptyStyle = document.createElement("style");
        emptyStyle.type = "text/css";
        var osVersionMatch = /[\s\(](os|os x|windows (?:phone|nt)|android) ([\d._]+)/.exec(agent);
        return {
            // Browser identification
            isChrome: !!isChrome,
            isEdge: !!isEdge,
            isFirefox: !!isFirefox,
            isIE: !!isIE,
            isIE9: !!isIE9,
            isSafari: !!isSafari,
            browserName: isIE ? 'IE' : isEdge ? 'Edge' : isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isSafari ? 'Safari' : 'NA',
            browserMajor: browserMajor,
            browserMinor: browserMinor,
            // OS Identification
            isAndroid: isAndroid,
            isIOS: isIOS,
            isMac: isMac,
            isWindows: isWindows,
            isWinPhone: isWinPhone,
            osVersion: osVersionMatch ? osVersionMatch[2] : "NA",
            osName: isWindows ? 'Windows' : isWinPhone ? 'Windows Phone' : isMac ? 'OSX' : isIOS ? 'IOS' : isAndroid ? 'Android' : 'NA',
            isWindows81: !deviceMatch && /windows (?:8\.1|nt 6\.3)/.test(agent),
            isWindows10: !deviceMatch && agent.indexOf('windows nt 10') > -1,
            isWindows7: !deviceMatch && agent.indexOf('windows nt 6.1') > -1,
            // Device identification
            isMobile: !!deviceMatch,
            isIPad: isIPad,
            // Capabilities
            areCSS3TransitionsSupported: !isIE || browserMajor > 9,
            areTouchEventsSupported: 'ontouchstart' in window,
            isFolderUploadSupported: "webkitdirectory" in input,
            isHtml5FileUploadSupported: !!(fileProto && (fileProto.slice || fileProto.mozSlice || fileProto.webkitSlice)),
            isRetinaSupported: window.devicePixelRatio > 1,
            isUnlimitedStyleSheetsSupported: !emptyStyle["styleSheet"],
            isWebDavSupported: 'addBehavior' in document.createElement('div'),
            // Raw user agent
            userAgent: userAgent
        };
    }
    return PlatformDetection;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PlatformDetection;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DisposalChain = (function () {
    function DisposalChain(owner) {
        this._callbacks = [];
        this._owner = owner;
    }
    DisposalChain.prototype.addCallback = function (callback) {
        this._callbacks.push(callback);
    };
    DisposalChain.prototype.dispose = function () {
        // Handle dispose callbacks is the reverse order from when they were attached.
        while (this._callbacks.length) {
            var callback = this._callbacks.pop();
            callback.call(this._owner);
        }
    };
    return DisposalChain;
}());
/**
 * Determines whether not an object requires is disposable.
 *
 * @export
 * @template T
 * @param {(T | IDisposable)} object
 * @returns {object is IDisposable}
 */
function isDisposable(object) {
    return typeof object.dispose === 'function';
}
exports.isDisposable = isDisposable;
function hook(instance, onDispose) {
    var disposable = instance;
    var dispose = disposable.dispose;
    var disposalChain = typeof dispose === 'function' && dispose.disposalChain;
    if (!disposalChain) {
        disposalChain = new DisposalChain(disposable);
        var disposeHook = (function () {
            disposalChain.dispose();
            if (dispose) {
                // Restore the old dispose method and clean up modifications.
                disposable.dispose = dispose;
                disposable.dispose();
            }
        });
        disposable.dispose = disposeHook;
        disposeHook.disposalChain = disposalChain;
    }
    disposalChain.addCallback(onDispose);
    return disposable;
}
exports.hook = hook;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var UriEncoding = (function () {
    function UriEncoding() {
    }
    /////////////////////////////
    // This file is more clean of all unneeded pollutants. It only contains the minimum amount of code required for someone to use the URI class.
    // You should think twice before adding anything else into this file because you will be causing unneeded bloat from someone else.
    /////////////////////////////
    /**
     * This function performs an aggressive unicode URL-encoding.
     * Convert non alphanum character into UTF-8 code string in format %XX%XX%XX.
     *
     * Escape unsafe characters
     *   CTL | SP | <"> | "#" | "%" | "<" | ">" | "'" | "&"
     * in the URL path (before "?", "#")
     * No encoding on query string.
     *
     * @param {string} str - String to encode
     * @param {boolean} bAsUrl - Encode in the same way as the code in unmanaged (Url::UrlEncode) code and
     *                           SP OM (SPHttpUtility.UrlKeyValueEncode and SPHttpUtility.UrlPathEncode).
     * @param {boolean} bForFilterQuery
     * @param {boolean} bForCallback - Only escape the characters after 0x7F to workaround bug O12: 452191
     */
    UriEncoding.encodeURIComponent = function (str, bAsUrl, bForFilterQuery, bForCallback) {
        var strOut = "";
        var strByte;
        var ix = 0;
        var strEscaped = " \"%<>\'&";
        if (!str) {
            return "";
        }
        var len = str.length;
        for (ix = 0; ix < len; ix++) {
            var charCode = str.charCodeAt(ix);
            var curChar = str.charAt(ix);
            if (bAsUrl && (curChar === '#' || curChar === '?')) {
                strOut += str.substr(ix);
                break;
            }
            if (bForFilterQuery && curChar === '&') {
                strOut += curChar;
                continue;
            }
            if (charCode <= 0x7f) {
                if (bForCallback) {
                    strOut += curChar;
                }
                else {
                    if ((charCode >= 97 && charCode <= 122) ||
                        (charCode >= 65 && charCode <= 90) ||
                        (charCode >= 48 && charCode <= 57) ||
                        (bAsUrl && (charCode >= 32 && charCode <= 95) && strEscaped.indexOf(curChar) < 0)) {
                        strOut += curChar;
                    }
                    else if (charCode <= 0x0f) {
                        strOut += "%0" + charCode.toString(16).toUpperCase();
                    }
                    else if (charCode <= 0x7f) {
                        strOut += "%" + charCode.toString(16).toUpperCase();
                    }
                }
            }
            else if (charCode <= 0x07ff) {
                strByte = 0xc0 | (charCode >> 6);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f);
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
            else if ((charCode & 0xFC00) !== 0xD800) {
                strByte = 0xe0 | (charCode >> 12);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x0fc0) >> 6); // middle 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f); // lower 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
            else if (ix < str.length - 1) {
                charCode = (charCode & 0x03FF) << 10; // lower 10 bits of first char
                ix++;
                var nextCharCode = str.charCodeAt(ix);
                charCode |= nextCharCode & 0x03FF; // lower 10 bits of second char
                charCode += 0x10000;
                strByte = 0xf0 | (charCode >> 18);
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x3f000) >> 12); // upper 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | ((charCode & 0x0fc0) >> 6); // middle 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
                strByte = 0x80 | (charCode & 0x003f); // lower 6 bits
                strOut += "%" + strByte.toString(16).toUpperCase();
            }
        }
        return strOut;
    };
    /**
     * Callbacks do not work if a #bookmark is in the URL. If there is a bookmark then we need to remove it. We also need to
     * deal with the scenario where there is not a bookmark but there is an unencoded # as a part of a name/value after the '?'.
     * This is how things should work here:
     * .../foo.aspx -> .../foo.aspx (unchanged)
     * .../foo.aspx#bookmark -> .../foo.aspx (bookmark is removed)
     * .../foo.aspx#bookmark?name=value -> .../foo.aspx?name=value (bookmark is removed)
     * .../foo.aspx#bookmark?name1=value#extra1&name2=value2 -> .../foo.aspx?name1=value#extra1&name2=value2 (only the bookmark # is removed)
     * .../foo.aspx?name1=value#extra1&name2=value2 -> .../foo.aspx?name1=value#extra1&name2=value2 (unchanged)
     */
    UriEncoding.escapeUrlForCallback = function (str) {
        var iPound = str.indexOf("#");
        var iQues = str.indexOf("?");
        if ((iPound > 0) && ((iQues === -1) || (iPound < iQues))) {
            var strNew = str.substr(0, iPound);
            if (iQues > 0) {
                strNew += str.substr(iQues); // Need to include the '?' along with the "name=value" pairs.
            }
            str = strNew;
        }
        return UriEncoding.encodeURIComponent(str, true, false, true);
    };
    /**
     * SharePoint REST processor expect single quote ' to be escaped to '' in tokens (this applies to %27 too).
     * See example for usage.
     * @example
     * "getFolderByServerRelativeUrl('"+encodeRestUriStringToken("don't know.txt")+"')" should became "getFolderByServerRelativeUrl('don''t know.txt')""
     */
    UriEncoding.encodeRestUriStringToken = function (stringToken) {
        if (stringToken) {
            stringToken = stringToken.replace(/'/g, "''");
            stringToken = stringToken.replace(/%27/g, "%27%27");
            stringToken = UriEncoding.encodeURIComponent(stringToken);
        }
        return stringToken;
    };
    return UriEncoding;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UriEncoding;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ItemType;
(function (ItemType) {
    ItemType[ItemType["File"] = 0] = "File";
    ItemType[ItemType["Folder"] = 1] = "Folder";
    ItemType[ItemType["Media"] = 2] = "Media";
    ItemType[ItemType["OneNote"] = 3] = "OneNote";
    ItemType[ItemType["Unknown"] = 4] = "Unknown";
    ItemType[ItemType["Error"] = 5] = "Error";
    ItemType[ItemType["App"] = 6] = "App";
    ItemType[ItemType["Subsite"] = 7] = "Subsite";
    /** A shortcut link pointing to some target destination or Url */
    ItemType[ItemType["Shortcut"] = 8] = "Shortcut";
})(ItemType = exports.ItemType || (exports.ItemType = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ItemType;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:CoverageThreshold(75)

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EventBase_1 = __webpack_require__(22);
var Manager_1 = __webpack_require__(16);
var ResultTypeEnum_1 = __webpack_require__(34);
var ErrorHelper_1 = __webpack_require__(9);
var Async_1 = __webpack_require__(15);
var ObjectUtil_1 = __webpack_require__(17);
var schemaExceptionErrorCode = 'GetSchemaException';
var promiseCreationFailureErrorCode = 'PromiseCreationFailed';
var timeoutErrorCode = 'Timeout';
function generateQosResult(resultType, resultCode, error) {
    var schema = {
        resultType: resultType
    };
    if (resultCode) {
        schema.resultCode = resultCode;
    }
    if (error) {
        schema.error = error;
    }
    return schema;
}
function createPairedEvent(props, metadata, baseClass) {
    var PairedEvent = (function (_super) {
        __extends(PairedEvent, _super);
        function PairedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PairedEvent;
    }(PairedEventBase));
    EventBase_1.addEventProps(PairedEvent.prototype, props, metadata, baseClass);
    return PairedEvent;
}
exports.createPairedEvent = createPairedEvent;
var PairedEventBase = (function (_super) {
    __extends(PairedEventBase, _super);
    function PairedEventBase(data, parent) {
        return _super.call(this, data, EventBase_1.ClonedEventType.Start, parent) || this;
    }
    PairedEventBase.instrumentPromise = function (startSchema, createPromise, getCompleteSchema, getErrorSchema, timeoutMs, timeoutSchema, parent) {
        var promise;
        var event = new this(startSchema, parent);
        if (timeoutMs) {
            event.setTimeout(timeoutMs, timeoutSchema);
        }
        var onComplete = function (result) {
            var schema;
            if (getCompleteSchema) {
                try {
                    schema = getCompleteSchema(result);
                }
                catch (e) {
                    schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, schemaExceptionErrorCode, e.toString());
                }
            }
            else {
                schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Success);
            }
            event.end(schema);
        };
        var onError = function (errorArgs) {
            var schema;
            if (getErrorSchema) {
                try {
                    schema = getErrorSchema(errorArgs);
                }
                catch (e) {
                    schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, schemaExceptionErrorCode, e.toString());
                }
            }
            else if (errorArgs) {
                var failureResultType = (errorArgs instanceof Error && errorArgs.name === "Canceled") ?
                    ResultTypeEnum_1.ResultTypeEnum.ExpectedFailure : ResultTypeEnum_1.ResultTypeEnum.Failure;
                schema = generateQosResult(failureResultType, null, ObjectUtil_1.safeSerialize(errorArgs));
            }
            else {
                schema = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure);
            }
            event.end(schema);
        };
        try {
            promise = createPromise();
        }
        catch (e) {
            event.end(generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, promiseCreationFailureErrorCode, e.toString()));
            throw e;
        }
        promise.then(onComplete, onError);
        return promise;
    };
    PairedEventBase.prototype.setTimeout = function (ms, data) {
        if (!this.async) {
            this.async = new Async_1.default(this);
        }
        this._clearTimeout();
        if (!data) {
            data = generateQosResult(ResultTypeEnum_1.ResultTypeEnum.Failure, timeoutErrorCode);
        }
        this.async.setTimeout(this.end.bind(this, data), ms);
    };
    PairedEventBase.prototype.verbose = function (message) {
        if (this.endTime) {
            // event already ended, no need to log anymore
            return;
        }
        if (this._isQosEvent()) {
            var qosSchema = this.data;
            ErrorHelper_1.default.verbose(message, qosSchema.name);
        }
    };
    PairedEventBase.prototype.end = function (data) {
        // Make sure end can only be called once
        if (!this.endTime) {
            if (data) {
                this._setData(data);
            }
            // Set the end time
            this.endTime = Manager_1.Manager.getTime();
            // Log the event end
            this._logEvent(EventBase_1.ClonedEventType.End);
            // If this is a QOS event log and contains an error message trigger the upload of logs by calling
            // the ErrorHelper
            if (this._isQosEvent()) {
                var qosSchema = this.data;
                if (qosSchema.error) {
                    ErrorHelper_1.default.log(qosSchema.error, qosSchema.name, qosSchema.resultCode, qosSchema.resultType);
                }
            }
            this._clearTimeout();
        }
    };
    PairedEventBase.prototype._clearTimeout = function () {
        if (this.async && this.timeoutId) {
            this.async.clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    };
    PairedEventBase.prototype._isQosEvent = function () {
        return this.eventName.indexOf('Qos,') >= 0;
    };
    return PairedEventBase;
}(EventBase_1.EventBase));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
var Trace_event_1 = __webpack_require__(139);
exports.CaughtError = SingleEventBase_1.createSingleEvent({
    eventName: 'CaughtError,Trace,',
    shortEventName: 'CaughtError',
    critical: true,
    requiresParent: false
}, {
    stack: 1 /* String */,
    extraData: 4 /* Object */
}, Trace_event_1.Trace);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.CaughtError;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.PLT = SingleEventBase_1.createSingleEvent({
    eventName: 'PLT,',
    shortEventName: 'PLT',
    samplingFeature: { ODB: true, ODC: 'PLTLoggingSampling', Fallback: false }
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    },
    w3cResponseEnd: 2 /* Number */,
    prefetchStart: 2 /* Number */,
    deferredListDataRender: 2 /* Number */,
    appStart: 2 /* Number */,
    preRender: 2 /* Number */,
    dataFetch: 2 /* Number */,
    dataFetchServerTime: 2 /* Number */,
    postRender: 2 /* Number */,
    render: 2 /* Number */,
    plt: 2 /* Number */,
    pltWithUnload: 2 /* Number */,
    httpRequests: 2 /* Number */,
    appCacheHit: 3 /* Boolean */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.PLT;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var Async_1 = __webpack_require__(15);
var PageTransitionType_1 = __webpack_require__(143);
var RUMOneSLAPI_1 = __webpack_require__(144);
var RUMOneErrorsSLAPI_1 = __webpack_require__(250);
var RUMOneDataUpload_event_1 = __webpack_require__(137);
var PlatformDetection_1 = __webpack_require__(82);
var PerformanceMarker_1 = __webpack_require__(147);
var PerformanceDataState;
(function (PerformanceDataState) {
    /**
     * Not enought data collected to upload
     * At this state logger isRunning is true
     */
    PerformanceDataState[PerformanceDataState["Incomplete"] = 1] = "Incomplete";
    /**
     * Required data collected and can be uploaded.
     * Practically all expected controls has rendered by this time
     * and EUPL has been set.
     * At this state logger isRunning is true but sooner to change to false.
     */
    PerformanceDataState[PerformanceDataState["ReadyToUpload"] = 2] = "ReadyToUpload";
    /**
     * Incomplete -> ReadyToUpload |  ERROR_TIMEOUT time elapsed -> Uploaded
     * Performance data has been uploaded for the current page.
     * Until reset, no more data will be uploaded.
     */
    PerformanceDataState[PerformanceDataState["Uploaded"] = 3] = "Uploaded";
    /**
     * Incomplete -> ERROR_TIMEOUT time elapsed -> TimeOut -> Uploaded
     * Timeout occured before expected controls could finish rendering
     * Data will be uploaded as it is but without EUPL.
     * Consumer should consider EUPL="" as > 30 sec for performance analysis
     */
    PerformanceDataState[PerformanceDataState["TimeOut"] = 4] = "TimeOut";
    /**
     * Incomplete -> (ERROR_TIMEOUT time elapsed && TimeOut) | ReadyToUpload -> Skipped
     * This is a state where data has been collected or timeout but uploading the data was skipped
     * This happens when consumer has asked to do so based on the page's debug environment
     */
    PerformanceDataState[PerformanceDataState["Skipped"] = 5] = "Skipped";
})(PerformanceDataState || (PerformanceDataState = {}));
var APICallPerformanceData = (function () {
    function APICallPerformanceData(url, duration, correlationid, status, startTime, endTime, name) {
        this.url = url;
        this.duration = duration;
        this.correlationId = correlationid;
        this.status = status;
        this.startTime = startTime;
        this.endTime = endTime;
        this.name = name;
    }
    return APICallPerformanceData;
}());
exports.APICallPerformanceData = APICallPerformanceData;
var ControlPerformanceData = (function () {
    function ControlPerformanceData(controlId, startTime, endTime, renderTimeCalculator, renderTimeRequiredDataChecker) {
        this.controlId = controlId;
        this.startTime = startTime;
        this.endTime = endTime;
        this.renderTimeCalculator = renderTimeCalculator;
        this.renderTimeRequiredDataChecker = renderTimeRequiredDataChecker;
    }
    return ControlPerformanceData;
}());
exports.ControlPerformanceData = ControlPerformanceData;
function isNullOrUndefined(item) {
    'use strict';
    return item === null || item === undefined;
}
var performance = window.performance;
/**
 * It is a new client side perf instrumentation, it logs more metrics, like scenario, api data, server request id, duration, etc in 1 single schema.
 * It has server side usage DB and cosmos supports.
 */
var RUMOneLogger = (function () {
    function RUMOneLogger(logFunc) {
        this.async = new Async_1.default(this);
        this.dataStartTime = Number((new Date()).getTime());
        this.performanceData = null;
        this.dataState = PerformanceDataState.Incomplete;
        this.controls = [];
        this.apis = [];
        this.perfDataTimer = null;
        this.expectedControls = [];
        this.euplBreakDown = {};
        this.serverMetrics = {};
        this.isW3cTimingCollected = false;
        this.isW3cResourceTimingCollected = false;
        this.tempData = {};
        this.performanceData = null;
        this.loggingFunc = logFunc;
        this.getPerformanceData();
        this.setPerfDataTimer();
        this._platformDetection = new PlatformDetection_1.default();
    }
    /**
     * RUMOneLogger.getRUMOneLogger: Use this method to get a singleton reference of RUMOneLogger
     * with default parameters.
     */
    RUMOneLogger.getRUMOneLogger = function (logFunc) {
        var loggingFunc = logFunc || (function (streamName, dictProperties) {
            RUMOneDataUpload_event_1.RUMOneDataUpload.logData({ streamName: streamName, dictionary: dictProperties });
        });
        if (!RUMOneLogger.rumOneLogger) {
            try {
                RUMOneLogger.rumOneLogger = new RUMOneLogger(loggingFunc);
            }
            catch (e) {
                // If RUMOneLogger fails, don't block UX
                RUMOneLogger.rumOneLogger = null;
            }
        }
        return RUMOneLogger.rumOneLogger;
    };
    RUMOneLogger.prototype.getPerformanceData = function () {
        if (!this.performanceData) {
            this.performanceData = new RUMOneSLAPI_1.default();
            this.logMessageInConsole("RUMOne object initiated!");
        }
        return this.performanceData;
    };
    RUMOneLogger.prototype.resetLogger = function () {
        this.dataStartTime = (new Date()).getTime();
        this.dataState = PerformanceDataState.Incomplete;
        this.isW3cTimingCollected = false;
        this.isW3cResourceTimingCollected = false;
        this.expectedControls = [];
        this.controls = [];
        this.apis = [];
        this.tempData = {};
        this.performanceData = null;
        this._excludePageData = false;
        this._waitOnAddingExpectedControl = false;
        this.getPerformanceData();
        this.clearPerfDataTimer();
        this.setPerfDataTimer();
        this.euplBreakDown = {};
        this.serverMetrics = {};
        this.clearResourceTimings();
        PerformanceMarker_1.clearMarks();
        this.logMessageInConsole("Reset performance Logger Done");
    };
    /**
     * Consumer should own logic to determine whether to ignore the  page for perf data collection
     * when Called this API, RUMOneLogger will not upload data but display in the console for debug purpose
     * E.g. Hidden Preload.aspx page for sharepoint or a debug page with #debugManifest or ?moduleLoader= in the url
     *
     */
    RUMOneLogger.prototype.excludePageForPerfData = function () {
        this._excludePageData = true;
    };
    RUMOneLogger.prototype.logPerformanceData = function (key, value) {
        if (!key || !this.performanceData || !this.verifyPropertyMatchingSchema(key)) {
            return;
        }
        this.getPerformanceData();
        this.performanceData[key] = value;
    };
    RUMOneLogger.prototype.getPerformanceDataPropertyValue = function (key) {
        if (!this.performanceData || !key || !this.verifyPropertyMatchingSchema(key)) {
            return null;
        }
        return this.performanceData[key];
    };
    RUMOneLogger.prototype.verifyPropertyMatchingSchema = function (propertyName) {
        var properties = this.getRUMOnePropertyNames(this.performanceData);
        return properties.join().indexOf(propertyName) !== -1;
    };
    RUMOneLogger.prototype.addExpectedControl = function (control) {
        if (this.expectedControls.indexOf(control) === -1) {
            this.expectedControls.push(control);
        }
    };
    RUMOneLogger.prototype.expectingControl = function (control) {
        return this.expectedControls.indexOf(control) >= 0;
    };
    RUMOneLogger.prototype.writeServerCorrelationId = function (correlationId) {
        if (!this.isCollected('ServerCorrelationId')) {
            this.logPerformanceData('ServerCorrelationId', correlationId);
        }
    };
    RUMOneLogger.prototype.writeServerUrl = function (url) {
        if (!this.isCollected('ServerUrl')) {
            var serverUrl = url || window.location.href;
            this.logPerformanceData('ServerUrl', serverUrl);
        }
    };
    RUMOneLogger.prototype.writeServerSideLatency = function (duration, iisLatency) {
        if (!this.isCollected('ServerRequestDuration')) {
            this.logPerformanceData('ServerRequestDuration', duration);
            this.logPerformanceData('IISLatency', iisLatency);
        }
    };
    RUMOneLogger.prototype.writeControlPerformanceData = function (controlData) {
        if (controlData) {
            var foundControl = this.controls.filter(function (control) {
                return control.controlId === controlData.controlId;
            });
            if (foundControl.length === 0) {
                this.controls.push(controlData);
            }
        }
    };
    RUMOneLogger.prototype.writeAPICallPerformanceData = function (apiData) {
        if (apiData) {
            this.apis.push(apiData);
        }
    };
    RUMOneLogger.prototype.readAPICallPerformanceData = function () {
        return this.apis;
    };
    RUMOneLogger.prototype.writeAppCache = function (appCache) {
        if (!this.isCollected('AppCache')) {
            this.logPerformanceData('AppCache', appCache);
        }
    };
    RUMOneLogger.prototype.writePageTransitionType = function (pageTransitionType, overwrite) {
        if ((!this.isCollected('PageTransitionType') || overwrite) &&
            (pageTransitionType === PageTransitionType_1.default.fullPageLoad || pageTransitionType === PageTransitionType_1.default.none || pageTransitionType === PageTransitionType_1.default.onePageAppNavigation)) {
            this.logPerformanceData('PageTransitionType', pageTransitionType);
        }
    };
    RUMOneLogger.prototype.writeScenarioId = function (scenarioId, overwrite) {
        if (!this.isCollected('ScenarioId') || overwrite) {
            this.logPerformanceData('ScenarioId', scenarioId);
        }
    };
    RUMOneLogger.prototype.collectW3CPerfTimings = function () {
        if (!this.isW3cTimingCollected) {
            var w3cTimeStampNames = ['navigationStart', 'unloadEventStart', 'unloadEventEnd', 'fetchStart', 'redirectStart', 'redirectEnd', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'secureConnectionStart', 'connectEnd', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domComplete', 'loadEventStart', 'loadEventEnd'];
            var perfTimingObject = performance && performance.timing;
            if (perfTimingObject) {
                for (var index = 0; index < w3cTimeStampNames.length; index++) {
                    var w3cObject = perfTimingObject[w3cTimeStampNames[index]];
                    if (w3cObject) {
                        this.logPerformanceData(this.getW3cTimingName(w3cTimeStampNames[index]), Number(w3cObject));
                    }
                }
                this.isW3cTimingCollected = true;
            }
        }
    };
    RUMOneLogger.prototype.collectW3cResourceTimings = function () {
        if (!this.isW3cResourceTimingCollected && performance && performance.getEntriesByType) {
            var allRequests = performance.getEntriesByType("resource");
            var iFrames = document.getElementsByTagName("iframe");
            for (var index = 0; index < iFrames.length; index++) {
                var iFramePerformance = null;
                try {
                    iFramePerformance = iFrames[index].contentWindow.performance;
                }
                catch (e) {
                }
                if (iFramePerformance && iFramePerformance.getEntriesByType) {
                    allRequests.concat(iFramePerformance.getEntriesByType("resource"));
                }
            }
            var fromSources = {};
            fromSources["SharePoint"] = function (element) { return /\.sharepoint\.com|\.spoppe\.com/i.test(element.name); }; //matching sharepoint.com or spoppe.com
            fromSources["CDN"] = function (element) { return /(cdn(ppe)?|static(ppe)?)\.sharepointonline\.com|\.akamaihd\.net/i.test(element.name); }; //matching cdn(ppe)sharepointonline.com or adamaihd.net
            fromSources["ThirdParty"] = function (element) { return !fromSources["SharePoint"](element) && !fromSources["CDN"](element); }; // all requests other than sharepoint requests or cdn requests
            var types = {};
            types["ASPX"] = function (element) { return /\.aspx/i.test(element.name); };
            types["JS"] = function (element) { return /script/i.test(element.initiatorType); };
            types["CSS"] = function (element) { return /link|css/i.test(element.initiatorType); };
            types["IMG"] = function (element) { return /img/i.test(element.initiatorType); };
            var sources = Object.keys(fromSources);
            for (var index = 0; index < sources.length; index++) {
                var source = sources[index];
                var requests = this.categorizeResourceRequests(allRequests, {
                    from: fromSources[source],
                    requestType: null //match any type to get total request count for this source
                });
                this.logPerformanceData(source + "RequestCountTotal", requests.length); //SharePoint|CDN|ThirdParty resource request count
                var typeKeys = Object.keys(types);
                for (var typeIndex = 0; typeIndex < typeKeys.length; typeIndex++) {
                    var type = typeKeys[typeIndex];
                    this.logPerformanceData(source + "RequestCount" + type, this.categorizeResourceRequests(requests, {
                        from: null,
                        requestType: types[type]
                    }).length); //SharePoint|CDN|ThirdParty ASPX resource request count
                }
                if (requests.length > 0) {
                    this.logPerformanceData(source + "RequestDownloadTime", Math.round(requests.reduce(function (sum, currentVal) {
                        return sum + currentVal.duration;
                    }, 0) / requests.length)); //SharePoint|CDN|ThirdParty resource request average duration
                    // log the file names of all resource requests in a JSON string. The output after processing will looks like:
                    // [{name: "require-db6c47e2.js", startTime: 500, duration: 100},{name: "RenderListDataAsStream", startTime: 200, duration: 10}]
                    // The raw resource name before this processing is "https://msft.spoppe.com/teams/SPGroups/_api/web/GetList(@listUrl)/RenderListDataAsStream?Paged=TRUE&p_FileLeafRef=test%2eurl&p_ID=213&PageFirstRow=121&View=6eab4254-2f2f-4086-91c0-549ae900cc93&@listUrl=%27%2Fteams%2FSPGroups%2FVNextDocLib%27"
                    var files = JSON.stringify(requests.map(function (timing) {
                        return {
                            name: timing.name.split("/").map(function (urlToken) {
                                return urlToken.split("?")[0];
                            }).filter(function (urlToken) {
                                return urlToken && urlToken.length > 0;
                            }).slice(-1)[0].replace(/\(.*?\)/g, '()'),
                            startTime: Math.round(timing.startTime),
                            duration: Math.round(timing.duration)
                        };
                    }));
                    this.logPerformanceData(source + "RequestNames", files);
                }
            }
            this.isW3cResourceTimingCollected = true;
        }
    };
    RUMOneLogger.prototype.saveTempData = function (key, value) {
        this.tempData[key] = value;
    };
    RUMOneLogger.prototype.readTempData = function (key) {
        return this.tempData[key];
    };
    RUMOneLogger.prototype.writeRenderTime = function (renderTime, overwrite) {
        if (!this.isCollected('RenderTime') || overwrite) {
            this.logPerformanceData('RenderTime', renderTime);
        }
    };
    RUMOneLogger.prototype.writePreRenderTime = function (preRender) {
        if (!this.isCollected('PreRender')) {
            this.logPerformanceData('PreRender', preRender);
        }
    };
    RUMOneLogger.prototype.writePostRenderTime = function (postRender) {
        if (!this.isCollected('PostRender')) {
            this.logPerformanceData('PostRender', postRender);
        }
    };
    RUMOneLogger.prototype.writeDataFetchTime = function (dataFetch, overwrite) {
        if (!this.isCollected('DataFetch') || overwrite) {
            this.logPerformanceData('DataFetch', dataFetch);
        }
    };
    RUMOneLogger.prototype.isRunning = function () {
        return !(this.dataState === PerformanceDataState.Uploaded ||
            this.dataState === PerformanceDataState.TimeOut ||
            this.dataState === PerformanceDataState.Skipped);
    };
    RUMOneLogger.prototype.writeEUPLBreakdown = function (euplBreakdown, overwrite) {
        if (euplBreakdown) {
            try {
                var breakdown = JSON.parse(euplBreakdown);
                for (var key in breakdown) {
                    if (!breakdown.hasOwnProperty(key)) {
                        continue;
                    }
                    this.addEUPLBreakdown(key, breakdown[key], overwrite);
                }
            }
            catch (e) {
                // in case the euplBreakdown is invalid JSON
                this.logMessageInConsole("Failed to write EUPL breakdown data:" + e.toString());
            }
        }
    };
    RUMOneLogger.prototype.addEUPLBreakdown = function (name, value, overwrite) {
        if (name && !isNullOrUndefined(value)) {
            if (isNullOrUndefined(this.euplBreakDown[name]) || overwrite) {
                this.euplBreakDown[name] = value;
            }
        }
    };
    /**
     * Add list of flights enabled for this page.
     */
    RUMOneLogger.prototype.addFlights = function (flights) {
        if (flights && flights.length > 0) {
            var _flights = JSON.parse(this.getPerformanceDataPropertyValue('Flights') || '[]');
            for (var index = 0; index < flights.length; index++) {
                var flight = flights[index];
                if (flight && _flights.indexOf(flight) === -1) {
                    _flights.push(flight);
                }
            }
            this.logPerformanceData('Flights', JSON.stringify(_flights));
        }
    };
    RUMOneLogger.prototype.addServerMetrics = function (metric, overwrite) {
        if (metric) {
            for (var key in metric) {
                if (key && !isNullOrUndefined(metric[key]) &&
                    (isNullOrUndefined(this.serverMetrics[key]) || overwrite)) {
                    this.serverMetrics[key] = metric[key];
                }
            }
        }
    };
    RUMOneLogger.prototype.readControlPerformanceData = function () {
        return this.controls;
    };
    RUMOneLogger.prototype.mark = function (name) {
        PerformanceMarker_1.mark(name);
    };
    RUMOneLogger.prototype.now = function () {
        return performance && performance.now ? Math.round(performance.now()) : NaN;
    };
    RUMOneLogger.prototype.getMarkerTime = function (name) {
        return PerformanceMarker_1.getMarkerTime(name);
    };
    Object.defineProperty(RUMOneLogger.prototype, "waitOnAddingExpectedControl", {
        /**
         * If set to true, RUMOnelogger will wait until this is not set false again before concluding all expected controls are added
         * Set it to true if not all expected controls are added
         * Set it to false once all expected controls has been added
         */
        set: function (wait) {
            this._waitOnAddingExpectedControl = wait;
        },
        enumerable: true,
        configurable: true
    });
    RUMOneLogger.prototype.clearResourceTimings = function () {
        if (performance && performance.clearResourceTimings) {
            performance.clearResourceTimings();
        }
    };
    RUMOneLogger.prototype.collectMarks = function () {
        var marks = {};
        var markerIndex = 0;
        PerformanceMarker_1.getAllMarks().forEach(function (mark) {
            if (markerIndex < RUMOneLogger.MAX_MARKS) {
                var markName = mark.name.substr(PerformanceMarker_1.MARKER_PREFIX.length) + (".mark" + markerIndex++);
                marks[markName] = Math.round(mark.startTime); // covert to rumone collected marks to object and merge to EUPL Breakdown
            }
        });
        this.writeEUPLBreakdown(JSON.stringify(marks));
    };
    RUMOneLogger.prototype.logMessageInConsole = function (message) {
        if (this.isRUMOneDebuggingEnabled) {
            console.log(message);
        }
    };
    Object.defineProperty(RUMOneLogger.prototype, "isRUMOneDebuggingEnabled", {
        get: function () {
            try {
                if ('sessionStorage' in window && window.sessionStorage) {
                    var debugStr = window.sessionStorage["enableRUMOneDebugging"];
                    var debug = debugStr && debugStr.toLowerCase() === "true";
                    return debug && typeof console !== "undefined" && !!console;
                }
            }
            catch (e) {
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    RUMOneLogger.prototype.logObjectForDebugging = function (propertyName, dictProperties) {
        if (this.isRUMOneDebuggingEnabled) {
            var logMessageText = propertyName + " : " + JSON.stringify(dictProperties);
            console.log(logMessageText);
        }
    };
    RUMOneLogger.prototype.isCollected = function (name) {
        return !isNullOrUndefined(this.getPerformanceDataPropertyValue(name));
    };
    RUMOneLogger.prototype.getRUMOnePropertyNames = function (obj) {
        var names = [];
        var index = 0;
        if (!isNullOrUndefined(obj)) {
            for (var property in obj) {
                if (obj.hasOwnProperty(property)) {
                    names[index++] = property;
                }
            }
        }
        return names;
    };
    RUMOneLogger.prototype.setPerfDataTimer = function () {
        this.perfDataTimer = this.async.setTimeout(this.loopForDataCompleteness, RUMOneLogger.CHECK_INTERVAL);
    };
    RUMOneLogger.prototype.clearPerfDataTimer = function () {
        if (!isNullOrUndefined(this.perfDataTimer)) {
            this.async.clearTimeout(this.perfDataTimer);
            this.perfDataTimer = null;
        }
    };
    RUMOneLogger.prototype.categorizeResourceRequests = function (requests, categorizer) {
        var ret = [];
        for (var index = 0; index < requests.length; index++) {
            var request = requests[index];
            if ((!categorizer.from || categorizer.from(request)) && (!categorizer.requestType || categorizer.requestType(request))) {
                ret.push(request);
            }
        }
        return ret;
    };
    RUMOneLogger.prototype.collectSupplementaryData = function () {
        this.setAPIDataToRUMOne();
        this.collectMarks();
        this.writeServerUrl(null);
        this.setBrowseInfo();
        this.setReferrer();
        this.logPerformanceData('ServerMetrics', JSON.stringify(this.serverMetrics));
        this.logPerformanceData('EUPLBreakdown', JSON.stringify(this.euplBreakDown));
    };
    RUMOneLogger.prototype.loopForDataCompleteness = function () {
        this.clearPerfDataTimer();
        if (!this._waitOnAddingExpectedControl) {
            if (this.isRUMOneDebuggingEnabled) {
                this.logObjectForDebugging("RUMONE: ", this.performanceData);
                this.logObjectForDebugging("RUMOne DataState: ", String(this.getReadableDataState(this.dataState)));
                this.logObjectForDebugging("Control Performance Data: ", this.controls);
                this.logObjectForDebugging("API Performance Data: ", this.apis);
                this.logObjectForDebugging("Temp Data: ", this.tempData);
                this.logObjectForDebugging("EUPLBreakdown: ", this.euplBreakDown);
                this.logObjectForDebugging("ServerMetrics: ", this.serverMetrics);
                this.logMessageInConsole("====================================================================");
            }
            if (!this.isRunning()) {
                return;
            }
            this._updateState();
            if (this.dataState === PerformanceDataState.ReadyToUpload) {
                this.finishPerfDataUpload();
                return;
            }
            this.processControlRenderTime();
            if (this.readyToComputeEUPL()) {
                this.setEUPL();
                this._updateState();
            }
        }
        // Check timeout
        this._checkTimeout();
        if (this.isRunning()) {
            this.setPerfDataTimer();
        }
    };
    /**
     * Check if we reached ERROR_TIMEOUT without being ready to upload and timeout if so
     */
    RUMOneLogger.prototype._checkTimeout = function () {
        if (!this.isRunning() || this.dataState === PerformanceDataState.ReadyToUpload) {
            return;
        }
        if (Number((new Date()).getTime()) - Number(this.dataStartTime) <= RUMOneLogger.ERROR_TIMEOUT) {
            return; // Nope, we still have time
        }
        // Upload whatever data we have without all key metrics
        this.dataState = PerformanceDataState.TimeOut;
        this.finishPerfDataUpload();
        // Report timeout error
        this.reportErrors('TimeOut', "Did not get key perf metrics in " + RUMOneLogger.ERROR_TIMEOUT + " milliseconds. Missed metrics: " + this._getKeyMissedMetrics().join() + ".");
    };
    RUMOneLogger.prototype._updateState = function () {
        this.dataState =
            (this._getKeyMissedMetrics().length === 0)
                ? PerformanceDataState.ReadyToUpload
                : PerformanceDataState.Incomplete;
    };
    /**
     * Get array of missing key metrices
     */
    RUMOneLogger.prototype._getKeyMissedMetrics = function () {
        var missedKeyMetrics = [];
        for (var i = 0; i < RUMOneLogger.KeyMetrics.length; i++) {
            var keyMetricValue = this.getPerformanceDataPropertyValue(RUMOneLogger.KeyMetrics[i]);
            if (isNullOrUndefined(keyMetricValue)) {
                missedKeyMetrics.push(RUMOneLogger.KeyMetrics[i]);
            }
        }
        return missedKeyMetrics;
    };
    RUMOneLogger.prototype.finishPerfDataUpload = function () {
        this.writeControlDataToRUMOne();
        this.collectSupplementaryData();
        try {
            this.uploadPerfData();
            if (this.isRUMOneDebuggingEnabled) {
                this.logMessageInConsole('Final Data uploaded');
                this.logObjectForDebugging("RUMONE: ", this.performanceData);
                this.logObjectForDebugging("RUMOne DataState: ", this.getReadableDataState(this.dataState));
            }
        }
        catch (e) {
            (function (errorText) {
                if (typeof console !== "undefined" && Boolean(console)) {
                    console.error(errorText);
                }
            })("PerformanceLogger error writing RUMOne data: " + e);
        }
    };
    RUMOneLogger.prototype.getReadableDataState = function (_dataState) {
        for (var key in PerformanceDataState) {
            if (_dataState === Number(PerformanceDataState[key])) {
                return key;
            }
        }
        return 'NaN';
    };
    /**
     * Write Control and corresponding render time for top 10 renderTime controls.
     */
    RUMOneLogger.prototype.writeControlDataToRUMOne = function () {
        if (this.controls && this.controls.length) {
            var byRenderTime = this.controls.slice(0);
            byRenderTime.sort(function (control1, control2) {
                return control2.renderTime - control1.renderTime;
            });
            // We have maximum 10 slots for the Control render data collection
            for (var index = 0; index < 10 && index < byRenderTime.length; index++) {
                this.logPerformanceData("Control" + (index + 1) + "Id", byRenderTime[index].controlId);
                this.logPerformanceData("Control" + (index + 1) + "RenderTime", byRenderTime[index].renderTime);
            }
        }
    };
    /**
     * Calculate renderTime for the controls ready for it.
     */
    RUMOneLogger.prototype.processControlRenderTime = function () {
        for (var index = 0; index < this.controls.length; index++) {
            var control = this.controls[index];
            // if this control is not processed yet and ready to be processed
            if (!Boolean(control.renderTime) && control.renderTimeRequiredDataChecker(this, control)) {
                control.renderTime = control.renderTimeCalculator(this, control);
            }
        }
    };
    RUMOneLogger.prototype.readyToComputeEUPL = function () {
        var readyControls = 0;
        for (var index = 0; index < this.expectedControls.length; index++) {
            var keyControl = this.lookUpControls(this.expectedControls[index], this.controls);
            if (keyControl && Boolean(keyControl.renderTime)) {
                readyControls++;
            }
        }
        return this.expectedControls.length > 0 && this.expectedControls.length === readyControls;
    };
    RUMOneLogger.prototype.lookUpControls = function (_controlId, _controls) {
        if (_controls) {
            for (var index = 0; index < _controls.length; index++) {
                if (_controlId === _controls[index].controlId) {
                    return _controls[index];
                }
            }
        }
        return null;
    };
    RUMOneLogger.prototype.setEUPL = function () {
        if (!this.isCollected('EUPL')) {
            var eupl = 0;
            for (var index = 0; index < this.controls.length; index++) {
                var controlData = this.controls[index];
                if (Boolean(controlData.renderTime) && eupl < controlData.renderTime) {
                    eupl = controlData.renderTime;
                }
            }
            this.logPerformanceData('EUPL', eupl);
        }
    };
    RUMOneLogger.prototype.setBrowseInfo = function () {
        this.logPerformanceData('Browser', this._platformDetection.browserName + this._platformDetection.browserMajor);
        this.logPerformanceData('BrowserIsMobile', this._platformDetection.isMobile);
    };
    RUMOneLogger.prototype.setAPIDataToRUMOne = function () {
        var calls = 0;
        var durationSum = 0;
        for (var index = 0; index < this.apis.length; index++) {
            var apiData = this.apis[index];
            if (apiData) {
                calls++;
                durationSum += apiData.duration;
                // only take the function part of the API url to avoid cosmos data scrubber
                // url before processing: /teams/SPGroups/_api/web/GetList(@listUrl)/RenderListDataAsStream?Paged=TRUE&p_FileLeafRef=test%2eurl&p_ID=213&PageFirstRow=121&View=6eab4254-2f2f-4086-91c0-549ae900cc93&@listUrl=%27%2Fteams%2FSPGroups%2FVNextDocLib%27"
                // url after processing: RenderListDataAsStream
                apiData.url = apiData.url.split("/").map(function (s) { return s.split("?")[0]; }).slice(-1)[0].replace(/\(.*?\)/g, '()');
            }
        }
        this.logPerformanceData('APICallCount', calls);
        this.logPerformanceData('APICallDurationSum', durationSum);
        this.logPerformanceData('APICalls', JSON.stringify(this.apis));
    };
    RUMOneLogger.prototype.setReferrer = function () {
        if (!this.isCollected('Referrer')) {
            this.logPerformanceData('Referrer', document.referrer);
        }
    };
    RUMOneLogger.prototype.getW3cTimingName = function (timingName) {
        if (timingName !== 'secureConnectionStart') {
            return 'W3c' + timingName.charAt(0).toUpperCase() + timingName.slice(1);
        }
        else {
            return 'W3cSecureConnectStart'; // to workaround a RUMOne schema issue W3cSecureConnectStart should be W3cSecureConnectionStart
        }
    };
    RUMOneLogger.prototype.uploadPerfData = function () {
        if (this._excludePageData) {
            this.dataState = PerformanceDataState.Skipped;
            this.logMessageInConsole('Uploading perf data skipped as requested by the consumer');
        }
        else if (this.dataState !== PerformanceDataState.ReadyToUpload &&
            this.dataState !== PerformanceDataState.TimeOut) {
            console.error("Error: Uploading perf data called with wrong data state " + this.dataState);
        }
        else if (!this.loggingFunc) {
            console.error('Uploading perf data skipped as loggingFunc is not defined');
        }
        else if (!this.performanceData) {
            console.error('Error: Uploading perf data called but perf data is not available');
        }
        else {
            this.loggingFunc("RUMOne", this.getPerformanceData());
            this.dataState = PerformanceDataState.Uploaded;
        }
    };
    RUMOneLogger.prototype.reportErrors = function (reason, message) {
        this.logMessageInConsole(message);
        var errorObj = new RUMOneErrorsSLAPI_1.default();
        errorObj.Reason = reason;
        errorObj.Message = message;
        if (this.loggingFunc) {
            this.loggingFunc("RUMOneErrors", errorObj);
        }
    };
    return RUMOneLogger;
}());
RUMOneLogger.rumOneLogger = null;
RUMOneLogger.CHECK_INTERVAL = 100; // in milliseconds
RUMOneLogger.ERROR_TIMEOUT = 30000; // in milliseconds
RUMOneLogger.MAX_MARKS = 100; // suppport maximum 100 perf markers
RUMOneLogger.KeyMetrics = ['EUPL', 'ScenarioId'];
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RUMOneLogger;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(351),
    mapCacheDelete = __webpack_require__(352),
    mapCacheGet = __webpack_require__(353),
    mapCacheHas = __webpack_require__(354),
    mapCacheSet = __webpack_require__(355);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(91),
    setCacheAdd = __webpack_require__(357),
    setCacheHas = __webpack_require__(358);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 94 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(57),
    arrayEach = __webpack_require__(93),
    assignValue = __webpack_require__(59),
    baseAssign = __webpack_require__(276),
    cloneBuffer = __webpack_require__(307),
    copyArray = __webpack_require__(102),
    copySymbols = __webpack_require__(316),
    getAllKeys = __webpack_require__(330),
    getTag = __webpack_require__(39),
    initCloneArray = __webpack_require__(339),
    initCloneByTag = __webpack_require__(340),
    initCloneObject = __webpack_require__(341),
    isArray = __webpack_require__(3),
    isBuffer = __webpack_require__(185),
    isHostObject = __webpack_require__(67),
    isObject = __webpack_require__(1),
    keys = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(100),
    isKey = __webpack_require__(40),
    toKey = __webpack_require__(44);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(163),
    baseIsNaN = __webpack_require__(285);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(283),
    isObject = __webpack_require__(1),
    isObjectLike = __webpack_require__(19);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 99 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(3),
    stringToPath = __webpack_require__(366);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

module.exports = castPath;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(156);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(25),
    isIterateeCall = __webpack_require__(69);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1);

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(288),
    baseUnary = __webpack_require__(63),
    nodeUtil = __webpack_require__(180);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(159),
    baseKeysIn = __webpack_require__(166),
    isArrayLike = __webpack_require__(12);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1),
    isSymbol = __webpack_require__(47);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var LogSource = (function () {
    function LogSource(id) {
        sp_core_library_1.Validate.isNotNullOrUndefined(id, 'id');
        this.id = id;
    }
    LogSource.create = function (id) {
        return new LogSource(id);
    };
    LogSource.prototype.isEmpty = function () {
        return this.id.length === 0;
    };
    return LogSource;
}());
exports.default = LogSource;
exports.logSourceServiceKey = sp_core_library_1.ServiceKey.createCustom('sp-client-base:LogSource', function (serviceScope) {
    return new LogSource('');
});


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Validate_1 = __webpack_require__(14);
var Text_1 = __webpack_require__(29);
var StringsProxy_1 = __webpack_require__(13);
var Guid = (function () {
    function Guid(guid) {
        this._guid = guid;
    }
    Guid.newGuid = function (randomNumberGenerator) {
        return new Guid(Guid._generateGuid(randomNumberGenerator));
    };
    Guid.parse = function (guidString) {
        var guid = Guid.tryParse(guidString);
        if (!guid) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.invalidGuidStringError, guidString));
        }
        return guid;
    };
    Guid.tryParse = function (guid) {
        if (guid) {
            guid = Guid._normalize(guid);
            if (Guid._guidRegEx.test(guid)) {
                return new Guid(guid);
            }
        }
        return undefined;
    };
    Guid.isValid = function (guid) {
        if (guid) {
            guid = Guid._normalize(guid);
            if (Guid._guidRegEx.test(guid)) {
                return true;
            }
        }
        return false;
    };
    Guid._normalize = function (guid) {
        Validate_1.default.isNonemptyString(guid, 'guid');
        var result = /^Guid\((.*)\)/i.exec(guid); 
        if (result) {
            guid = result[1];
        }
        if (guid.length === 38) {
            guid = guid.substr(1, 36);
        }
        return guid.toLowerCase();
    };
    Guid._generateGuid = function (randomNumberGenerator) {
        return 'AAAAAAAA-AAAA-4AAA-BAAA-AAAAAAAAAAAA'.replace(/[AB]/g, 
        function (character) {
            var randomNumber = randomNumberGenerator ? randomNumberGenerator.generate() : Math.random();
            var num = randomNumber * 16 | 0;
            var masked = character === 'A' ? num : (num & 0x3 | 0x8);
            return masked.toString(16);
        });
    };
    Guid.prototype.equals = function (guid) {
        Validate_1.default.isNotNullOrUndefined(guid, 'guid');
        return guid && this._guid.toString() === guid.toString();
    };
    Guid.prototype.toString = function () {
        return this._guid;
    };
    return Guid;
}());
Guid.empty = new Guid('00000000-0000-0000-0000-000000000000');
Guid._guidRegEx = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
exports.default = Guid;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Validate_1 = __webpack_require__(14);
var ServiceKey = (function () {
    function ServiceKey(id, name, defaultCreator) {
        this.id = id;
        this.name = name;
        this.defaultCreator = defaultCreator;
    }
    ServiceKey.create = function (name, serviceClass) {
        Validate_1.default.isNotNullOrUndefined(serviceClass, 'serviceClass');
        return ServiceKey.createCustom(name, function (serviceScope) {
            return new serviceClass(serviceScope);
        });
    };
    ServiceKey.createCustom = function (name, defaultCreator) {
        Validate_1.default.isNonemptyString(name, 'name');
        Validate_1.default.isNotNullOrUndefined(defaultCreator, 'defaultCreator');
        ServiceKey._lastId++;
        var id = ServiceKey._lastId.toString();
        return new ServiceKey(id, name, defaultCreator);
    };
    return ServiceKey;
}());
ServiceKey._lastId = 0;
exports.default = ServiceKey;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UrlQueryParameterCollection = (function () {
    function UrlQueryParameterCollection(url) {
        this._queryParameterList = this._getUrlQueryParameterArray(url);
    }
    UrlQueryParameterCollection.prototype.getValue = function (param) {
        for (var _i = 0, _a = this._queryParameterList; _i < _a.length; _i++) {
            var queryParam = _a[_i];
            if (param === undefined) {
                if (queryParam.key === undefined) {
                    return queryParam.value;
                }
                continue;
            }
            else if (param.toUpperCase() === queryParam.key) {
                return queryParam.value;
            }
        }
        return undefined;
    };
    UrlQueryParameterCollection.prototype.getValues = function (param) {
        var queryParams = [];
        for (var _i = 0, _a = this._queryParameterList; _i < _a.length; _i++) {
            var queryParam = _a[_i];
            if (param === undefined) {
                if (queryParam.key === undefined) {
                    queryParams.push(queryParam.value);
                }
                continue;
            }
            else if (param.toUpperCase() === queryParam.key) {
                queryParams.push(queryParam.value);
            }
        }
        return queryParams.length > 0 ? queryParams : undefined;
    };
    UrlQueryParameterCollection.prototype._getUrlQueryParameterArray = function (url) {
        var queryParameterList = [];
        var urlParser = document.createElement('a');
        urlParser.href = url;
        var queryParams = urlParser.search.substring(1).split('&');
        for (var _i = 0, queryParams_1 = queryParams; _i < queryParams_1.length; _i++) {
            var queryParam = queryParams_1[_i];
            if (queryParam !== '') {
                var equalsIndex = queryParam.indexOf('=');
                var key = void 0;
                var value = void 0;
                if (equalsIndex < 0) {
                    key = queryParam;
                    value = undefined;
                }
                else if (equalsIndex === 0) {
                    key = '';
                    value = queryParam.length === 1 ? '' : queryParam.substring(1);
                }
                else {
                    key = queryParam.substring(0, equalsIndex);
                    value =
                        queryParam.substring(equalsIndex).length === 1 ?
                            '' :
                            queryParam.substring(equalsIndex + 1);
                }
                queryParameterList.push({
                    key: decodeURIComponent(key.toUpperCase()),
                    value: value
                });
            }
            else {
                queryParameterList.push({
                    key: undefined,
                    value: undefined
                });
            }
        }
        return queryParameterList;
    };
    return UrlQueryParameterCollection;
}());
exports.default = UrlQueryParameterCollection;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var StringsProxy_1 = __webpack_require__(13);
var SPCoreLibraryStrings_resx_1 = __webpack_require__(215);
StringsProxy_1.setStrings(SPCoreLibraryStrings_resx_1.default);
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var developerToolsLoader = __webpack_require__(212);
var SPSystemJsComponentLoader_1 = __webpack_require__(222);
var SPRequireJsComponentLoader_1 = __webpack_require__(219);
var LocaleStore_1 = __webpack_require__(124);
var BrowserSupport_1 = __webpack_require__(224);
var showBrowserDevToolsWarning_1 = __webpack_require__(211);
var SPLoader_resx_1 = __webpack_require__(5);
if (false) {
    showBrowserDevToolsWarning_1.showBrowserDevToolsWarning();
}
var REQUIREJS_FLIGHT_ID = 125;
var SPStarter = (function () {
    function SPStarter() {
    }
    SPStarter._setBundledComponents = function (bundledComponents) {
        if (!SPStarter._bundledComponents) {
            SPStarter._bundledComponents = bundledComponents;
        }
        else {
            throw new Error('Bundled components can be only set once'); 
        }
    };
    SPStarter.start = function (preloadedData, handleFailure) {
        var handleError = function (error) {
            if (handleFailure) {
                handleFailure({
                    message: SPLoader_resx_1.default.loaderUserFriendlyError,
                    error: error
                });
            }
            return Promise.reject(error);
        };
        if (!preloadedData) {
            return handleError(new Error(SPLoader_resx_1.default.invalidPreloadedDataError));
        }
        if (!preloadedData.clientSideApplicationId) {
            return handleError(new Error(SPLoader_resx_1.default.missingApplicationIdError));
        }
        var browserCompatibility = SPStarter.getBrowserCompatibility();
        if (browserCompatibility.supportLevel === sp_core_library_1.BrowserSupportLevel.Blocked) {
            if (handleFailure) {
                handleFailure({
                    message: SPLoader_resx_1.default.browserNotSupportedError,
                    error: new Error(browserCompatibility.warning)
                });
            }
            return Promise.reject(new Error(SPLoader_resx_1.default.browserNotSupportedError));
        }
        if (preloadedData.spPageContextInfo) {
            sp_core_library_1.Log._initialize(new sp_telemetry_1._SPTelemetryLogHandler());
            SPStarter._initializeEnvironment();
            sp_core_library_1.Session._initialize({ applicationId: preloadedData.spPageContextInfo.CorrelationId });
            SPStarter._initializeTelemetry(preloadedData);
            var allowDebugQueryParameter = 'EDOG_Content' === preloadedData.spPageContextInfo.farmLabel
                || sp_core_library_1.Environment.type === sp_core_library_1.EnvironmentType.Local;
            sp_core_library_1._SPFlight.initialize(preloadedData.spPageContextInfo.ExpFeatures, allowDebugQueryParameter);
            sp_core_library_1._SPKillSwitch.initialize(preloadedData.spPageContextInfo.killSwitches, allowDebugQueryParameter);
            LocaleStore_1.default.setLocale(preloadedData.spPageContextInfo.currentUICultureName);
            sp_telemetry_1._PerformanceLogger.markSpLoaderStart();
        }
        var spLoader = __webpack_require__(31);
        var componentLoader = sp_core_library_1._SPFlight.isEnabled(REQUIREJS_FLIGHT_ID) ?
            new SPRequireJsComponentLoader_1.default() :
            new SPSystemJsComponentLoader_1.default();
        return componentLoader._initialize(preloadedData, SPStarter._bundledComponents).then(function () {
            spLoader.SPComponentLoader.initialize(componentLoader);
            spLoader.DeveloperTools.initialize(developerToolsLoader);
            return spLoader.SPComponentLoader.start(preloadedData).then(function (application) {
                if (window['_spLoaderCallback']) {
                    var _spLoaderCallback = window['_spLoaderCallback'];
                    _spLoaderCallback(application);
                }
                return application;
            });
        }).catch(function (error) {
            return handleError(error);
        });
    };
    SPStarter.getBrowserCompatibility = function () {
        return BrowserSupport_1.default.getBrowserCompatibility();
    };
    SPStarter._initializeEnvironment = function () {
        var type;
        if (window.location.hostname === 'localhost' ||
            window['ENVIRONMENTTYPE'] &&
                window['ENVIRONMENTTYPE'] === 'Local') {
            type = sp_core_library_1.EnvironmentType.Local;
        }
        else {
            type = sp_core_library_1.EnvironmentType.SharePoint;
        }
        sp_core_library_1.Environment._initialize({ type: type });
    };
    SPStarter._initializeTelemetry = function (preloadedData) {
        if (SPStarter._isTelemetryDisabled()) {
            return;
        }
        var pageContextInfo = preloadedData.spPageContextInfo;
        sp_telemetry_1._Telemetry.initialize(preloadedData.manifests[0].alias, {
            environment: pageContextInfo.env,
            farmLabel: pageContextInfo.farmLabel,
            clientSideApplicationId: preloadedData.clientSideApplicationId,
            siteSubscriptionId: pageContextInfo.siteSubscriptionId,
            version: !!undefined ? undefined : preloadedData.manifests[0].version,
            loginName: pageContextInfo.userLoginName,
            systemUserKey: pageContextInfo.systemUserKey,
            currentUICultureName: pageContextInfo.currentUICultureName,
            correlationId: pageContextInfo.CorrelationId,
            enableConsoleLog: SPStarter._isConsoleLogEnabled()
        });
    };
    SPStarter._isQueryParameterTrue = function (name) {
        var parameterValue;
        try {
            var queryParams = new sp_core_library_1.UrlQueryParameterCollection(window.location.href);
            parameterValue = queryParams.getValue(name) === 'true';
        }
        catch (error) {
            parameterValue = false;
        }
        return parameterValue;
    };
    SPStarter._isConsoleLogEnabled = function () {
        return SPStarter._isQueryParameterTrue('enableConsoleLog');
    };
    SPStarter._isTelemetryDisabled = function () {
        return SPStarter._isQueryParameterTrue('disableTelemetry');
    };
    return SPStarter;
}());
SPStarter._bundledComponents = undefined;
exports.default = SPStarter;


/***/ }),
/* 116 */
/***/ (function(module, exports) {



/***/ }),
/* 117 */
/***/ (function(module, exports) {



/***/ }),
/* 118 */,
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var SPApplicationLoader_1 = __webpack_require__(120);
var debugManifestProvider_1 = __webpack_require__(75);
var ManifestStore_1 = __webpack_require__(4);
var telemetryConstants = __webpack_require__(6);
var BaseComponentLoader = (function () {
    function BaseComponentLoader() {
        if (!BaseComponentLoader._headElement) {
            BaseComponentLoader._headElement = document.getElementsByTagName('head')[0];
        }
    }
    BaseComponentLoader.prototype.start = function (preloadedData) {
        return this._initialize(preloadedData, undefined).then(function () {
            return SPApplicationLoader_1.default.startApplication(preloadedData);
        }).catch(function (error) {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.startLogSource, error);
            throw error;
        });
    };
    BaseComponentLoader.prototype.loadComponentById = function (id, version) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        var parsedId = sp_core_library_1.Guid.parse(id).toString();
        var manifest = ManifestStore_1.default.instance.getManifest(parsedId, version);
        return this.loadComponent(manifest);
    };
    BaseComponentLoader.prototype.registerManifests = function (manifests) {
        ManifestStore_1.default.instance.registerManifests(manifests, false);
    };
    Object.defineProperty(BaseComponentLoader.prototype, "manifests", {
        get: function () {
            return ManifestStore_1.default.instance.getRegisteredManifests();
        },
        enumerable: true,
        configurable: true
    });
    BaseComponentLoader.prototype.loadCss = function (url) {
        sp_core_library_1.Validate.isNonemptyString(url, 'url');
        var linkTag = document.createElement('link');
        linkTag.rel = 'stylesheet';
        linkTag.type = 'text/css';
        linkTag.href = url;
        BaseComponentLoader._headElement.appendChild(linkTag);
    };
    BaseComponentLoader.prototype._forceLocalManifests = function () {
        return debugManifestProvider_1.loadDebugManifests(this, ['https://localhost:4321/temp/manifests.js', 'http://localhost:4321/temp/manifests.js'], 
 true, 
 true, 
 true, 
 true);
    };
    BaseComponentLoader.prototype.tryGetManifestById = function (id, version) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        var parsedId = sp_core_library_1.Guid.parse(id).toString();
        return ManifestStore_1.default.instance.tryGetManifest(parsedId, version);
    };
    return BaseComponentLoader;
}());
exports.BaseComponentLoader = BaseComponentLoader;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_telemetry_1 = __webpack_require__(2);
var SPComponentLoaderProxy_1 = __webpack_require__(74);
var ManifestStore_1 = __webpack_require__(4);
var componentConstants = __webpack_require__(21);
var telemetryConstants = __webpack_require__(6);
var sp_core_library_1 = __webpack_require__(0);
var SPLoader_resx_1 = __webpack_require__(5);
var SPApplicationLoader = (function () {
    function SPApplicationLoader() {
    }
    SPApplicationLoader.startApplication = function (preloadedData) {
        var qosMonitor = new sp_telemetry_1._QosMonitor(telemetryConstants.startQosScenarioName);
        setTimeout(function () {
            if (!qosMonitor.hasEnded) {
                qosMonitor.writeExpectedFailure(telemetryConstants.timeoutExpectedFailure);
            }
        }, SPApplicationLoader.TIMEOUT_IN_MILISECONDS);
        return SPApplicationLoader._startApplication(preloadedData, qosMonitor);
    };
    SPApplicationLoader._startApplication = function (preloadedData, qosMonitor) {
        var _this = this;
        function error(message, failureId) {
            var error = new Error(message);
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.startLogSource, error);
            qosMonitor.writeUnexpectedFailure(failureId, error);
            throw error;
        }
        return Promise.resolve().then(function () {
            var platformManifest = _this._getPlatformManifest(error);
            var applicationId = preloadedData.clientSideApplicationId;
            var applicationManifest = _this._getApplicationManifest(applicationId, error);
            var platformPromise = _this._loadPlatform(platformManifest, error);
            var applicationPromise = _this._loadApplication(applicationManifest, error);
            return Promise.all([platformPromise, applicationPromise])
                .then(function (modules) {
                var platform = modules[0];
                var application = modules[1];
                if (platform && application) {
                    return platform._spShell.start(application, preloadedData).then(function (result) {
                        qosMonitor.writeSuccess();
                        return result;
                    }).catch(function (e) {
                        error(sp_core_library_1.Text.format(SPLoader_resx_1.default.applicationFailedToInitializeError, e), telemetryConstants.shellStartFailure);
                    });
                }
                else if (!platform) {
                    error(sp_core_library_1.Text.format(SPLoader_resx_1.default.platformFailedToLoadError, componentConstants.spApplicationBaseComponentId, componentConstants.spApplicationBaseName), telemetryConstants.platformFailedToLoadFailure);
                }
                else {
                    error(sp_core_library_1.Text.format(SPLoader_resx_1.default.applicationFailedToLoadError, applicationManifest.id, applicationManifest.loaderConfig.entryModuleId), telemetryConstants.applicationFailedToLoadFailure);
                }
            });
        });
    };
    SPApplicationLoader._getPlatformManifest = function (error) {
        return this._getManifest(componentConstants.spApplicationBaseComponentId, error, telemetryConstants.missingPlatformManifestFailure);
    };
    SPApplicationLoader._getApplicationManifest = function (applicationId, error) {
        return this._getManifest(applicationId, error, telemetryConstants.missingApplicationManifestFailure);
    };
    SPApplicationLoader._getManifest = function (componentId, error, failureId) {
        var manifest = ManifestStore_1.default.instance.tryGetManifest(componentId);
        if (!manifest) {
            return error(sp_core_library_1.Text.format(SPLoader_resx_1.default.manifestNotFoundByIdError, componentId), failureId);
        }
        return manifest;
    };
    SPApplicationLoader._loadPlatform = function (manifest, error) {
        return this._loadComponent(manifest, error, SPLoader_resx_1.default.platformFailedToLoadWithMessageError, telemetryConstants.platformFailedToLoadFailure);
    };
    SPApplicationLoader._loadApplication = function (manifest, error) {
        return this._loadComponent(manifest, error, SPLoader_resx_1.default.applicationFailedToLoadWithMessageError, telemetryConstants.applicationFailedToLoadFailure);
    };
    SPApplicationLoader._loadComponent = function (manifest, error, errorMessage, failureId) {
        return SPComponentLoaderProxy_1.default.loadComponent(manifest)
            .catch(function (e) {
            return error(sp_core_library_1.Text.format(errorMessage, manifest.id, manifest.loaderConfig.entryModuleId, e.message), failureId);
        });
    };
    return SPApplicationLoader;
}());
SPApplicationLoader.TIMEOUT_IN_MILISECONDS = 10000;
exports.default = SPApplicationLoader;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ensureDebugComponents_1 = __webpack_require__(122);
var _debugAllowed =  true ? true : undefined;
var _debugAllowedPromise;
function confirmDebugAllowed(prompt) {
    if (prompt === false || _debugAllowed !== undefined) {
        return Promise.resolve(peek());
    }
    else if (!_debugAllowedPromise) {
        _debugAllowedPromise = new Promise(function (resolve) {
            ensureDebugComponents_1.default().then(function (debugComponents) {
                debugComponents.showDebugPrompt(function (allowed) {
                    _debugAllowed = allowed;
                    resolve(allowed);
                });
            });
        });
    }
    return _debugAllowedPromise;
}
exports.confirmDebugAllowed = confirmDebugAllowed;
function dangerouslyForceDebug() {
    _debugAllowed = true;
}
exports.dangerouslyForceDebug = dangerouslyForceDebug;
function peek() {
    return !!_debugAllowed;
}
exports.peek = peek;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _debugComponentsPromise;
function ensureDebugComponents() {
    if (!_debugComponentsPromise) {
        _debugComponentsPromise = new Promise(function (resolve) {
            __webpack_require__.e/* require.ensure */(1).then((function (require) {
                var debugComponents = __webpack_require__(202);
                resolve(debugComponents);
            }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
        });
    }
    return _debugComponentsPromise;
}
exports.default = ensureDebugComponents;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AddressStore = (function () {
    function AddressStore() {
        this._addressMap = new Map();
    }
    Object.defineProperty(AddressStore, "instance", {
        get: function () {
            if (!AddressStore._instance) {
                AddressStore._instance = new AddressStore();
            }
            return AddressStore._instance;
        },
        enumerable: true,
        configurable: true
    });
    AddressStore.prototype.get = function (normalizedName) {
        return this._addressMap.get(normalizedName);
    };
    AddressStore.prototype.set = function (normalizedName, address) {
        if (!this._addressMap.has(normalizedName)) {
            this._addressMap.set(normalizedName, address);
        }
    };
    return AddressStore;
}());
exports.default = AddressStore;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LocaleStore = (function () {
    function LocaleStore() {
    }
    LocaleStore.getLocale = function () {
        return LocaleStore._locale;
    };
    LocaleStore.setLocale = function (locale) {
        LocaleStore._locale = locale;
    };
    return LocaleStore;
}());
LocaleStore._locale = undefined;
exports.default = LocaleStore;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var resolveAddress_1 = __webpack_require__(80);
var SPLoader_resx_1 = __webpack_require__(5);
var telemetryConstants = __webpack_require__(6);
var UrlStatus;
(function (UrlStatus) {
    UrlStatus[UrlStatus["Undefined"] = 0] = "Undefined";
    UrlStatus[UrlStatus["OK"] = 1] = "OK";
    UrlStatus[UrlStatus["FileNotFound"] = 2] = "FileNotFound";
    UrlStatus[UrlStatus["Forbidden"] = 3] = "Forbidden";
    UrlStatus[UrlStatus["ClientError"] = 4] = "ClientError";
    UrlStatus[UrlStatus["ServerError"] = 5] = "ServerError";
    UrlStatus[UrlStatus["NetworkError"] = 6] = "NetworkError";
})(UrlStatus || (UrlStatus = {}));
var ResourceUrlChecker = (function () {
    function ResourceUrlChecker() {
    }
    ResourceUrlChecker.checkResourceUrl = function (manifest, name) {
        sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
        sp_core_library_1.Validate.isNonemptyString(name, 'name');
        var url = resolveAddress_1.default(manifest, name);
        return ResourceUrlChecker._getUrlStatus(url).then(function (urlStatus) {
            if (urlStatus !== UrlStatus.OK) {
                return ResourceUrlChecker._throwUrlStatusError(urlStatus, manifest, name, url);
            }
            return Promise.resolve();
        });
    };
    ResourceUrlChecker._throwUrlStatusError = function (urlStatus, manifest, name, url) {
        var errorString = '';
        switch (urlStatus) {
            case UrlStatus.FileNotFound:
                if (url.match(ResourceUrlChecker.localhostUrlRegex)) {
                    errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusLocalhostFileNotFoundError, manifest.id, manifest.alias, name, url); 
                }
                else {
                    errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusFileNotFoundError, manifest.id, manifest.alias, name, url);
                }
                break;
            case UrlStatus.Forbidden:
                errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusForbiddenError, manifest.id, manifest.alias, name, url);
                break;
            case UrlStatus.ClientError:
                errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusClientErrorError, manifest.id, manifest.alias, name, url);
                break;
            case UrlStatus.ServerError:
                errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusServerErrorError, manifest.id, manifest.alias, name, url);
                break;
            case UrlStatus.NetworkError:
                if (url.match(ResourceUrlChecker.localhostUrlRegex)) {
                    errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusLocalhostNetworkErrorError, manifest.id, manifest.alias, name, url); 
                }
                else if (url.match(ResourceUrlChecker.httpsUrlRegex)) {
                    errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusHttpsNetworkErrorError, manifest.id, manifest.alias, name, url);
                }
                else {
                    errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusNetworkErrorError, manifest.id, manifest.alias, name, url);
                }
                break;
            case UrlStatus.Undefined:
            default:
                errorString = sp_core_library_1.Text.format(SPLoader_resx_1.default.urlStatusUndefinedError, manifest.id, manifest.alias, name, url);
        }
        var error = new Error(errorString);
        sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, error);
        throw error;
    };
    ResourceUrlChecker._getUrlStatus = function (url) {
        var requestInit = {
            method: 'HEAD',
            mode: 'cors'
        };
        var request = new Request(url, requestInit);
        return window.fetch(request).then(function (response) {
            var httpStatusCode = response.status;
            if (httpStatusCode >= 200 && httpStatusCode < 300) {
                return UrlStatus.OK;
            }
            if (httpStatusCode === 404) {
                return UrlStatus.FileNotFound;
            }
            if (httpStatusCode === 403) {
                return UrlStatus.Forbidden;
            }
            if (httpStatusCode >= 400 && httpStatusCode < 500) {
                return UrlStatus.ClientError;
            }
            if (httpStatusCode >= 500 && httpStatusCode < 600) {
                return UrlStatus.ServerError;
            }
            return UrlStatus.Undefined;
        }).catch(function (error) {
            return UrlStatus.NetworkError;
        });
    };
    return ResourceUrlChecker;
}());
ResourceUrlChecker.localhostUrlRegex = /^http[s]?:\/\/localhost/;
ResourceUrlChecker.httpsUrlRegex = /^https:\/\//;
exports.default = ResourceUrlChecker;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ManifestStore_1 = __webpack_require__(4);
var componentConstants = __webpack_require__(21);
function initializeNpmModule() {
    ensureReactIsLoaded();
    ManifestStore_1.default.instance.registerManifests([
        __webpack_require__(205)("./" + componentConstants.spTelemetryComponentId + ".manifest.json"),
        __webpack_require__(204)("./" + componentConstants.odspUtilitiesBundleComponentId + ".manifest.json")
    ], false);
}
exports.initializeNpmModule = initializeNpmModule;
function ensureReactIsLoaded() {
    var url = __webpack_require__(430);
    var relativeReactUrl = '../../../react/dist/react.js'; 
    var relativeReactDomUrl = '../../../react-dom/dist/react-dom.js'; 
    var store = ManifestStore_1.default.instance;
    var reactIsPopulated = !!store.tryGetManifest(componentConstants.reactComponentId);
    var reactDomIsPopulated = !!store.tryGetManifest(componentConstants.reactDomComponentId);
    if (!reactIsPopulated && relativeReactUrl !== '__RELATIVE_' + 'REACT_PATH__') {
        var reactUrl = url.resolve(__webpack_require__.p, relativeReactUrl);
        var reactManifest = {
            id: componentConstants.reactComponentId,
            manifestVersion: 2,
            componentType: 'Library',
            alias: 'react',
            version: '15.4.2',
            loaderConfig: {
                internalModuleBaseUrls: [],
                entryModuleId: 'react',
                scriptResources: {
                    'react': {
                        type: 'path',
                        path: reactUrl
                    }
                }
            }
        };
        store.registerManifests([reactManifest], false);
        reactIsPopulated = true;
    }
    if (!reactDomIsPopulated && relativeReactDomUrl !== '__RELATIVE_' + 'REACT_DOM_PATH__') {
        var reactDomUrl = url.resolve(__webpack_require__.p, relativeReactDomUrl);
        var reactDomManifest = {
            id: componentConstants.reactDomComponentId,
            manifestVersion: 2,
            componentType: 'Library',
            alias: 'react-dom',
            version: '15.4.2',
            loaderConfig: {
                internalModuleBaseUrls: [],
                entryModuleId: 'react-dom',
                scriptResources: {
                    'react-dom': {
                        type: 'path',
                        path: reactDomUrl
                    },
                    'react': {
                        type: 'component',
                        id: componentConstants.reactComponentId,
                        version: '15.4.2' 
                    }
                }
            }
        };
        store.registerManifests([reactDomManifest], false);
        reactDomIsPopulated = true;
    }
    if (!reactIsPopulated || !reactDomIsPopulated) {
        throw new Error('The loader was unable to locate React and/or React-DOM. This indicates a problem occured ' +
            'during npm install. Try deleting and re-running npm install.');
    }
}


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ErrorHelper_1 = __webpack_require__(9);
/** An instance of EventGroup allows anything with a handle to it to trigger events on it.
 *  If the target is an HTMLElement, the event will be attached to the element and can be
 *  triggered as usual (like clicking for onclick).
 *  The event can be triggered by calling EventGroup.raise() here. If the target is an
 *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
 *  handled here in EventGroup, and the handler is called in the context of the parent
 *  (which is passed in in the constructor).
 */
var EventGroup = (function () {
    /** parent: the context in which events attached to non-HTMLElements are called */
    function EventGroup(parent) {
        this._id = EventGroup._uniqueId++;
        this._parent = parent;
        this._eventRecords = [];
    }
    /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.
     *  Events raised here by default have bubbling set to false and cancelable set to true.
     *  This applies also to built-in events being raised manually here on HTMLElements,
     *  which may lead to unexpected behavior if it differs from the defaults.
     */
    EventGroup.raise = function (target, eventName, eventArgs, bubbleEvent) {
        var retVal;
        if (EventGroup._isElement(target)) {
            if (document.createEvent) {
                var ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, bubbleEvent, true);
                ev['args'] = eventArgs;
                retVal = target.dispatchEvent(ev);
            }
            else if (document['createEventObject']) {
                var evObj = document['createEventObject'](eventArgs);
                // cannot set cancelBubble on evObj, fireEvent will overwrite it
                target.fireEvent("on" + eventName, evObj);
            }
        }
        else {
            while (target && retVal !== false) {
                var events = target.__events__;
                var eventRecords = events ? events[eventName] : null;
                for (var id in eventRecords) {
                    var eventRecordList = eventRecords[id];
                    for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
                        var record = eventRecordList[listIndex];
                        if (record.objectCallback) {
                            retVal = record.objectCallback.call(record.parent, eventArgs);
                        }
                    }
                }
                // If the target has a parent, bubble the event up.
                target = bubbleEvent ? target.parent : null;
            }
        }
        return retVal;
    };
    EventGroup.isObserved = function (target, eventName) {
        var events = target && target.__events__;
        return !!events && !!events[eventName];
    };
    /** Check to see if the target has declared support of the given event. */
    EventGroup.isDeclared = function (target, eventName) {
        var declaredEvents = target && target.__declaredEvents;
        return !!declaredEvents && !!declaredEvents[eventName];
    };
    EventGroup.stopPropagation = function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        }
        else {
            event.cancelBubble = true;
        }
    };
    EventGroup._isElement = function (target) {
        return !!target && (target instanceof HTMLElement || target.addEventListener);
    };
    EventGroup.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this.off();
            this._parent = null;
        }
    };
    /** On the target, attach a set of events, where the events object is a name to function mapping. */
    EventGroup.prototype.onAll = function (target, events, useCapture) {
        for (var eventName in events) {
            this.on(target, eventName, events[eventName], useCapture);
        }
    };
    /** On the target, attach an event whose handler will be called in the context of the parent
     * of this instance of EventGroup.
     */
    EventGroup.prototype.on = function (target, eventName, callback, useCapture) {
        var _this = this;
        if (eventName.indexOf(',') > -1) {
            var events = eventName.split(/[ ,]+/);
            for (var i = 0; i < events.length; i++) {
                this.on(target, events[i], callback, useCapture);
            }
        }
        else {
            var parent = this._parent;
            var eventRecord = {
                target: target,
                eventName: eventName,
                parent: parent,
                callback: callback,
                objectCallback: null,
                elementCallback: null,
                useCapture: useCapture
            };
            // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
            var events_1 = (target.__events__ = target.__events__ || {});
            events_1[eventName] = events_1[eventName] || {
                count: 0
            };
            events_1[eventName][this._id] = events_1[eventName][this._id] || [];
            events_1[eventName][this._id].push(eventRecord);
            events_1[eventName].count++;
            if (EventGroup._isElement(target)) {
                var processElementEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    try {
                        var result = callback.apply(parent, args);
                        if (result === false && args[0] && args[0].preventDefault) {
                            var e = args[0];
                            e.preventDefault();
                            e.cancelBubble = true;
                        }
                    }
                    catch (e) {
                        ErrorHelper_1.default.log(e);
                    }
                    return result;
                };
                eventRecord.elementCallback = processElementEvent;
                if (target.addEventListener) {
                    /* tslint:disable:ban-native-functions */
                    target.addEventListener(eventName, processElementEvent, useCapture);
                }
                else if (target.attachEvent) {
                    target.attachEvent("on" + eventName, processElementEvent);
                }
            }
            else {
                var processObjectEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    return callback.apply(parent, args);
                };
                eventRecord.objectCallback = processObjectEvent;
            }
            // Remember the record locally, so that it can be removed.
            this._eventRecords.push(eventRecord);
        }
    };
    EventGroup.prototype.off = function (target, eventName, callback, useCapture) {
        for (var i = 0; i < this._eventRecords.length; i++) {
            var eventRecord = this._eventRecords[i];
            if ((!target || target === eventRecord.target) &&
                (!eventName || eventName === eventRecord.eventName) &&
                (!callback || callback === eventRecord.callback) &&
                ((typeof useCapture !== 'boolean') || useCapture === eventRecord.useCapture)) {
                var events = eventRecord.target.__events__;
                var targetArrayLookup = events[eventRecord.eventName];
                var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
                // We may have already target's entries, so check for null.
                if (targetArray) {
                    if (targetArray.length === 1 || !callback) {
                        targetArrayLookup.count -= targetArray.length;
                        delete events[eventRecord.eventName][this._id];
                    }
                    else {
                        targetArrayLookup.count--;
                        targetArray.splice(targetArray.indexOf(eventRecord), 1);
                    }
                    if (!targetArrayLookup.count) {
                        delete events[eventRecord.eventName];
                    }
                }
                if (eventRecord.elementCallback) {
                    if (eventRecord.target.removeEventListener) {
                        eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.useCapture);
                    }
                    else if (eventRecord.target.detachEvent) {
                        eventRecord.target.detachEvent("on" + eventRecord.eventName, eventRecord.elementCallback);
                    }
                }
                this._eventRecords.splice(i--, 1);
            }
        }
    };
    /** Trigger the given event in the context of this instance of EventGroup. */
    EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {
        return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
    };
    /** Declare an event as being supported by this instance of EventGroup. */
    EventGroup.prototype.declare = function (event) {
        var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
        if (typeof event === 'string') {
            declaredEvents[event] = true;
        }
        else {
            for (var i = 0; i < event.length; i++) {
                declaredEvents[event[i]] = true;
            }
        }
    };
    return EventGroup;
}());
EventGroup._uniqueId = 0;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EventGroup;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function generateUuidPart(length) {
    "use strict";
    var str = '';
    while (str.length < length) {
        var num = Math.random() * 16;
        num = num | 0; // clear decimal
        str += num.toString(16);
    }
    return str;
}
var Guid = (function () {
    function Guid() {
    }
    /**
     * Return a v4 UUID as specified by RFC 4122 http://tools.ietf.org/html/rfc4122
     */
    Guid.generate = function () {
        var parts = [];
        parts.push(generateUuidPart(8));
        parts.push(generateUuidPart(4));
        // first digit must be 4 since we are using pseudorandom numbers
        var timeHighAndVersion = '4' + generateUuidPart(3);
        parts.push(timeHighAndVersion);
        // first digit must have first two bits set to 10
        var clockSeqHiAndReserved = generateUuidPart(4);
        var intVal = parseInt(clockSeqHiAndReserved[0], 10);
        intVal = intVal & 3; // clear out first two bits
        intVal = intVal | 8; // set first bit to 1
        clockSeqHiAndReserved = intVal.toString(16) + clockSeqHiAndReserved.substr(1);
        parts.push(clockSeqHiAndReserved);
        parts.push(generateUuidPart(12));
        return parts.join('-');
    };
    /**
     * Normalizes a GUID to lowercase. Returns '' if guid is not given.
     * @param includeBrackets - if true, add or keep brackets; if false, strip brackets
     */
    Guid.normalizeLower = function (guid, includeBrackets) {
        return guid ? Guid._normalizeBrackets(guid.toLowerCase(), includeBrackets) : '';
    };
    /**
     * Normalizes a GUID to uppercase. Returns '' if guid is not given.
     * @param includeBrackets - if true, add or keep brackets; if false, strip brackets
     */
    Guid.normalizeUpper = function (guid, includeBrackets) {
        return guid ? Guid._normalizeBrackets(guid.toUpperCase(), includeBrackets) : '';
    };
    Guid._normalizeBrackets = function (guid, includeBrackets) {
        var match = guid.match(/^\{(.*)\}$/);
        if (match) {
            return includeBrackets ? match[0] : match[1];
        }
        return includeBrackets ? '{' + guid + '}' : guid;
    };
    return Guid;
}());
Guid.Empty = "00000000-0000-0000-0000-000000000000";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Guid;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ItemType_1 = __webpack_require__(85);
/**
 * Enumeration of icon file names, and what extensions they map to.
 * Please keep items alphabetical. Items without extensions may require specific logic in the code to map.
 * Track icon accuracy status here: https://msft-my.spoppe.com/personal/caperez_microsoft_com/Documents/Missing%20List.xlsx?web=1
 */
var FileTypeIconMap = {
    'accdb': { extensions: ['accdb', 'mdb'] },
    'archive': { type: ItemType_1.default.Unknown, extensions: ['7z', 'ace', 'arc', 'arj', 'dmg', 'gz', 'iso', 'lzh', 'pkg', 'rar', 'sit', 'tgz', 'tar', 'rar', 'z'] },
    'audio': { type: ItemType_1.default.Unknown, extensions: ['aif', 'aiff', 'aac', 'amr', 'au', 'awb', 'dct', 'dss', 'dvf', 'flac', 'gsm', 'm4a', 'm4p', 'mid', 'mmf', 'mp3', 'ogg', 'oga', 'ra', 'rm', 'wav', 'wma', 'wv'] },
    'code': { extensions: ['Hcp', 'abap', 'ada', 'adp', 'ahk', 'as', 'as3', 'asc', 'ascx', 'asm', 'asp', 'awk', 'bash', 'bash_login', 'bash_logout', 'bash_profile', 'bashrc', 'bat', 'bib', 'bsh', 'build', 'builder', 'c', 'c++', 'capfile', 'cc', 'cfc', 'cfm', 'cfml', 'cl', 'clj', 'cls', 'cmake', 'cmd', 'coffee', 'cpp', 'cpt', 'cpy', 'cs', 'cshtml', 'cson', 'csproj', 'css', 'ctp', 'cxx', 'd', 'ddl', 'di', 'disco', 'dml', 'dtd', 'dtml', 'el', 'emakefile', 'erb', 'erl', 'f', 'f90', 'f95', 'fs', 'fsi', 'fsscript', 'fsx', 'gemfile', 'gemspec', 'gitconfig', 'go', 'groovy', 'gvy', 'h', 'h++', 'haml', 'handlebars', 'hbs', 'hh', 'hpp', 'hrl', 'hs', 'htc', 'hxx', 'idl', 'iim', 'inc', 'inf', 'ini', 'inl', 'ipp', 'irbrc', 'jade', 'jav', 'java', 'js', 'json', 'jsp', 'jsx', 'l', 'less', 'lhs', 'lisp', 'log', 'lst', 'ltx', 'lua', 'm', 'make', 'markdn', 'markdown', 'mdown', 'mkdn', 'ml', 'mli', 'mll', 'mly', 'mm', 'mud', 'nfo', 'opml', 'osascript', 'p', 'pas', 'patch', 'php', 'php2', 'php3', 'php4', 'php5', 'phtml', 'pl', 'pm', 'pod', 'pp', 'profile', 'ps1', 'pt', 'py', 'pyw', 'r', 'rake', 'rb', 'rbx', 'rc', 're', 'reg', 'rest', 'resw', 'resx', 'rhtml', 'rjs', 'rprofile', 'rpy', 'rss', 'rst', 'rxml', 's', 'sass', 'scala', 'scm', 'sconscript', 'sconstruct', 'script', 'scss', 'sgml', 'sh', 'sh', 'shtml', 'sml', 'sql', 'sql', 'sty', 'tcl', 'tex', 'textile', 'tld', 'tli', 'tmpl', 'tpl', 'vb', 'vi', 'vim', 'wsdl', 'xhtml', 'xoml', 'xsd', 'xslt', 'yaml', 'yaws', 'yml', 'zsh'] },
    'css': {},
    'csv': { extensions: ['csv'] },
    'docset': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'docx': { extensions: ['doc', 'docm', 'docx'] },
    'dotx': { extensions: ['dot', 'dotm', 'dotx'] },
    'email': { type: ItemType_1.default.Unknown, extensions: ['eml', 'msg', 'ost', 'pst'] },
    'exe': { type: ItemType_1.default.Unknown, extensions: ['application', 'appref-ms', 'apk', 'app', 'appx', 'exe', 'ipa', 'msi', 'xap'] },
    'folder': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'font': { type: ItemType_1.default.Unknown, extensions: ['ttf', 'otf', 'woff'] },
    'genericfile': { type: ItemType_1.default.Unknown },
    'html': { extensions: ['htm', 'html', 'mht'] },
    'link': { type: ItemType_1.default.Unknown, extensions: ['lnk', 'link', 'url', 'website', 'webloc'] },
    'listitem': { type: ItemType_1.default.Unknown, extensions: ['listitem'] },
    'model': { extensions: ['3ds', 'blend', 'dae', 'df', 'dwfx', 'dwg', '3mf', 'fbx', 'ply', 'obj', 'stl', 'gltf', 'glb', 'dxf', 'layout', 'off', 'max', 'skp', 'stp', 't', 'thl', 'x'] },
    'mpp': { extensions: ['mpp'] },
    'mpt': { extensions: ['mpt'] },
    'odp': { extensions: ['odp'] },
    'ods': { extensions: ['ods'] },
    'odt': { extensions: ['odt'] },
    'one': { type: ItemType_1.default.OneNote, extensions: ['one'] },
    'onepkg': { type: ItemType_1.default.OneNote, extensions: ['onepkg'] },
    'onetoc': { type: ItemType_1.default.OneNote, extensions: ['ms-one-stub', 'onetoc', 'onetoc2'] },
    'pdf': { extensions: ['pdf'] },
    'photo': { type: ItemType_1.default.Media, extensions: ['arw', 'bmp', 'cr2', 'crw', 'dcr', 'dds', 'dib', 'dng', 'erf', 'gif', 'ico', 'jfi', 'jfif', 'jif', 'jpe', 'jpeg', 'jpg', 'kdc', 'mrw', 'nef', 'orf', 'pct', 'pict', 'png', 'pns', 'psd', 'raw', 'tga', 'tif', 'tiff', 'wdp'] },
    'potx': { extensions: ['pot', 'potm', 'potx'] },
    'ppsx': { extensions: ['pps', 'ppsm', 'ppsx'] },
    'pptx': { extensions: ['ppt', 'pptm', 'pptx'] },
    'pub': { extensions: ['pub'] },
    'spo': { extensions: ['aspx'] },
    'rtf': { extensions: ['epub', 'rtf', 'wri'] },
    'sharedfolder': { type: ItemType_1.default.Folder, iconType: 'svg' },
    'sysfile': { type: ItemType_1.default.Unknown, extensions: ['bak', 'bin', 'cab', 'cache', 'cat', 'cer', 'class', 'dat', 'db', 'dbg', 'dl_', 'dll', 'ithmb', 'jar', 'kb', 'kdc', 'ldt', 'lrprev', 'ppa', 'ppam', 'pdb', 'rom', 'thm', 'thmx', 'vsl', 'xla', 'xlam', 'xll'] },
    'txt': { extensions: ['dif', 'diff', 'md', 'markdown', 'out', 'plist', 'properties', 'readme', 'text', 'txt'] },
    'vector': { type: ItemType_1.default.Unknown, extensions: ['ai', 'dgn', 'pd', 'emf', 'eps', 'indd', 'indt', 'ps', 'svg', 'svgz', 'wmf'] },
    'video': { type: ItemType_1.default.Media, extensions: ['3gp', 'asf', 'avi', 'dvr-ms', 'flv', 'm1v', 'm4v', 'mkv', 'mod', 'mov', 'mm4p', 'mp2', 'mp2v', 'mp4', ' mpa', 'mpe', 'mpeg', 'mpg', 'mpv', 'mpv2', 'mts', 'ogg', 'qt', 'swf', 'ts', 'vob', 'webm', 'wlmp', 'wm', 'wmv', 'wmx'] },
    'vsdx': { extensions: ['vsd', 'vsdm', 'vsdx', 'vdw'] },
    'vssx': { extensions: ['vss', 'vssm', 'vssx'] },
    'vstx': { extensions: ['vst', 'vstm', 'vstx'] },
    'xlsx': { extensions: ['xls', 'xlsb', 'xlsm', 'xlsx'] },
    'xltx': { extensions: ['xlt', 'xltm', 'xltx'] },
    'xml': { extensions: ['xaml', 'xml', 'xsl'] },
    'xps': { extensions: ['oxps', 'xps'] },
    'xsn': { extensions: ['xsn'] },
    'zip': { type: ItemType_1.default.Unknown, extensions: ['zip'] }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = FileTypeIconMap;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var SharingType;
(function (SharingType) {
    SharingType[SharingType["Public"] = 0] = "Public";
    SharingType[SharingType["PublicUnlisted"] = 2] = "PublicUnlisted";
    SharingType[SharingType["Shared"] = 3] = "Shared";
    SharingType[SharingType["Private"] = 4] = "Private";
    SharingType[SharingType["Unknown"] = 5] = "Unknown";
})(SharingType || (SharingType = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SharingType;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var SharingType_1 = __webpack_require__(130);
function usePrivateFolderIcon(itemSharingType) {
    return (itemSharingType === undefined ||
        itemSharingType === SharingType_1.default.Private ||
        itemSharingType === SharingType_1.default.Unknown); // erring on caution--if sharingType is Unknown, show it as not shared
}
exports.usePrivateFolderIcon = usePrivateFolderIcon;
function showSubTextSharingIcon(itemSharingType) {
    return (itemSharingType !== undefined &&
        itemSharingType !== SharingType_1.default.Private &&
        itemSharingType !== SharingType_1.default.Unknown); // additionally, the Unknown case should be not shared as well
}
exports.showSubTextSharingIcon = showSubTextSharingIcon;
function shouldRequestSharedWithData(itemSharingType) {
    return (itemSharingType !== SharingType_1.default.Private); // not including Unknown, should fetch the shared with information when uncertain
}
exports.shouldRequestSharedWithData = shouldRequestSharedWithData;
function useSharedFolderAriaLabel(itemSharingType) {
    return (itemSharingType === SharingType_1.default.Shared); // not including Unknown, don't mentioned sharing state when uncertain
}
exports.useSharedFolderAriaLabel = useSharedFolderAriaLabel;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Locale = (function () {
    function Locale() {
    }
    /**
     * Sets the locale to be used by the app.
     * @param {string} language - The language used to render the app.
     */
    Locale.invalidate = function (language) {
        Locale.isRightToLeft = (document.documentElement.getAttribute('dir') === 'rtl');
        Locale.safeLeft = Locale.isRightToLeft ? 'right' : 'left';
        Locale.safeRight = Locale.isRightToLeft ? 'left' : 'right';
        /** Robert Chen has the detailed explanation here : The most magic thing here is that OneDrive page and teamsite page has exactly the same line of code with regard to html tag Lang attribute.
         * <SharePoint:SPHtmlTag lang="<%$Resources:wss,language_value%>" dir="<%$Resources:wss,multipages_direction_dir_value%>" ID="SPHtmlTag" runat="server">
         * And in teamsite doclib, this lang gets executed to the current user locale. And that is actually already a magic------What happens here is the in order to get the doclib page in ContentDB, we had a standard MondoSproc call which gets the page and the SPWeb. In constructing the web, SP *  * code has smart logic to set Thread.CurrentThread.CurrentUICulture to match the MUI language! And with that magic, ="<%$Resources:wss,language_value%> actually gets sets properly to the user language, not the pre-defined web language.
         * For OneDrive.aspx which lives inside _layouts folder, the order of code execution changes. We must have executed this line of ASPX code first ="<%$Resources:wss,language_value%> before SPWeb was opened and did the magic to set Thread.CurrentThread.CurrentUICulture.
         * So the Thread.CurrentThread.CurrentUICulture affecting ="<%$Resources:wss,language_value%> with SPWeb magic end up not working in Onedrive.aspx! And theres really nothing that we can do about it unless we rewrite the page!
         * So the conclusion is that the lang attribute is by design (of implementation) different from the regular team site pages which live inside content db.
         */
        language = language || window["_spPageContextInfo"] && window["_spPageContextInfo"].currentUICultureName;
        // fallback of xml:lang for IE9
        Locale.language = language ||
            document.documentElement.getAttribute('lang') ||
            document.documentElement.getAttribute('xml:lang') ||
            'en-us';
    };
    return Locale;
}());
Locale.invalidate();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Locale;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Guid_1 = __webpack_require__(128);
var CorrelationVector = (function () {
    function CorrelationVector(parent, current) {
        if (parent) {
            this.root = parent.root;
            this.parent = parent.current;
        }
        else {
            this.root = this.parent = Guid_1.default.Empty;
        }
        if (current) {
            this.current = current;
        }
        else {
            this.current = Guid_1.default.generate();
        }
    }
    CorrelationVector.prototype.toString = function () {
        return this.root + "#" + this.parent + "#" + this.current;
    };
    return CorrelationVector;
}());
CorrelationVector.RootVector = window['rootVector'] || new CorrelationVector();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CorrelationVector;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var PairedEventBase_1 = __webpack_require__(86);
var Qos_event_1 = __webpack_require__(33);
var ResultTypeEnum_1 = __webpack_require__(34);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
exports.Api = PairedEventBase_1.createPairedEvent({
    eventName: 'Api,Qos,',
    shortEventName: 'Api',
    samplingFeature: { ODB: true, ODC: 'ApiEventLogging', Fallback: false }
}, {
    url: 1 /* String */
}, Qos_event_1.Qos);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Api;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.PLTHttpRequest = SingleEventBase_1.createSingleEvent({
    eventName: 'PLTHttpRequest,',
    shortEventName: 'PLTHttpRequest',
    samplingFeature: { ODB: true, ODC: 'PLTHttpRequestSampling', Fallback: false }
}, {
    startTime: 2 /* Number */,
    url: 1 /* String */,
    duration: 2 /* Number */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.PLTHttpRequest;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
var CaughtError_event_1 = __webpack_require__(87);
var ResultTypeEnum_1 = __webpack_require__(34);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
exports.QosError = SingleEventBase_1.createSingleEvent({
    eventName: 'QosError,CaughtError,Trace,',
    shortEventName: 'QosError',
    critical: true
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    },
    resultCode: 1 /* String */,
    resultType: {
        typeRef: ResultTypeEnum_1.ResultTypeEnum,
        type: 6 /* Enum */
    }
}, CaughtError_event_1.CaughtError);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.QosError;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.RUMOneDataUpload = SingleEventBase_1.createSingleEvent({
    eventName: 'RUMOneDataUpload,',
    shortEventName: 'RUMOneDataUpload'
}, {
    streamName: 1 /* String */,
    dictionary: 4 /* Object */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.RUMOneDataUpload;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.RequireJSError = SingleEventBase_1.createSingleEvent({
    eventName: 'RequireJSError,',
    shortEventName: 'RequireJSError',
    critical: true,
    requiresParent: false
}, {
    message: 1 /* String */,
    requireModules: 5 /* Array */,
    requireType: 1 /* String */,
    stack: 1 /* String */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.RequireJSError;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.Trace = SingleEventBase_1.createSingleEvent({
    eventName: 'Trace,',
    shortEventName: 'Trace',
    requiresParent: false
}, {
    message: 1 /* String */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Trace;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
var Trace_event_1 = __webpack_require__(139);
exports.Verbose = SingleEventBase_1.createSingleEvent({
    eventName: 'Verbose,Trace,',
    shortEventName: 'Verbose',
    requiresParent: false
}, {
    name: {
        isKey: true,
        type: 1 /* String */
    }
}, Trace_event_1.Trace);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Verbose;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var BaseDataStore_1 = __webpack_require__(55);
var DataStoreCachingType_1 = __webpack_require__(35);
var Manager_1 = __webpack_require__(16);
var LogProcessor_1 = __webpack_require__(142);
var BeaconCache;
(function (BeaconCache) {
    "use strict";
    var _store = new BaseDataStore_1.default(LogProcessor_1.default.STORE_KEY,  true ? DataStoreCachingType_1.default.sharedMemory : DataStoreCachingType_1.default.session);
    BeaconCache.eventNamePrefix = "";
    BeaconCache.instance = null;
    BeaconCache.handlers = null;
    if (true) {
        try {
            console.log("Beacon: To disable logging to the console set \"window.disableBeaconLogToConsole = true\" in the debug window");
        }
        catch (error) {
        }
    }
    var OdbBeaconCache = (function () {
        function OdbBeaconCache(eventNamePrefix, handlers) {
            var _this = this;
            BeaconCache.eventNamePrefix = eventNamePrefix;
            BeaconCache.handlers = handlers;
            var bufferedEvents = Manager_1.Manager.addLogHandler(function (event) {
                _this.addEvent(event);
            });
            // Add bufferred events to local store
            for (var x = 0; x < bufferedEvents.length; x++) {
                this.addEvent(bufferedEvents[x]);
            }
        }
        OdbBeaconCache.prototype.addEvent = function (event) {
            if (event.enabled) {
                // put every new event to the session storage so that Sharepoint can upload it for us
                // if user navigates away before Beacon event
                LogProcessor_1.default.processAndLogEvent({
                    event: event,
                    logFunc: function (streamName, dictProperties) {
                        var storeSize = _store.getValue(LogProcessor_1.default.STORE_SIZE_KEY);
                        if (!storeSize) {
                            storeSize = 0;
                        }
                        _store.setValue(storeSize.toString(), { name: streamName, props: dictProperties });
                        _store.setValue(LogProcessor_1.default.STORE_SIZE_KEY, ++storeSize);
                    },
                    eventNamePrefix: BeaconCache.eventNamePrefix,
                    handlers: BeaconCache.handlers
                });
            }
        };
        return OdbBeaconCache;
    }());
    function addToLoggingManager(eventNamePrefix, handlers) {
        if (!BeaconCache.instance) {
            BeaconCache.instance = new OdbBeaconCache(eventNamePrefix, handlers);
        }
        else {
            throw new Error("The beaconCache has already been added to the logging manager with event name prefix " + eventNamePrefix + ".");
        }
    }
    BeaconCache.addToLoggingManager = addToLoggingManager;
})(BeaconCache || (BeaconCache = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BeaconCache;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Qos_event_1 = __webpack_require__(33);
var PLT_event_1 = __webpack_require__(88);
var Beacon_event_1 = __webpack_require__(53);
var UnhandledError_event_1 = __webpack_require__(245);
var RequireJSError_event_1 = __webpack_require__(138);
var CaughtError_event_1 = __webpack_require__(87);
var QosError_event_1 = __webpack_require__(136);
var Verbose_event_1 = __webpack_require__(140);
var Engagement_event_1 = __webpack_require__(54);
var EventBase_1 = __webpack_require__(22);
var RUMOneDataUpload_event_1 = __webpack_require__(137);
var DebugPriorityLevel_1 = __webpack_require__(247);
var LogProcessor;
(function (LogProcessor) {
    "use strict";
    LogProcessor.STORE_KEY = "SPCacheLogger";
    LogProcessor.STORE_SIZE_KEY = "Size";
    var SOURCE_V2_Engagement = "ClientV2Engagement";
    var DEBUG_LOG_STREAM = "ReliabilityLog";
    var USER_ENGAGEMENT_STREAM = "UserEngagement";
    var SOURCE_V2_Reliability = "ClientV2Reliability";
    // regex for SLAPI event names
    var SLAPI_EVENT_NAME_ALLOW = /[^a-z0-9\.\_\-\+]+/ig;
    var _spModuleLink = window['_spModuleLink'];
    var _appVersion = _spModuleLink ? _spModuleLink.buildNumber : "";
    function processAndLogEvent(params) {
        // Ignored events
        if (params.handlers.ignoredEventsHandler && params.handlers.ignoredEventsHandler(params.event)) {
            return;
        }
        // Get the data to log
        var logDataArray = Engagement_event_1.Engagement.isTypeOf(params.event) ? _processEngagementEvent(params.event) :
            Qos_event_1.Qos.isTypeOf(params.event) ? _processQosEvent(params.event, params.handlers.qosEventNameHandler || null, params.handlers.qosEventExtraDataHandler || null) :
                PLT_event_1.PLT.isTypeOf(params.event) ? _processPLTEvent(params.event) :
                    UnhandledError_event_1.UnhandledError.isTypeOf(params.event) ? _processUnhandledErrorEvent(params.event) :
                        RequireJSError_event_1.RequireJSError.isTypeOf(params.event) ? _processRequireJSErrorEvent(params.event) :
                            CaughtError_event_1.CaughtError.isTypeOf(params.event) ? _processCaughtErrorEvent(params.event) :
                                Verbose_event_1.Verbose.isTypeOf(params.event) ? _processVerboseEvent(params.event) :
                                    Beacon_event_1.Beacon.isTypeOf(params.event) ? _processBeaconEvent(params.event) :
                                        RUMOneDataUpload_event_1.RUMOneDataUpload.isTypeOf(params.event) ? _processRUMOneDataUploadEvent(params.event) :
                                            null;
        // If the log data array is not defined the event was unhandled, log
        // the event name so is easy to discover and fix
        if (!logDataArray) {
            logDataArray = [{
                    userEngagementData: {
                        EngagementName: "UnknownEvent",
                        Duration: 0,
                        LogType: 0,
                        Properties: JSON.stringify({ name: params.event.eventName }),
                        ClientTime: params.event.eventType === EventBase_1.ClonedEventType.End ? params.event.endTime : params.event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        // Log all the data in the array adding the event prefix to the tag/name
        for (var index = 0, length = logDataArray.length; index < length; index++) {
            var logData = logDataArray[index];
            if (logData.debugData) {
                logData.debugData.Tag = _addEventPrefix(logData.debugData.Tag, params.eventNamePrefix).replace(SLAPI_EVENT_NAME_ALLOW, "");
                params.logFunc(DEBUG_LOG_STREAM, logData.debugData);
            }
            if (logData.userEngagementData) {
                // SPList: special case for Engagement events
                // set prefix to the name of the list type
                // to be able to track usage/engagement by list type
                var prefix = params.eventNamePrefix;
                if (Engagement_event_1.Engagement.isTypeOf(params.event) && prefix === 'SPList') {
                    // prefix will be set to a list type based on list base template
                    // if list type not found, [refix will be set back to generic SPList
                    prefix = _getScenarioNameFromListType();
                }
                logData.userEngagementData.EngagementName = _addEventPrefix(logData.userEngagementData.EngagementName, prefix).replace(SLAPI_EVENT_NAME_ALLOW, "");
                // SPList: special case for Qos events; add listBaseTemplate ID to the property bag
                if (Qos_event_1.Qos.isTypeOf(params.event) && params.eventNamePrefix === 'SPList') {
                    params.event.data.extraData["ListBaseTemplate"] = _getListBaseTemplate();
                }
                params.logFunc(USER_ENGAGEMENT_STREAM, logData.userEngagementData);
            }
            if (logData.rumOneData) {
                params.logFunc(logData.rumOneData.streamName, logData.rumOneData.dictionary);
            }
        }
    }
    LogProcessor.processAndLogEvent = processAndLogEvent;
    // get the list base template id
    function _getListBaseTemplate() {
        var listTemplate = -1;
        var spPageContextInfo = window['_spPageContextInfo'];
        if (spPageContextInfo !== undefined && spPageContextInfo !== null) {
            listTemplate = spPageContextInfo.listBaseTemplate;
        }
        return listTemplate;
    }
    // get the name of the listType; it's SPList for the unrecognized
    // list templates; TODO: add all templates
    function _getScenarioNameFromListType() {
        var scenarioName = "";
        var listTemplate = _getListBaseTemplate();
        switch (listTemplate) {
            case 100:
                scenarioName = "ListNext";
                break;
            case 101:
                scenarioName = "DocsNext";
                break;
            case 102:
                scenarioName = "SurveyNext";
                break;
            case 103:
                scenarioName = "LinksNext";
                break;
            case 104:
                scenarioName = "AnnouncementsNext";
                break;
            case 107:
                scenarioName = "TasksNext";
                break;
            case 109:
                scenarioName = "PicLibNext";
                break;
            default:
                scenarioName = "SPList";
                break;
        }
        return scenarioName;
    }
    // string examples: "{\"w3cResponseEnd\":2", "\"appStart\":750"
    function _cleanString(dataPLT) {
        var cleanString = dataPLT;
        cleanString = cleanString.replace("{", "");
        cleanString = cleanString.replace(/\"/gi, "");
        cleanString = cleanString.replace("}", "");
        return cleanString;
    }
    function _addEventPrefix(eventName, prefix) {
        if (!prefix) {
            return eventName;
        }
        return prefix + '.' + eventName;
    }
    function _getResultTypeSuffix(resultType) {
        if (resultType === Qos_event_1.ResultTypeEnum.Success) {
            return ".Success";
        }
        else if (resultType === Qos_event_1.ResultTypeEnum.Failure) {
            return ".Failure";
        }
        else if (resultType === Qos_event_1.ResultTypeEnum.ExpectedFailure) {
            return ".ExpectedFailure";
        }
        return "";
    }
    function _processRUMOneDataUploadEvent(event) {
        if (!event.data) {
            return [{
                    userEngagementData: {
                        EngagementName: "RUMOne.no_EventData",
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        var rumOneDataUpdateEventData = event.data;
        return [{
                rumOneData: {
                    streamName: rumOneDataUpdateEventData.streamName,
                    dictionary: rumOneDataUpdateEventData.dictionary
                }
            }];
    }
    function _processEngagementEvent(event) {
        var logDataList = [];
        // if the event has not data we will get this in COSMOS
        // if it's a start we have only the name and append ".Start" to it
        // else we look for resultCode and append it to data.name with result type
        // if resultCode is not present than we append only the result type to the name
        // i.e. serverDataGetValue.Start OR serverDataGetValue.ResponseText.GetAuth.ExpectedFailure
        var name = "no_EngagementName";
        var properties = "";
        if (event.data) {
            var engagementData = event.data;
            if (engagementData.name) {
                name = engagementData.name;
            }
            // if there is an experimentData object, it means there is an experiment so create and log a new tag for it
            // put all the experiment data in the properties bag;
            if (engagementData.experiment) {
                var abExperiment = engagementData.experiment;
                var experimentData = abExperiment.GetExperimentData();
                logDataList.push({ userEngagementData: {
                        EngagementName: _getExperimentEventName(experimentData, abExperiment.IsExperimentOn()),
                        Properties: JSON.stringify(experimentData),
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    } });
            }
            // put the extraData in the properties bag
            properties = engagementData.extraData ? JSON.stringify(engagementData.extraData) : "";
        }
        logDataList.push({ userEngagementData: {
                EngagementName: name,
                Properties: properties,
                Duration: 0,
                LogType: 0,
                ClientTime: event.startTime,
                Source: SOURCE_V2_Engagement
            } });
        return logDataList;
    }
    function _getExperimentEventName(experimentData, isOn) {
        var name = (experimentData.name ? experimentData.name : 'noExperimentData') +
            '.Experiment' +
            (isOn ? 'Treatment' : 'Control');
        return name;
    }
    function _processQosEvent(event, qoSEventNameHandler, qosEventExtraDataHandler) {
        var logData = {};
        // if the event has not data we will get this in COSMOS
        // if it's a start we have only the name and append ".Start" to it
        // else we look for resultCode and append it to data.name with result type
        // if resultCode is not present than we append only the result type to the name
        // i.e. serverDataGetValue.ResponseText.Success OR serverDataGetValue.ResponseText.GetAuth.ExpectedFailure
        var name = "no_QosName";
        var qosData = event.data ? event.data : null;
        if (qosData) {
            if (qosData.name) {
                name = qosData.name;
            }
            if (qoSEventNameHandler != null) {
                name = qoSEventNameHandler(event, name);
            }
            qosData.extraData = qosData.extraData || {};
            if (qosEventExtraDataHandler != null) {
                qosEventExtraDataHandler(event, qosData);
            }
            qosData.extraData["appver"] = _appVersion;
        }
        // Duration is calculated only when we have an END event
        var durationTime;
        if (event.eventType === EventBase_1.ClonedEventType.End && event.startTime && event.endTime) {
            durationTime = event.endTime - event.startTime;
        }
        else {
            durationTime = 0;
        }
        logData.userEngagementData = {
            EngagementName: name,
            Properties: qosData && qosData.extraData ? JSON.stringify(qosData.extraData) : "",
            Duration: durationTime,
            LogType: 0,
            ClientTime: event.eventType === EventBase_1.ClonedEventType.End ? event.endTime : event.startTime,
            Source: SOURCE_V2_Reliability
        };
        return [logData];
    }
    function _processBeaconEvent(event) {
        var logData = {};
        var durationTime;
        if (event.eventType === EventBase_1.ClonedEventType.End && event.startTime && event.endTime) {
            durationTime = event.endTime - event.startTime;
        }
        else {
            durationTime = 0;
        }
        logData.userEngagementData = {
            EngagementName: "Beacon",
            Properties: event.data ? JSON.stringify(event.data) : "no_EventData",
            Duration: durationTime,
            LogType: 0,
            ClientTime: event.eventType === EventBase_1.ClonedEventType.End ? event.endTime : event.startTime,
            Source: SOURCE_V2_Reliability
        };
        return [logData];
    }
    function _processPLTEvent(event) {
        if (!event.data) {
            return [{
                    userEngagementData: {
                        EngagementName: "PLT.no_EventData",
                        Duration: 0,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    }
                }];
        }
        var logDataList = [];
        //get the data for this event
        var pltData = event.data;
        // this will be the prefix for the tags; i.e. PLT.SetView-Files.w3cResponseEnd
        var name = "PLT." + pltData.name.replace(" ", "");
        // break down the PLT data and log each one as a separate record in the stream
        //{"name":"SetView-Files","w3cResponseEnd":424,"appStart":254,"preRender":20,"dataFetch":310,"postRender":327,"render":347,"plt":1335}
        var dataPLT = JSON.stringify(pltData).split(',');
        var duration = 0;
        // iterate through data and extract each type
        // create tags like this: PLT.<pagename>.w3cResponseEnd; PLT.<pagename>.appStart
        for (var i = 0; i < dataPLT.length; i++) {
            var cleanedPLTString = _cleanString(dataPLT[i]);
            // split the string and get the name and duration
            // special case for duration when appCacheHit is a boolean
            var subDataPLTs = cleanedPLTString.split(':');
            // skip the 'name' key-value pair
            if (_cleanString(subDataPLTs[1]) !== pltData.name) {
                if (subDataPLTs[1] === 'true') {
                    duration = 1;
                }
                else if (subDataPLTs[1] === 'false' || subDataPLTs[1] === 'null') {
                    duration = 0;
                }
                else {
                    duration = parseInt(subDataPLTs[1], 10);
                }
                logDataList.push({ userEngagementData: {
                        EngagementName: name + "." + subDataPLTs[0],
                        Properties: (subDataPLTs[0] === 'appCacheHit') ? JSON.stringify(event.data) : "",
                        Duration: duration,
                        LogType: 0,
                        ClientTime: event.startTime,
                        Source: SOURCE_V2_Engagement
                    } });
            }
        }
        return logDataList;
    }
    function _processUnhandledErrorEvent(event) {
        return [{
                userEngagementData: {
                    EngagementName: "UnhandledError",
                    Duration: 0,
                    LogType: 0,
                    ClientTime: event.startTime,
                    Source: SOURCE_V2_Engagement
                },
                debugData: {
                    Tag: "UnhandledError",
                    Level: DebugPriorityLevel_1.default.Normal,
                    Message: event.data ? JSON.stringify(event.data) : "no_EventData",
                    Misc: "",
                    ClientTime: event.startTime
                }
            }];
    }
    function _processRequireJSErrorEvent(event) {
        var logData = {};
        var name = "RequireJSError";
        var errorData;
        var errorMessage;
        if (event.data) {
            // clone all properties so that we can omit 'message' in JSON
            errorData = {};
            for (var key in event.data) {
                if (key !== "message") {
                    errorData[key] = event.data[key];
                }
                else {
                    errorMessage = event.data[key];
                }
            }
        }
        logData.userEngagementData = {
            EngagementName: name,
            Duration: 0,
            LogType: 0,
            ClientTime: event.startTime,
            Source: SOURCE_V2_Engagement
        };
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Normal,
            Message: errorMessage ? errorMessage : "no_ErrorMessage",
            Misc: errorData ? JSON.stringify(errorData) : "no_ErrorData",
            ClientTime: event.startTime
        };
        return [logData];
    }
    function _processCaughtErrorEvent(event) {
        var logData = {};
        var name = "CaughtError";
        if (QosError_event_1.QosError.isTypeOf(event)) {
            if (event.data) {
                var qosErrorData = event.data;
                name = qosErrorData.name;
                if (qosErrorData.resultCode) {
                    name += "." + qosErrorData.resultCode;
                }
                name += _getResultTypeSuffix(qosErrorData.resultType);
            }
            else {
                name = "QosErrorEvent.no_EventData";
            }
        }
        else {
            // log it once in the UserEngagement stream to count the hits
            logData.userEngagementData = {
                EngagementName: name,
                Duration: 0,
                LogType: 0,
                ClientTime: event.startTime,
                Source: SOURCE_V2_Engagement
            };
        }
        // log it again in ReliabilityLog stream with data for debugging
        var caughtErrorData = event.data ? event.data : null;
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Normal,
            Message: caughtErrorData && caughtErrorData.message ? caughtErrorData.message : "",
            Misc: caughtErrorData && caughtErrorData.stack ? JSON.stringify(caughtErrorData.stack) : "",
            ClientTime: event.startTime
        };
        return [logData];
    }
    function _processVerboseEvent(event) {
        var logData = {};
        var name = "Verbose";
        if (event.data) {
            var verboseData = event.data;
            if (verboseData.name) {
                name = verboseData.name + ".Verbose";
            }
        }
        else {
            name += ".no_EventData";
        }
        // log it in ReliabilityLog stream with data for debugging
        logData.debugData = {
            Tag: name,
            Level: DebugPriorityLevel_1.default.Low,
            Message: verboseData.message,
            Misc: "",
            ClientTime: event.startTime
        };
        return [logData];
    }
})(LogProcessor || (LogProcessor = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LogProcessor;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var PageTransitionType;
(function (PageTransitionType) {
    PageTransitionType[PageTransitionType["none"] = 0] = "none";
    PageTransitionType[PageTransitionType["fullPageLoad"] = 4] = "fullPageLoad";
    PageTransitionType[PageTransitionType["onePageAppNavigation"] = 5] = "onePageAppNavigation";
})(PageTransitionType || (PageTransitionType = {}));
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PageTransitionType;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

//Intentionally Override the normal camel casing style to title casing style because the schema has to match exactly the server side schema which is Title casing.
//Please do not change back to camel casing.
var RUMOneSLAPI = (function () {
    function RUMOneSLAPI() {
        this.ServerCorrelationId = null;
        this.ScenarioId = null;
        this.EUPL = undefined;
        this.ServerUrl = null;
        this.Browser = null;
        this.ClientIP = null;
        this.UserAgent = null;
        this.Flights = null;
        this.PageTransitionType = undefined;
        this.AppCache = undefined;
        this.FolderNav = undefined;
        this.InitiationTimeOffset = undefined;
        this.ServerRequestDuration = undefined;
        this.IISLatency = undefined;
        this.TTFB = undefined;
        this.TTLB = undefined;
        this.ParseTime = undefined;
        this.RenderTime = undefined;
        this.Control1Id = null;
        this.Control1RenderTime = undefined;
        this.Control2Id = null;
        this.Control2RenderTime = undefined;
        this.Control3Id = null;
        this.Control3RenderTime = undefined;
        this.Control4Id = null;
        this.Control4RenderTime = undefined;
        this.SharePointRequestCountTotal = undefined;
        this.SharePointRequestCountASPX = undefined;
        this.SharePointRequestCountJS = undefined;
        this.SharePointRequestCountCSS = undefined;
        this.SharePointRequestCountIMG = undefined;
        this.SharePointRequestCountNoneCached = undefined;
        this.SharePointRequestBytes = undefined;
        this.SharePointRequestDownloadTime = undefined;
        this.CDNRequestCountTotal = undefined;
        this.CDNRequestCountASPX = undefined;
        this.CDNRequestCountJS = undefined;
        this.CDNRequestCountCSS = undefined;
        this.CDNRequestCountIMG = undefined;
        this.CDNRequestCountNoneCached = undefined;
        this.CDNRequestBytes = undefined;
        this.CDNRequestDownloadTime = undefined;
        this.ThirdPartyRequestCountTotal = undefined;
        this.ThirdPartyRequestCountASPX = undefined;
        this.ThirdPartyRequestCountJS = undefined;
        this.ThirdPartyRequestCountCSS = undefined;
        this.ThirdPartyRequestCountIMG = undefined;
        this.ThirdPartyRequestCountNoneCached = undefined;
        this.ThirdPartyRequestBytes = undefined;
        this.ThirdPartyRequestDownloadTime = undefined;
        this.FromEdge = undefined;
        this.APICallCount = undefined;
        this.APICallDurationSum = undefined;
        this.PreRender = undefined;
        this.DataFetch = undefined;
        this.PostRender = undefined;
        this.W3cNavigationStart = undefined;
        this.W3cUnloadEventStart = undefined;
        this.W3cUnloadEventEnd = undefined;
        this.W3cFetchStart = undefined;
        this.W3cRedirectStart = undefined;
        this.W3cRedirectEnd = undefined;
        this.W3cDomainLookupStart = undefined;
        this.W3cDomainLookupEnd = undefined;
        this.W3cConnectStart = undefined;
        this.W3cSecureConnectStart = undefined;
        this.W3cConnectEnd = undefined;
        this.W3cRequestStart = undefined;
        this.W3cResponseStart = undefined;
        this.W3cResponseEnd = undefined;
        this.W3cDomLoading = undefined;
        this.W3cDomLoadEnd = undefined;
        this.W3cLoadEventStart = undefined;
        this.W3cLoadEventEnd = undefined;
        this.MDSDownloadStart = undefined;
        this.MDSParseDeltaStart = undefined;
        this.MDSParseDeltaEnd = undefined;
        this.MDSGCStart = undefined;
        this.MDSGCEnd = undefined;
        this.MDSCSSStart = undefined;
        this.MDSCSSEnd = undefined;
        this.MDSInnerHTMLStart = undefined;
        this.MDSScriptLoaderStart = undefined;
        this.MDSScriptLoaderEnd = undefined;
        this.MDSAnimationStart = undefined;
        this.MDSAnimationEnd = undefined;
        this.MDSParallelDownloadStart = undefined;
        this.MDSParallelDownloadEnd = undefined;
        this.APICalls = undefined;
        this.SharePointRequestNames = undefined;
        this.CDNRequestNames = undefined;
        this.ThirdPartyRequestNames = undefined;
        this.EUPLBreakdown = undefined;
        this.Control5Id = null;
        this.Control5RenderTime = undefined;
        this.Control6Id = null;
        this.Control6RenderTime = undefined;
        this.Control7Id = null;
        this.Control7RenderTime = undefined;
        this.Control8Id = null;
        this.Control8RenderTime = undefined;
        this.Control9Id = null;
        this.Control9RenderTime = undefined;
        this.Control10Id = null;
        this.Control10RenderTime = undefined;
        this.ServerMetrics = null;
        this.Referrer = null;
        this.BrowserIsMobile = undefined;
    }
    return RUMOneSLAPI;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RUMOneSLAPI;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Attempts to extract the default export from a module.
 *
 * @export
 * @template TExport
 * @param {IModule<TExport>} module
 * @returns {TExport}
 */
function getDefaultExport(module) {
    var exportValue;
    if (isModuleWithDefault(module)) {
        exportValue = module.default;
    }
    else {
        exportValue = module;
    }
    return exportValue;
}
exports.getDefaultExport = getDefaultExport;
/**
 * Returns the module itself as its own export.
 *
 * @export
 * @template TModule
 * @param {TModule} module
 * @returns {TModule}
 */
function getIdentityExport(module) {
    return module;
}
exports.getIdentityExport = getIdentityExport;
function isModuleWithDefault(module) {
    return !!module && typeof module === 'object' && 'default' in module;
}
exports.isModuleWithDefault = isModuleWithDefault;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var PLT_event_1 = __webpack_require__(88);
var PLTHttpRequest_event_1 = __webpack_require__(135);
var Api_event_1 = __webpack_require__(134);
var EventBase_1 = __webpack_require__(22);
var ErrorHelper_1 = __webpack_require__(9);
var Manager_1 = __webpack_require__(16);
var PerformanceMarker_1 = __webpack_require__(147);
exports.HighResolutionTimingSupported = PerformanceMarker_1.HighResolutionTimingSupported;
var performance = window.performance;
exports.AppStartMarkerName = "EUPL.AppStart";
exports.DataFetchStartMarkerName = "EUPL.DataManager.FirstDataFetch.GetItem.Start";
exports.DataFetchEndMarkerName = "EUPL.DataManager.FirstDataFetch.GetItem.End";
exports.OnePageNavigationStartMarkerName = "EUPL.OnePageNavigation.Start";
//For reference see http://www.w3.org/TR/navigation-timing/
//also, got tips at http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/
var PerformanceCollection = (function () {
    function PerformanceCollection() {
    }
    /**
     * When list data is returned from server as deferred control, browser w3c timing responseEnd may not reflect correct timing of the manifest response end.
     * To workaround this, we write "var g_responseEnd = new Date().getTime();" in server duration script tag.
     * In most of the scenarios, we will still use performance.timing.responseEnd.
     * If g_responseEnd is less than performance.timing.responseEnd or performance.timing.responseEnd is not available yet (this is will happen for deferred SPListRender sends splist data back to html), we will use g_responseEnd.
     */
    PerformanceCollection.getResponseEnd = function () {
        if (performance && performance.timing) {
            if (window["g_responseEnd"] &&
                (!!performance.timing.responseEnd && (Number(window["g_responseEnd"]) < performance.timing.responseEnd) || !performance.timing.responseEnd)) {
                return Number(window["g_responseEnd"]);
            }
            else {
                return performance.timing.responseEnd;
            }
        }
        else {
            return NaN;
        }
    };
    ;
    PerformanceCollection.appStart = function () {
        try {
            if (performance && performance.timing) {
                PerformanceCollection.mark(exports.AppStartMarkerName);
                Manager_1.Manager.addLogHandler(this.eventLogHandler);
                this.summary.w3cResponseEnd = (PerformanceCollection.getResponseEnd() - performance.timing.fetchStart); //Time to get the aspx from the server
                this._times["appStart"] = Date.now(); //Time it takes for our app to *start* running
                this.summary.appStart = this._times["appStart"] - PerformanceCollection.getResponseEnd(); //Time it takes for our app to *start* running
                this.summary.prefetchStart = -1;
                this.summary.deferredListDataRender = -1;
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
        }
    };
    //called when the view is fully loaded
    PerformanceCollection.plt = function (name) {
        try {
            if (performance && performance.timing && PerformanceCollection._times["plt"] === undefined) {
                var now = Date.now();
                var performanceNow = Math.round(performance.now());
                Manager_1.Manager.removeLogHandler(this.eventLogHandler);
                var onePageNavStart = PerformanceMarker_1.getMarkerTime(exports.OnePageNavigationStartMarkerName);
                this._times["plt"] = isNaN(onePageNavStart) ? (now - performance.timing.fetchStart) : (performanceNow - onePageNavStart);
                this.summary.preRender = PerformanceMarker_1.getMarkerTime(exports.DataFetchStartMarkerName) - PerformanceMarker_1.getMarkerTime(exports.AppStartMarkerName); //Time it takes for our app to make the relevant data fetch for this view
                this.summary.dataFetch = PerformanceMarker_1.getMarkerTime(exports.DataFetchEndMarkerName) - PerformanceMarker_1.getMarkerTime(exports.DataFetchStartMarkerName); //Time it takes for our app to get data back from the server
                this.summary.postRender = PerformanceCollection.now() - PerformanceMarker_1.getMarkerTime(exports.DataFetchEndMarkerName);
                this.summary.render = this.summary["preRender"] + this.summary["postRender"];
                this.summary.plt = this._times["plt"]; //unbiased end to end PLT from fetchStart that excludes unload of previous page.
                this.summary.pltWithUnload = now - performance.timing.navigationStart; //unbiased end to end PLT from navigationStart that includes the unload of the previous page
                this.summary.name = name;
                //we consider an appcache hit if the w3cResponseEnd time is less than 40ms
                this.summary.appCacheHit = this.summary.w3cResponseEnd <= 40 &&
                    Boolean(window.applicationCache) &&
                    Boolean(window.applicationCache.status !== window.applicationCache.UNCACHED);
                // ASSERT(this.summary.appStart +
                //     this.summary.dataFetch +
                //     this.summary.postRender +
                //     this.summary.preRender +
                //     this.summary.w3cResponseEnd ===
                //     this.summary.plt,
                //     "PLT summary times do not add up");
                // Get the count of events so we have it in the plt event logs
                // This must be logged before log data otherwise the count is not passed
                this.getHttpRequests();
                var event_1 = PLT_event_1.PLT.logData(this.summary);
                if (this.httpRequestCollection) {
                    for (var _i = 0, _a = this.httpRequestCollection; _i < _a.length; _i++) {
                        var eventData = _a[_i];
                        PLTHttpRequest_event_1.PLTHttpRequest.logData(eventData, event_1);
                    }
                }
                PerformanceCollection.mark('EUPL.glass');
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
        }
    };
    PerformanceCollection.mark = function (name, limit) {
        PerformanceMarker_1.mark(name, limit);
    };
    PerformanceCollection.pageLoaded = function () {
        return this._times["plt"] !== undefined;
    };
    PerformanceCollection.getMarkerTime = function (name) {
        return PerformanceMarker_1.getMarkerTime(name);
    };
    PerformanceCollection.now = function () {
        if (PerformanceMarker_1.HighResolutionTimingSupported) {
            return Math.round(performance.now());
        }
        else {
            return Date.now();
        }
    };
    PerformanceCollection.eventLogHandler = function (event) {
        // Look at all api events
        if (Api_event_1.Api.isTypeOf(event)) {
            if (PerformanceCollection._times["appDataFetchStart"] === undefined) {
                // Calculate the start time from the first api event
                PerformanceCollection._times["appDataFetchStart"] = event.startTime;
            }
            else if (event.eventType === EventBase_1.ClonedEventType.End || event.eventType === EventBase_1.ClonedEventType.Single) {
                // Calculate the end time from the api events
                PerformanceCollection._times["appDataFetchEnd"] = PerformanceCollection._times["appDataFetchEnd"] ? Math.max(PerformanceCollection._times["appDataFetchEnd"], event.endTime) : event.endTime;
            }
        }
    };
    PerformanceCollection.getHttpRequests = function () {
        if (performance && performance.getEntriesByType) {
            var httpRequestCollection = [];
            var perfEntries = performance.getEntriesByType("resource");
            var httpRequests = perfEntries.length;
            for (var j = 0; j < httpRequests; j++) {
                var data = {
                    startTime: Math.round(perfEntries[j].startTime),
                    url: perfEntries[j].name,
                    duration: Math.round(perfEntries[j].duration)
                };
                httpRequestCollection.push(data);
            }
            //Make sure we get all the http requests from iframes as well
            var iFrames = document.getElementsByTagName("iframe");
            httpRequests += iFrames.length;
            for (var i = 0; i < iFrames.length; i++) {
                try {
                    perfEntries = iFrames[i].contentWindow.performance.getEntriesByType("resource");
                }
                catch (e) {
                    // If the iframe in question isn't domain lowered, we can't access it.
                    perfEntries = null;
                }
                if (perfEntries) {
                    var requests = perfEntries.length;
                    httpRequests += requests;
                    for (var j = 0; j < requests; j++) {
                        var iframeData = {
                            startTime: Math.round(perfEntries[j].startTime),
                            url: perfEntries[j].name,
                            duration: Math.round(perfEntries[j].duration)
                        };
                        httpRequestCollection.push(iframeData);
                    }
                }
            }
            this.summary.httpRequests = httpRequests;
            this.httpRequestCollection = httpRequestCollection;
        }
    };
    return PerformanceCollection;
}());
PerformanceCollection.summary = {};
PerformanceCollection._times = {};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PerformanceCollection;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var performance = window.performance;
var HighResolutionTimingSupported = !!performance && typeof performance.mark === 'function' &&
    typeof performance.clearMarks === 'function' &&
    typeof performance.now === 'function';
exports.HighResolutionTimingSupported = HighResolutionTimingSupported;
exports.MARKER_PREFIX = "EUPL.";
var _markCount = 0;
var _perfMarks = window['_perfMarks'] = window['_perfMarks'] || []; // used for browsers do not support native performance.mark
function mark(name, limit) {
    'use strict';
    var markName = name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0 ? name : exports.MARKER_PREFIX + name;
    if (limit === null || limit === undefined || _markCount < limit) {
        if (HighResolutionTimingSupported) {
            performance.mark(markName);
        }
        else {
            _perfMarks.push({
                name: markName,
                startTime: Date.now()
            });
        }
        _markCount++;
    }
}
exports.mark = mark;
function getMarkerTime(name) {
    'use strict';
    var markName = name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0 ? name : exports.MARKER_PREFIX + name;
    if (HighResolutionTimingSupported) {
        var mark_1 = performance.getEntriesByName(markName);
        return mark_1 && mark_1.length > 0 ? Math.round(mark_1[0].startTime) : NaN;
    }
    else {
        var mark_2 = _perfMarks.filter(function (mark) { return mark.name === markName; })[0];
        return mark_2 && mark_2.startTime;
    }
}
exports.getMarkerTime = getMarkerTime;
function clearMarks() {
    'use strict';
    if (HighResolutionTimingSupported) {
        performance.getEntriesByType("mark").filter(function (mark) {
            return mark.name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0;
        }).forEach(function (mark) {
            performance.clearMarks(mark.name);
        });
    }
    else {
        _perfMarks = [];
    }
}
exports.clearMarks = clearMarks;
function getAllMarks() {
    'use strict';
    if (HighResolutionTimingSupported) {
        return performance.getEntriesByType("mark").filter(function (mark) {
            return mark.name.lastIndexOf(exports.MARKER_PREFIX, 0) === 0;
        });
    }
    else {
        return _perfMarks;
    }
}
exports.getAllMarks = getAllMarks;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var Promise_1 = __webpack_require__(51);
var Signal_1 = __webpack_require__(81);
var Scope_1 = __webpack_require__(149);
var Disposable_1 = __webpack_require__(83);
var lastId = 0;
var ResourceKey = (function () {
    function ResourceKey(nameOrOptions) {
        this.id = ++lastId;
        if (typeof nameOrOptions === 'string') {
            this.name = nameOrOptions;
        }
        else {
            this.name = nameOrOptions.name;
            this.factory = nameOrOptions.factory;
            this.loader = nameOrOptions.loader;
        }
    }
    Object.defineProperty(ResourceKey.prototype, "lazy", {
        /**
         * Gets an identifier for this {ResourceKey} as a lazy dependency (wrap in a function for deferred evaluation)
         */
        get: function () {
            return new ResourceDependency(this, 1 /* lazy */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceKey.prototype, "local", {
        /**
         * Gets an identifier for this {ResourceKey} as a local dependency (resolved in the local ResourceScope)
         */
        get: function () {
            return new ResourceDependency(this, 2 /* local */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceKey.prototype, "optional", {
        /**
         * Gets an identifier for this {ResourceKey} as an optional dependency
         */
        get: function () {
            return new ResourceDependency(this, 4 /* optional */);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Provides information about this resource key
     */
    ResourceKey.prototype.toString = function () {
        return "Resource #" + this.id + " \"" + this.name + "\"";
    };
    return ResourceKey;
}());
exports.ResourceKey = ResourceKey;
var ResourceDependency = (function () {
    function ResourceDependency(key, flags) {
        this.key = key;
        this.flags = flags;
    }
    Object.defineProperty(ResourceDependency.prototype, "lazy", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 1 /* lazy */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "local", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 2 /* local */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "optional", {
        get: function () {
            return new ResourceDependency(this.key, this.flags | 4 /* optional */);
        },
        enumerable: true,
        configurable: true
    });
    return ResourceDependency;
}());
var ConstantResourceFactory = (function () {
    function ConstantResourceFactory(value) {
        this._value = value;
        this.dependencies = {};
    }
    ConstantResourceFactory.prototype.create = function () {
        return { instance: this._value };
    };
    return ConstantResourceFactory;
}());
exports.ConstantResourceFactory = ConstantResourceFactory;
exports.resourceScopeKey = new ResourceKey({
    name: 'resources'
});
exports.asyncLoadBarrierKey = new ResourceKey({
    name: 'asyncLoadBarrier'
});
var CacheOnSuccessLoader = (function () {
    function CacheOnSuccessLoader(loader) {
        this._loader = loader;
    }
    CacheOnSuccessLoader.prototype.load = function () {
        var _this = this;
        var load = preventCancellation(this._loader.load());
        load.done(undefined, function () {
            // On error, reset the cache so the next load can try again.
            delete _this.load;
        });
        this.load = function () { return load; };
        return load;
    };
    return CacheOnSuccessLoader;
}());
var Handle = (function () {
    function Handle(entry, instanceManager) {
        this.entry = entry;
        this.manager = instanceManager;
    }
    Handle.prototype.getInstance = function (key, resourceScopeOptions) {
        var manager = this.manager;
        var factory = this.entry.factory;
        var resource = factory.create(manager.resolve(factory.dependencies, resourceScopeOptions));
        var instance = resource.instance;
        if (resource.disposable) {
            manager.scope.attach(resource.disposable);
        }
        this.getInstance = function () { return instance; };
        return instance;
    };
    Handle.prototype.promote = function (targetHandleManager) {
        var entry = this.entry;
        return new Handle({
            manager: targetHandleManager,
            loader: entry.loader,
            factory: entry.factory
        });
    };
    return Handle;
}());
var logBeginConstruction;
var logEndConstruction;
var logConsume;
var logExpose;
var log;
function getResolvedConstructor(resolvableConstructor, resolvedDependencies) {
    var Resolved = function (params) {
        var instance = resolvableConstructor.call(this, params, resolvedDependencies) || this;
        return instance;
    };
    if (true) {
        // This pattern results in the correct type being displayed in the debugger
        var wrappedConstructor_1 = Resolved;
        Resolved = function (params) {
            logBeginConstruction(resolvableConstructor, 'Resources.resolved');
            var instance = wrappedConstructor_1.call(Object.create(resolvableConstructor.prototype), params);
            logEndConstruction(resolvableConstructor, 'Resources.resolved');
            return instance;
        };
    }
    Resolved.prototype = resolvableConstructor.prototype;
    return Resolved;
}
exports.getResolvedConstructor = getResolvedConstructor;
var HandleManager = (function () {
    function HandleManager(parentOrOptions) {
        this._handles = {};
        this._isLocked = false;
        var options;
        if (parentOrOptions instanceof HandleManager) {
            if (parentOrOptions.isDisposed) {
                throw new Error('Parent ResourceScope has already been disposed!');
            }
            options = parentOrOptions.options;
            this._parent = parentOrOptions;
            this._level = parentOrOptions._level + 1;
        }
        else {
            options = parentOrOptions || {};
            this._level = 0;
            if (true) {
                // Check for setting and enable tracing if set
                if (!('__ResourceTraceState' in window) && (localStorage && localStorage['EnableResourceTracing'])) {
                    window['__ResourceTraceState'] = {
                        log: [],
                        stack: [],
                        types: {},
                        exposed: {}
                    };
                }
                log('Created new root level Resource Scope');
            }
        }
        this.scope = new Scope_1.default();
        this.options = options;
    }
    Object.defineProperty(HandleManager.prototype, "isDisposed", {
        get: function () {
            return this.scope.isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    HandleManager.prototype.block = function (key) {
        return this._expose(key);
    };
    HandleManager.prototype.isDescendantOf = function (manager) {
        return this._level > manager._level;
    };
    HandleManager.prototype.getHandle = function (key) {
        var manager = this;
        var keyId = key.id;
        // Starting with this scope, attempt to find the first scope with an entry (may be undefined)
        // for the given key. Stop when there are no more ancestor scopes.
        while (!(keyId in manager._handles) && manager._parent) {
            manager = manager._parent;
        }
        var handles = manager._handles;
        return handles[keyId] || this.options.useFactoriesOnKeys &&
            (key.factory && (handles[keyId] = new Handle({
                factory: key.factory,
                manager: manager
            })) || (key.loader && (handles[keyId] = new Handle({
                loader: new CacheOnSuccessLoader(key.loader),
                manager: manager
            }))));
    };
    HandleManager.prototype.expose = function (key, source, instance) {
        return this._expose(key, function (handleManager) { return new Handle({
            factory: source.factory,
            loader: source.loader,
            manager: handleManager
        }, instance && handleManager); });
    };
    HandleManager.prototype.getLoader = function () {
        this.lock();
        var loader = new ResourceLoader(this);
        this.getLoader = function () { return loader; };
        return loader;
    };
    HandleManager.prototype.dispose = function () {
        this.scope.dispose();
        this._handles = {};
        this.consume = this.resolve = onConsumeAfterDispose;
        this.getLoader = onLoadAfterDispose;
    };
    HandleManager.prototype.bind = function (key) {
        var handle = this.getHandle(key);
        if (handle) {
            return this._expose(key, function (handleManager) { return handle.promote(handleManager); });
        }
        return this;
    };
    HandleManager.prototype.lock = function () {
        this._isLocked = !!this.options.lockResourcesForChildren;
    };
    HandleManager.prototype.consume = function (dependency, scopeOptions) {
        var _this = this;
        this.lock();
        var key = (dependency.key || dependency);
        var options = dependency.flags;
        var thunk;
        if (key === exports.resourceScopeKey) {
            var resourceScope_1;
            thunk = function () {
                if (!resourceScope_1) {
                    resourceScope_1 = _this.scope.attach(new ResourceScope(_this, scopeOptions || { owner: "" + key }));
                }
                return resourceScope_1;
            };
        }
        else {
            var handle_1 = this._getValidHandle(dependency, []);
            if (!(handle_1 instanceof Error)) {
                thunk = function () { return handle_1.getInstance(key, scopeOptions || { owner: "" + key }); };
            }
            else if (!(options & 4 /* optional */)) {
                throw handle_1;
            }
        }
        return ((options & 1 /* lazy */) ? thunk : (thunk && thunk()));
    };
    HandleManager.prototype.isExposed = function (dependency) {
        return !(this._getValidHandle(dependency, []) instanceof Error);
    };
    HandleManager.prototype.resolve = function (dependencies, scopeOptions) {
        var result = {};
        for (var _i = 0, _a = Object.keys(dependencies); _i < _a.length; _i++) {
            var id = _a[_i];
            var dependency = dependencies[id];
            if (!dependency) {
                continue;
            }
            result[id] = this.consume(dependencies[id], scopeOptions);
        }
        return result;
    };
    HandleManager.prototype._getValidHandle = function (resourceDependency, stack) {
        var key = (resourceDependency.key || resourceDependency);
        var keyId = key.id;
        if (stack.indexOf(key) >= 0) {
            // Circular reference will *always* throw, even on isExposed.
            throw new Error(key + " has a circular dependency.");
        }
        // If we have a handle with a manager cached, return it.
        var localHandle = this._handles[keyId];
        if (localHandle && localHandle.manager) {
            return localHandle;
        }
        var handle = this.getHandle(key);
        if (!handle) {
            return new Error(key + " is being consumed, but has not been exposed by a parent scope.");
        }
        var entry = handle.entry;
        var factory = entry.factory;
        if (!factory) {
            return new Error(key + " is being consumed synchronously, but was exposed asynchronously and has not been loaded.");
        }
        // Find the highest possible scope at which an instance of T can be stored.
        stack.push(key);
        var instanceManager = handle.manager;
        var targetManager = (resourceDependency.flags & 2 /* local */)
            ? this : instanceManager || entry.manager;
        var dependencies = factory.dependencies || {};
        for (var _i = 0, _a = Object.keys(dependencies); _i < _a.length; _i++) {
            var id = _a[_i];
            var dependency = dependencies[id];
            // Dependency on resourceScopeKey does not affect targeting
            if (!dependency || (dependency.key || dependency) === exports.resourceScopeKey) {
                continue;
            }
            // Recurse on dependencies.
            var dependencyHandle = this._getValidHandle(dependency, stack);
            if (dependencyHandle instanceof Error) {
                if (!(dependency.flags & 4 /* optional */)) {
                    stack.pop();
                    return dependencyHandle;
                }
            }
            else if (dependencyHandle.manager.isDescendantOf(targetManager)) {
                targetManager = dependencyHandle.manager;
            }
        }
        stack.pop();
        if (!instanceManager || instanceManager !== targetManager) {
            // Need a new handle.
            handle = new Handle(entry, targetManager);
            // Place on targetManager, so that other levels can reuse
            targetManager._handles[keyId] = handle;
        }
        return this._handles[keyId] = handle;
    };
    HandleManager.prototype._expose = function (key, createHandle) {
        if (this.isDisposed) {
            throw new Error('Cannot expose a resource on a ResourceScope that has been disposed.');
        }
        if (key === exports.resourceScopeKey) {
            throw new Error('It is illegal to expose the ResourceScope key');
        }
        var keyId = key.id;
        var handleManager = this._isLocked ? this.scope.attach(new HandleManager(this)) : this;
        var handles = handleManager._handles;
        if (handles[keyId]) {
            if (this.options.noDoubleExpose) {
                throw new Error(key + " has already been exposed/consumed at this scope.");
            }
            else if (true) {
                log("Duplicate exposure of " + key + ".");
            }
        }
        handles[keyId] = createHandle ? createHandle(handleManager) : void 0;
        return handleManager;
    };
    return HandleManager;
}());
function onConsumeAfterDispose() {
    throw new Error('Cannot consume a resource from a ResourceScope that has been disposed.');
}
function onLoadAfterDispose() {
    throw new Error('Cannot load a resource from a ResourceScope that has been disposed.');
}
function voidify() {
    // Do nothing
}
function getFirstError(errors) {
    for (var key in errors) {
        if (errors[key]) {
            return Promise_1.default.wrapError(errors[key]);
        }
    }
    return Promise_1.default.wrapError(new Error('A dependency could not be loaded.'));
}
var ResourceLoader = (function () {
    function ResourceLoader(handleManager) {
        this._handleManager = handleManager;
        this._loadState = {};
        this._root = handleManager.consume(exports.asyncLoadBarrierKey.optional);
    }
    /**
     * Performs an async load of the specified resource. Should return a successful result if the value is optional or loads.
     * Should return an error result if the value is non-optional and fails to load.
     * Should return the same promise for multiple requests to the same key.
     */
    ResourceLoader.prototype.loadAsync = function (dependency) {
        // Loading the ResourceScope key is always successful.
        var key = dependency.key || dependency;
        if (key === exports.resourceScopeKey) {
            return Promise_1.default.as();
        }
        var options = dependency.flags;
        var promise = this._loadAsync(key);
        return (options & 4 /* optional */) ? promise.then(null, voidify) : promise;
    };
    ResourceLoader.prototype.loadAllAsync = function (dependencies) {
        if (dependencies) {
            var dependencyNames = Object.keys(dependencies);
            var length_1 = dependencyNames.length;
            if (length_1 > 0) {
                var promises = {};
                while (length_1--) {
                    var name_1 = dependencyNames[length_1];
                    var dependency = dependencies[name_1];
                    if (!dependency) {
                        continue;
                    }
                    promises[name_1] = this.loadAsync(dependency);
                }
                return Promise_1.default.all(promises).then(voidify, getFirstError);
            }
        }
        return Promise_1.default.as();
    };
    ResourceLoader.prototype._loadAsync = function (key) {
        var _this = this;
        // Check the cache
        var keyId = key.id;
        var loadStateMap = this._loadState;
        var cached = loadStateMap[keyId];
        if (cached) {
            return cached;
        }
        // Validate that there is a valid handle for the key
        var handleManager = this._handleManager;
        var handle = handleManager.getHandle(key);
        if (!handle) {
            return loadStateMap[keyId] = Promise_1.default.wrapError(new Error(key + " is being loaded, but has no factory/loader."));
        }
        // Mark possible circular reference
        loadStateMap[keyId] = Promise_1.default.as();
        // If we have a synchronously available factory, load its dependencies
        var entry = handle.entry;
        var factory = entry.factory;
        if (factory) {
            return loadStateMap[keyId] = this.loadAllAsync(factory.dependencies);
        }
        // Finally, fall back to the loader
        var loader = entry.loader;
        if (!loader) {
            return loadStateMap[keyId] = Promise_1.default.wrapError(new Error(key + " is being loaded, but no loader was defined."));
        }
        var root = this._root;
        var rootPromise = root && root.wait() || Promise_1.default.as();
        return loadStateMap[keyId] = rootPromise.then(function () { return loader.load(); }).then(function (value) {
            if (true) {
                log("Loaded " + key);
            }
            entry.factory = value;
            var factoryDependencies = value.dependencies;
            if (factoryDependencies) {
                return _this.loadAllAsync(factoryDependencies);
            }
        });
    };
    return ResourceLoader;
}());
var ResourceScope = (function () {
    function ResourceScope(parentOrOptions, options) {
        var parentOwner;
        var handleManager;
        if (parentOrOptions instanceof ResourceScope) {
            handleManager = parentOrOptions._handleManager;
            parentOwner = parentOrOptions._owner;
        }
        else if (parentOrOptions instanceof HandleManager) {
            handleManager = parentOrOptions;
        }
        else {
            options = parentOrOptions || options;
        }
        var scope = new Scope_1.default();
        if (handleManager) {
            if (handleManager.scope.isDisposed) {
                throw new Error('Parent ResourceScope has already been disposed.');
            }
            handleManager.lock();
            if (!handleManager.options.lockResourcesForChildren) {
                this._prepareWrite = this._fork;
            }
        }
        this._handleManager = handleManager || (handleManager = scope.attach(new HandleManager(options)));
        this._scope = scope;
        var owner = options ? options.owner : '';
        this._owner = parentOwner ? parentOwner + " > " + owner : owner;
        if (true) {
            log("new ResourceScope: '" + owner + "'");
        }
    }
    /**
     * Obtains an instance of a resource with the given key exposed by either this scope
     * or a parent. Throws if the resource is not found and isOptional is not set.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @returns an instance of the resource, if available in this scope or a parent.
     */
    ResourceScope.prototype.consume = function (dependency) {
        if (true) {
            logConsume(dependency);
        }
        return this._handleManager.consume(dependency);
    };
    /**
     * Obtains an instance of a resource with the given key exposed by either this scope
     * or a parent. Throws if the resource is not found and isOptional is not set.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @returns a promise for an instance of the resource, if available in this scope or a parent.
     */
    ResourceScope.prototype.consumeAsync = function (dependency) {
        if (true) {
            logConsume(dependency);
        }
        var handleManager = this._handleManager;
        return preventCancellation(handleManager.getLoader().loadAsync(dependency).then(function () {
            return handleManager.consume(dependency);
        }));
    };
    /**
     * Ensures that the specified dependencies have been loaded for synchronous consumption.
     * @param dependencies {IResourceDependencies} - the dependencies to load.
     * @returns a promise that will complete when the specified resources are available.
     */
    ResourceScope.prototype.load = function (dependencies) {
        return preventCancellation(this._handleManager.getLoader().loadAllAsync(dependencies));
    };
    /**
     * Exposes an asynchronous loader for a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param loader - the object that can asynchronously load a factory of the desired type
     */
    ResourceScope.prototype.exposeAsync = function (key, loader) {
        this._expose(key, {
            loader: new CacheOnSuccessLoader(loader)
        });
    };
    /**
     * Exposes a factory for a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param factory - the factory that will construct instances when required by this or any child scope.
     */
    ResourceScope.prototype.exposeFactory = function (key, factory) {
        this._expose(key, {
            factory: factory
        });
    };
    /**
     * Exposes a resource with the given type-safe key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @param instance - the instance of the resource to use within this scope.
     */
    ResourceScope.prototype.expose = function (key, instance) {
        if (true) {
            logExpose(key, this._owner, instance);
        }
        this._expose(key, {
            factory: new ConstantResourceFactory(instance)
        }, instance);
        return instance;
    };
    /**
     * Hides any resources exposed by parent scopes for the specified key.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     */
    ResourceScope.prototype.block = function (key) {
        this._handleManager = this._prepareWrite().block(key);
    };
    /**
     * Re-exposes the currently exposed resource at the specified key at the current resource scope.
     * The effect of this is that the lifetime of instances created by the resource system that depend on the
     * specific key will not exceed the lifetime of this resource scope.
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     */
    ResourceScope.prototype.bind = function (key) {
        this._handleManager = this._prepareWrite().bind(key);
    };
    /**
     * Checks if a given resource key is defined and known to the system.
     */
    ResourceScope.prototype.isDefined = function (key) {
        var handleManager = this._handleManager;
        return !handleManager.isDisposed && !!handleManager.getHandle(key);
    };
    /**
     * Checks if a given resource key is exposed in the resource scope (including in parent scopes).
     * @param key {ResourceKey} - a shared resource key corresponding to a specific named resource.
     * @return {boolean}
     */
    ResourceScope.prototype.isExposed = function (dependency) {
        if (true) {
            logConsume(dependency);
        }
        var handleManager = this._handleManager;
        return !handleManager.isDisposed && handleManager.isExposed(dependency);
    };
    /**
     * Produces an alternate constructor for the given type which pre-injects the instance with resources
     * before invoking the real constructor.
     * This function preserves the original argument types for the constructor, allowing validation
     * of arguments.
     * @param type - the type of object for which to create an injected constructor.
     * @returns an injected version of the original constructor for the type.
     */
    ResourceScope.prototype.injected = function (type, options) {
        if (options === void 0) { options = {}; }
        var injectChildResourceScope = options.injectChildResourceScope;
        var childOptions = {
            owner: options.owner || type.name
        };
        var resources = injectChildResourceScope ? this._scope.attach(new ResourceScope(this, childOptions)) : this;
        var Injected = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.resources = resources;
            var instance = type.apply(this, args) || this;
            if (injectChildResourceScope) {
                Disposable_1.hook(instance, disposeInstanceResources);
            }
            return instance;
        };
        if (true) {
            // This pattern results in the correct type being displayed in the debugger
            var wrappedConstructor_2 = Injected;
            Injected = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                logBeginConstruction(type, 'Resources.injected');
                var instance = wrappedConstructor_2.apply(Object.create(type.prototype), args);
                logEndConstruction(type, 'Resources.injected');
                return instance;
            };
        }
        Injected.prototype = type.prototype;
        return Injected;
    };
    /**
     * Resolves a set of resource keys
     *
     * @param dependencies - an object that maps names to {ResourceKey} instances.
     * @returns an object mapping the original names to the resolved resources.
     */
    ResourceScope.prototype.resolve = function (dependencies) {
        return this._handleManager.resolve(dependencies);
    };
    /**
     * Resolves a set of resource keys
     *
     * @param dependencies - an object that maps names to {ResourceKey} instances.
     * @returns an object mapping the original names to the resolved resources.
     */
    ResourceScope.prototype.resolveAsync = function (dependencies) {
        var _this = this;
        return this.load(dependencies).then(function () { return _this.resolve(dependencies); });
    };
    ResourceScope.prototype.resolved = function (type, dependencies) {
        return getResolvedConstructor(type, this.resolve(__assign({}, (type.dependencies || {}), (dependencies || {}))));
    };
    ResourceScope.prototype.resolvedAsync = function (type, dependencies) {
        var _this = this;
        return this.load(__assign({}, (type.dependencies || {}), (dependencies || {}))).then(function () { return _this.resolved(type, dependencies); });
    };
    /**
     * Disposes this resource scope and any resources bound to this scope's lifetime.
     */
    ResourceScope.prototype.dispose = function () {
        this._scope.dispose();
    };
    ResourceScope.prototype._expose = function (key, source, instance) {
        this._handleManager = this._prepareWrite().expose(key, source, instance);
    };
    // These methods are to support legacy call patterns by imitating old behavior
    ResourceScope.prototype._prepareWrite = function () {
        return this._handleManager;
    };
    ResourceScope.prototype._fork = function () {
        delete this._prepareWrite;
        if (true) {
            log("Fork: '" + this._owner + "'");
        }
        return this._scope.attach(new HandleManager(this._handleManager));
    };
    return ResourceScope;
}());
exports.ResourceScope = ResourceScope;
function disposeInstanceResources() {
    this.resources.dispose();
}
if (true) {
    var lastTypeNameId_1 = 0;
    var getTraceState_1 = function () {
        return window['__ResourceTraceState'];
    };
    logBeginConstruction = function (type, wrapperType) {
        var traceState = getTraceState_1();
        if (traceState) {
            var typeName = type['name'] + "_" + ++lastTypeNameId_1;
            var stack = traceState.stack, types = traceState.types;
            var parent_1 = stack[stack.length - 1] || '_root';
            stack.push(typeName);
            (types[parent_1] || (types[parent_1] = {}))[typeName] = wrapperType;
            if (!(typeName in types)) {
                types[typeName] = {};
            }
        }
    };
    logEndConstruction = function (type, wrapperType) {
        var traceState = getTraceState_1();
        if (traceState) {
            traceState.stack.pop();
        }
    };
    logConsume = function (dependency) {
        var traceState = getTraceState_1();
        var key = dependency.key || dependency;
        var isOptional = dependency.flags & 4 /* optional */;
        if (traceState) {
            var stack = traceState.stack, types = traceState.types;
            var parent_2 = stack[stack.length - 1] || '_root';
            (types[parent_2] || (types[parent_2] = {}))[isOptional ? key.id + "?" : key.id] = key.name;
        }
    };
    logExpose = function (key, owner, instance) {
        var traceState = getTraceState_1();
        if (traceState) {
            var typeName = instance && instance.constructor['name'];
            var exposed = traceState.exposed;
            (exposed[owner] || (exposed[owner] = [])).push({
                id: key.id,
                name: key.name,
                type: typeName
            });
        }
    };
    log = function (message) {
        var traceState = getTraceState_1();
        if (traceState) {
            traceState.log.push(message);
        }
    };
}
function preventCancellation(promise) {
    var signal = new Signal_1.default();
    promise.done(function (result) { return signal.complete(result); }, function (error) { return signal.error(error); });
    return signal.getPromise();
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ResourceScope;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Disposable_1 = __webpack_require__(83);
/**
 * Lifetime manager for scoping components.
 *
 * @export
 * @class Scope
 * @implements {IDisposable}
 *
 * @example
 *  const scope = new Scope();
 *
 *  let instance = new (scope.attached(MyComponent))();
 *
 *  scope.dispose();
 */
var Scope = (function () {
    /**
     * Creates an instance of Scope.
     */
    function Scope() {
        this._disposables = {};
        this._lastDisposableId = 0;
    }
    /**
     * Produces a constructor for instances of a type which will be bound to the lifetime
     * of this scope.
     *
     * @template T the type of object to be created.
     * @param {T} the original constructor for the type.
     * @returns {T} a new constructor to invoke to create the object.
     */
    Scope.prototype.attached = function (type) {
        var scope = this;
        var Attached = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return scope.attach(type.apply(this, args) || this);
        };
        if (true) {
            // This pattern results in the correct type being displayed in the debugger
            var wrappedConstructor_1 = Attached;
            Attached = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return wrappedConstructor_1.apply(Object.create(type.prototype), args);
            };
        }
        Attached.prototype = type.prototype;
        return Attached;
    };
    Scope.prototype.attach = function (instance) {
        var _this = this;
        var id = "" + ++this._lastDisposableId;
        var disposable = Disposable_1.hook(instance, function () {
            delete _this._disposables[id];
        });
        this._disposables[id] = disposable;
        return disposable;
    };
    /**
     * Disposes this scope and any attached objects.
     */
    Scope.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
        }
        var disposables = this._disposables;
        for (var _i = 0, _a = Object.keys(disposables); _i < _a.length; _i++) {
            var id = _a[_i];
            var disposable = disposables[id];
            if (disposable && Disposable_1.isDisposable(disposable)) {
                disposable.dispose();
            }
            delete disposables[id];
        }
    };
    return Scope;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Scope;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

exports.strings = { "fileSizeTB": "{0} TB", "fileSizeGB": "{0} GB", "fileSizeMB": "{0} MB", "fileSizeKB": "{0} KB", "fileSizeBytesPlural": "{0} bytes", "fileSizeBytesSingular": "1 byte" };


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var HslColor_1 = __webpack_require__(152);
var RgbaColor_1 = __webpack_require__(24);
var Shades_1 = __webpack_require__(258);
/**
 * Utility class with static methods to work with Fabric-style themes.
 */
var FabricTheming = (function () {
    function FabricTheming() {
    }
    /**
     * Generates a palette of Fabric colors from a primary RGB color value.
     * @param {RgbaColor} primaryRgb Primary RGB color used to generate a palette.
     * @param {boolean} inverted Whether the theme is inverted, with a dark background and light foreground.
     */
    FabricTheming.generateFabricColors = function (primaryRgb, inverted) {
        if (inverted === void 0) { inverted = false; }
        var generatedShades = {
            "themeDarker": Shades_1.Shades.Darkest,
            "themeDark": Shades_1.Shades.Darker,
            "themeDarkAlt": Shades_1.Shades.Darker,
            "themeLight": Shades_1.Shades.Lighter,
            "themeLightAlt": Shades_1.Shades.Lighter,
            "themeLighter": Shades_1.Shades.Lightest,
            "themeLighterAlt": Shades_1.Shades.Lightest,
            "themePrimary": Shades_1.Shades.Unshaded,
            "themeAccent": Shades_1.Shades.Unshaded,
            "themeSecondary": Shades_1.Shades.Medium,
            "themeTertiary": Shades_1.Shades.Lighter,
            "themeTertiaryAlt": Shades_1.Shades.Lighter
        };
        // Expected color slots. Start each defaulting to null to avoid warnings about missing slots.
        var colors = FabricTheming._getDefaultThemeTokenMap();
        // Starting points for the generated palette.
        var primaryColor = RgbaColor_1.default.fromRgba(primaryRgb.R, primaryRgb.G, primaryRgb.B);
        for (var shadeName in generatedShades) {
            var shade = generatedShades[shadeName];
            if (inverted && shade !== Shades_1.Shades.Unshaded) {
                shade = Shades_1.Shades.Darkest + Shades_1.Shades.Lightest - shade;
            }
            colors[shadeName] = Shades_1.getShade(primaryColor, shade);
        }
        var accent = colors["themeAccent"];
        colors["themeAccentTranslucent10"] = accent ?
            RgbaColor_1.default.fromRgba(accent.R, accent.G, accent.B, 0.1 * RgbaColor_1.default.maxComponent) : null;
        // Handle neutral slots for inverted themes
        if (inverted) {
            var invertedText = '#f8f8f8'; // neutralLighterAlt
            var invertedNeutralQuaternary = '#6b6b6b';
            var invertedNeutralQuaternaryAlt = '#707070';
            var invertedNeutralColors = {
                'black': '#fff',
                'blackTranslucent40': '#66ffffff',
                'neutralDark': '#fff',
                'neutralPrimary': invertedText,
                'neutralPrimaryTranslucent50': '#7ff8f8f8',
                'neutralPrimaryAlt': '#f4f4f4',
                'neutralSecondary': '#eaeaea',
                'neutralSecondaryAlt': '#c8c8c8',
                'neutralTertiary': '#a6a6a6',
                'neutralTertiaryAlt': '#767676',
                'neutralQuaternary': invertedNeutralQuaternary,
                'neutralQuaternaryAlt': invertedNeutralQuaternaryAlt,
                'cmdbarSelected': invertedNeutralQuaternary,
                'cmdbarSelectedHover': invertedNeutralQuaternaryAlt,
                'neutralLight': '#666666',
                'neutralLighter': '#333',
                'neutralLighterAlt': '#212121',
                'primaryText': invertedText,
                'primaryBackground': '#000',
                'white': '#000',
                'whiteTranslucent40': '#66000000',
                'error': '#f00',
                'errorBackground': '#7e3333'
            };
            for (var neutralSlot in invertedNeutralColors) {
                if (invertedNeutralColors.hasOwnProperty(neutralSlot)) {
                    colors[neutralSlot] =
                        RgbaColor_1.default.fromHtmlColor(invertedNeutralColors[neutralSlot]);
                }
            }
        }
        return colors;
    };
    /**
     * Applies an Hsl delta to an HslColor to produce a new HslColor.
     * @param {HslColor} primaryHsl Starting HSL color value.
     * @param {number} hDelta Delta to apply to the hue.
     * @param {number} sDelta Delta to apply to the saturation.
     * @param {number} lDelta Delta to apply to the luminance.
     */
    FabricTheming.applyHslDelta = function (primaryHsl, hDelta, sDelta, lDelta) {
        var hue = primaryHsl.hue - hDelta;
        if (hue > 1 || hue < 0) {
            hue = hue - Math.floor(hue);
        }
        var sat = primaryHsl.sat - sDelta;
        if (sat > 1) {
            sat = 1;
        }
        else if (sat < 0) {
            sat = 0;
        }
        var lum = primaryHsl.lum - lDelta;
        if (lum > 1) {
            lum = 1;
        }
        else if (lum < 0) {
            lum = 0;
        }
        var hslValue = new HslColor_1.default(hue, sat, lum);
        return hslValue;
    };
    FabricTheming._getDefaultThemeTokenMap = function () {
        return {
            backgroundOverlay: null,
            primaryBackground: null,
            primaryText: null,
            themeDarker: null,
            themeDark: null,
            themeDarkAlt: null,
            themePrimary: null,
            themeSecondary: null,
            themeTertiary: null,
            themeLight: null,
            themeLighter: null,
            themeLighterAlt: null,
            black: null,
            cmdbarSelected: null,
            cmdbarSelectedHover: null,
            neutralDark: null,
            neutralPrimary: null,
            neutralPrimaryAlt: null,
            neutralPrimaryTranslucent50: null,
            neutralSecondary: null,
            neutralSecondaryAlt: null,
            neutralTertiary: null,
            neutralTertiaryAlt: null,
            neutralQuaternary: null,
            neutralQuaternaryAlt: null,
            neutralLight: null,
            neutralLighter: null,
            neutralLighterAlt: null,
            white: null,
            blackTranslucent40: null,
            whiteTranslucent40: null,
            yellow: null,
            yellowLight: null,
            orange: null,
            orangeLight: null,
            redDark: null,
            red: null,
            magentaDark: null,
            magenta: null,
            magentaLight: null,
            purpleDark: null,
            purple: null,
            purpleLight: null,
            blueDark: null,
            blueMid: null,
            blue: null,
            blueLight: null,
            tealDark: null,
            teal: null,
            tealLight: null,
            greenDark: null,
            green: null,
            greenLight: null,
            error: null,
            errorBackground: null,
            success: null,
            successBackground: null,
            alert: null,
            alertBackground: null,
            infoBackground: null,
            info: null,
            orangeLighter: null
        };
    };
    return FabricTheming;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = FabricTheming;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RgbaColor_1 = __webpack_require__(24);
/**
 * A color represented by hue, saturation, luminance, and alpha (opacity) components.
 */
var HslColor = (function () {
    /**
     * Constructs a new HSL color object.
     * @param {number} h The hue (between 0 and 1) of the color.
     * @param {number} s The saturation (between 0 and 1) of the color.
     * @param {number} l The luminance (between 0 and 1) of the color.
     * @param {number} a The opacity (between 0 and 255) of the color.
     */
    function HslColor(h, s, l, a) {
        function LimitNumberToUnitInterval(value) {
            return Math.min(1.0, Math.max(0.0, value));
        }
        this.hue = LimitNumberToUnitInterval(h);
        this.sat = LimitNumberToUnitInterval(s);
        this.lum = LimitNumberToUnitInterval(l);
        this.alpha = a == null ? RgbaColor_1.default.maxComponent : a;
    }
    /**
     * Constructs an HslColor from an RgbaColor.
     * @param {RgbaColor} color The color to convert to HSL.
     */
    HslColor.fromRgba = function (color) {
        // Using integer values as much as possible to make comparisons easier.
        // I will indicate non-integer values with a  "_float" suffix.
        // These integer values are each some integer multiple of the true value.
        var scaleFactor = RgbaColor_1.default.maxComponent;
        var h_float = 0.0;
        var s_float = 0.0;
        var l_float = 0.0;
        var r = color.R;
        var g = color.G;
        var b = color.B;
        var cMax = Math.max(Math.max(r, g), b);
        var cMin = Math.min(Math.min(r, g), b);
        var twiceL = cMax + cMin;
        l_float = twiceL / (2 * scaleFactor);
        if (cMax === cMin) {
            s_float = 0.0;
            h_float = -1.0;
        }
        else {
            var dmax = cMax - cMin;
            var pmax = cMax + cMin;
            // The scale factor cancels when we divide scaled values, so divisions can ignore it.
            if (twiceL <= 1 * scaleFactor) {
                s_float = dmax / pmax;
            }
            else {
                s_float = dmax / (2 * scaleFactor - pmax); // Safe, since cMax != cMin
            }
            var dr_float = (cMax - r) * (1 / 6) / dmax;
            var dg_float = (cMax - g) * (1 / 6) / dmax;
            var db_float = (cMax - b) * (1 / 6) / dmax;
            if (r === cMax) {
                h_float = db_float - dg_float;
            }
            else if (g === cMax) {
                h_float = (1 / 3) + dr_float - db_float;
            }
            else {
                h_float = (2 / 3) + dg_float - dr_float;
            }
            if (h_float < 0) {
                h_float += 1.0;
            }
            if (h_float > 1.0) {
                h_float -= 1.0;
            }
        }
        return new HslColor(h_float, s_float, l_float, color.A);
    };
    /**
     * Converts a hue, saturation, or luminance value between 0 and 1 into
     * an integer between 0 and 255.
     */
    HslColor._hslComponentToByte = function (value) {
        var c_rgbaMax = RgbaColor_1.default.maxComponent;
        var result = Math.round(c_rgbaMax * value);
        return Math.min(c_rgbaMax, Math.max(0, result));
    };
    /**
     * Internal method which given the calculated magic numbers and the hue,
     * will calculate the appropriate RGB number.
     * This algorithm is intended to stay in-sync with the equivalent code in
     * mso\officespace\fscolorgallery.cpp.
     * @param {number} m1 The first magic number.
     * @param {number} m2 The second magic number.
     * @param {number} hue The hue to be converted using the magic numbers.
     */
    HslColor._hueToRgbComponent = function (m1, m2, hue) {
        var result;
        if (hue < 0) {
            hue += 1;
        }
        if (hue > 1) {
            hue -= 1;
        }
        if (hue < 1 / 6) {
            result = m1 + (m2 - m1) * hue * 6;
        }
        else if (hue < 1 / 2) {
            result = m2;
        }
        else if (hue < 2 / 3) {
            result = m1 + (m2 - m1) * (2 / 3 - hue) * 6;
        }
        else {
            result = m1;
        }
        return HslColor._hslComponentToByte(result);
    };
    /**
     * Darkens the color by the provided factor.
     * @param {number} factor The factor (between 0 and 1) by which to scale the luminance.
     */
    HslColor.prototype.darken = function (factor) {
        // TODO: Validate input.
        this.lum *= factor;
    };
    /**
     * Lightens the color by the provided factor.
     * @param {number} factor The factor (between 0 and 1) by which to scale the luminance.
     */
    HslColor.prototype.lighten = function (factor) {
        // TODO: Validate input.
        this.lum = this.lum * factor + (1 - factor);
    };
    /**
     * Returns an RgbaColor representation of this HslColor.
     */
    HslColor.prototype.toRgbaColor = function () {
        var r;
        var g;
        var b;
        var hue = this.hue;
        var saturation = this.sat;
        var luminance = this.lum;
        if (Math.round(saturation * RgbaColor_1.default.maxComponent) === 0) {
            r = g = b = HslColor._hslComponentToByte(luminance);
        }
        else {
            var m1;
            var m2;
            if (luminance <= 0.5) {
                m2 = luminance * (1 + saturation);
            }
            else {
                m2 = luminance + saturation - (luminance * saturation);
            }
            m1 = 2 * luminance - m2;
            r = HslColor._hueToRgbComponent(m1, m2, hue + (1 / 3));
            g = HslColor._hueToRgbComponent(m1, m2, hue);
            b = HslColor._hueToRgbComponent(m1, m2, hue - (1 / 3));
        }
        return RgbaColor_1.default.fromRgba(r, g, b, this.alpha);
    };
    return HslColor;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HslColor;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var BaseDataStore_1 = __webpack_require__(55);
var DataStoreCachingType_1 = __webpack_require__(35);
var THEME_CACHE_VERSION = '1.7';
var THEME_CACHE_PREFIX = 'odTheme';
var DATA_KEY = 'Data';
var TOKEN_KEY = 'CacheToken';
var VERSION_KEY = 'CacheVersion';
/**
 * Utility methods for caching theme data.
 */
var ThemeCache = (function () {
    function ThemeCache() {
    }
    /**
     * Clears the theme cache.
     */
    ThemeCache.clearThemeCache = function () {
        "use strict";
        var ds = ThemeCache.getThemeDataStore();
        ds.remove(DATA_KEY);
        ds.remove(TOKEN_KEY);
        ds.remove(VERSION_KEY);
    };
    /**
     * Reads the cached theme, if the cacheToken is compatible.
     * @param {string} cacheToken The cached value will only be returned if it has the same cache token.
     */
    ThemeCache.getCachedTheme = function (cacheToken) {
        "use strict";
        var cachedTheme;
        var ds = ThemeCache.getThemeDataStore();
        try {
            // Make sure the data was cached with the expected version and
            // the current theme cache token. Otherwise, return undefined.
            if (cacheToken === ds.getValue(TOKEN_KEY) &&
                THEME_CACHE_VERSION === ds.getValue(VERSION_KEY)) {
                cachedTheme = ds.getValue(DATA_KEY);
            }
        }
        catch (exReadCache) {
        }
        return cachedTheme;
    };
    /**
     * Updates the theme data in the cache.
     * @param {IThemeData} themeData The new theme data to cache.
     */
    ThemeCache.updateThemeCache = function (themeData, cacheToken) {
        "use strict";
        var ds = ThemeCache.getThemeDataStore();
        ds.setValue(DATA_KEY, themeData);
        ds.setValue(TOKEN_KEY, cacheToken || themeData.cacheToken);
        ds.setValue(VERSION_KEY, THEME_CACHE_VERSION);
    };
    /**
     * Returns an instance of the supporting data store for this cache.
     */
    ThemeCache.getThemeDataStore = function () {
        "use strict";
        return new BaseDataStore_1.default(THEME_CACHE_PREFIX, DataStoreCachingType_1.default.local);
    };
    return ThemeCache;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ThemeCache;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ObjectUtil_1 = __webpack_require__(17);
var StringHelper_1 = __webpack_require__(23);
var UriPartial;
(function (UriPartial) {
    /** The scheme segment of the URI */
    UriPartial[UriPartial["scheme"] = 0] = "scheme";
    /** The scheme and authority segments of the URI */
    UriPartial[UriPartial["authority"] = 1] = "authority";
    /** The scheme, authority, and path segments of the URI */
    UriPartial[UriPartial["path"] = 2] = "path";
    /** The scheme, authority, path, and query segments of the URI */
    UriPartial[UriPartial["query"] = 3] = "query";
})(UriPartial = exports.UriPartial || (exports.UriPartial = {}));
var DELIMITERS = /[;\/?:@&=$,]/;
var AUTHORITY_TERMINATORS = /[\/?]/;
function queryToLower(queryObj) {
    var newQuery = {};
    for (var key in queryObj) {
        if (queryObj.hasOwnProperty(key)) {
            newQuery[key.toLowerCase()] = queryObj[key].toLowerCase();
        }
    }
    return newQuery;
}
/**
 * Partial port of groove\Misc\URI.cpp, which was based on RFC2396 and RFC3986 (http://www.ietf.org/rfc/rfc2396.txt).
 * There are a few differences between this implementation and the RFC:
 *  - Implementation does not support parameters (we don't use them, and partial implementation was incorrect)
 *  - Implementation supports some relative URIs at a glance but more investigation required
 *
 *   foo://example.com:8042/over/there?name=ferret#nose
 *   \_/   \______________/\_________/ \_________/ \__/
 *    |           |            |            |        |
 * scheme     authority       path        query   fragment
 *
 * Possible improvements:
 *  - Support path parameters
 *  - Fully support and test relative URLs based on RFC
 *  - Allow changing/removing remaining URI components (i.e. user, host, port, parameters)
 *  - URI.equals could allow ?foo=1&bar=2 equals ?bar=2&foo=1
 *  - URI.parseURI should have better error handling rather than just setting it as path
 *  - URI.getQueryAsObject should have better error handling for query of "a=1&a=2"
 */
var Uri = (function () {
    function Uri(uriString, options) {
        // All of these are decoded (if relevant) unless specified as encoded.
        this._scheme = "";
        this._user = "";
        this._host = "";
        this._port = "";
        this._path = "";
        this._pathSegments = [];
        this._pathEncoded = "";
        this._query = {};
        this._fragment = "";
        if (options) {
            this._queryCaseInsensitive = !!options.queryCaseInsensitive;
            this._pathCaseInsensitive = !!options.pathCaseInsensitive;
        }
        this._parseURI(uriString);
    }
    Uri.concatenate = function () {
        var uriParts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            uriParts[_i] = arguments[_i];
        }
        var result = '';
        for (var i = 0; i < uriParts.length; i++) {
            var part = uriParts[i];
            if (i > 0) {
                part = Uri.ensureNoPrecedingSlash(part);
            }
            if (i < uriParts.length - 1) {
                part = Uri.ensureTrailingSlash(part);
            }
            result += part;
        }
        return result;
    };
    Uri.ensureNoPrecedingSlash = function (part) {
        return part[0] === "/" ? part.substr(1) : part;
    };
    Uri.ensureTrailingSlash = function (part) {
        return part[part.length - 1] !== "/" ? (part + "/") : part;
    };
    Uri.prototype.getScheme = function () {
        return this._scheme;
    };
    Uri.prototype.setScheme = function (scheme) {
        this._scheme = scheme;
    };
    Uri.prototype.getAuthority = function () {
        return this._getAuthority(false);
    };
    Uri.prototype.setAuthority = function (authority) {
        this._parseAuthority(authority);
    };
    Uri.prototype.getUser = function () {
        return this._user;
    };
    Uri.prototype.getHost = function () {
        return this._host;
    };
    Uri.prototype.getPort = function () {
        return this._port;
    };
    Uri.prototype.getPath = function (trimTrailingSlash) {
        var retPath = this._path;
        if (Boolean(trimTrailingSlash)) {
            // If the last character is a slash
            if (retPath !== null && retPath.lastIndexOf("/") === (retPath.length - 1)) {
                retPath = retPath.slice(0, -1); //trim last character
            }
        }
        return retPath;
    };
    /**
     * Returns a string containing the leftmost portion of the URI string, ending with the portion specified by part
     */
    Uri.prototype.getLeftPart = function (part) {
        var ret = this._scheme + "://"; // default value is UriPartial.scheme
        if (part === UriPartial.authority) {
            ret += this.getAuthority();
        }
        if (part === UriPartial.path) {
            ret += this.getPath();
        }
        if (part === UriPartial.query) {
            ret += this.getQuery();
        }
        return ret;
    };
    Uri.prototype.setPath = function (path) {
        if (path && path[0] !== "/") {
            path = "/" + path;
        }
        this._parsePath(path);
    };
    Uri.prototype.getPathSegments = function () {
        return this._pathSegments;
    };
    Uri.prototype.getLastPathSegment = function () {
        var pathSegments = this._pathSegments;
        return pathSegments[pathSegments.length - 1] || "";
    };
    Uri.prototype.getQuery = function (encoded) {
        return this._serializeQuery(encoded);
    };
    /**
     * Query is not well-defined but is commonly formatted as key=value and delimited with & or ;
     * (http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.2)
     *  - URI with query "a=1&b=2" or "a=1;b=2" will return {a: "1", b: "2"}
     *  - Mixed-mode will also work: "a=1&b=2;c=3" will return {a: "1", b: "2", c: "3"}
     *  - Assumes that parameters will be unique (i.e. "a=1&a=2" is not allowed and will produce unexpected results)
     */
    Uri.prototype.setQuery = function (query) {
        this.setQueryFromObject(this._deserializeQuery(query));
    };
    Uri.prototype.getQueryAsObject = function () {
        return this._query;
    };
    Uri.prototype.setQueryFromObject = function (queryObj) {
        this._query = {};
        for (var queryKey in queryObj) {
            if (queryObj.hasOwnProperty(queryKey)) {
                this.setQueryParameter(queryKey, queryObj[queryKey]);
            }
        }
    };
    Uri.prototype.getQueryParameter = function (queryKey) {
        var ret = null;
        var query = this._query;
        if (this._queryCaseInsensitive) {
            queryKey = queryKey.toLowerCase();
            for (var key in query) {
                if (query.hasOwnProperty(key) && key.toLowerCase() === queryKey) {
                    ret = query[key];
                }
            }
        }
        else {
            ret = query[queryKey];
        }
        return ret || null;
    };
    /**
     * Adds query parameter to the end if queryKey does not exist, or
     * overwrites existing query value if queryKey already exists.
     */
    Uri.prototype.setQueryParameter = function (queryKey, queryValue, ignoreEmptyValues) {
        if (ignoreEmptyValues === void 0) { ignoreEmptyValues = true; }
        var queryValueDecoded = this._decodeQueryString(queryValue);
        // there is no point adding undefined or modifying existing values to undefined or null.
        if (!!queryValueDecoded || ignoreEmptyValues) {
            this._query[this._decodeQueryString(queryKey)] = queryValueDecoded;
        }
    };
    Uri.prototype.removeQueryParameter = function (queryKey) {
        delete this._query[this._decodeQueryString(queryKey)];
    };
    Uri.prototype.getFragment = function () {
        return this._fragment;
    };
    Uri.prototype.setFragment = function (fragment) {
        if (fragment[0] === "#") {
            fragment = fragment.substring(1);
        }
        // Treat the fragment as a query string (decode + as space) because we pass in
        // query parameters using the fragment on page load.
        this._fragment = this._decodeQueryString(fragment);
    };
    /**
     * Does a strict equality check of URIs (including same query parameters
     * in the same order, and most comparisons case-sensitive).
     * According to RFC3986: scheme and host should be case-insensitive.
     * Note: This does not follow RFC2616's URI Comparison since it is not HTTP-specific.
     *
     * KNOWN ISSUE: Depending on your definition of "incorrect," this could return
     * incorrect results for URI parts that get decoded.
     * For example: http://somewhere/my%2fpath and http://somewhere/my/path
     * will compare as equal because the comparisons are done to decoded versions.
     */
    Uri.prototype.equals = function (uri) {
        return StringHelper_1.equalsCaseInsensitive(this._scheme, uri.getScheme()) &&
            this._user === uri.getUser() &&
            StringHelper_1.equalsCaseInsensitive(this._host, uri.getHost()) &&
            this._port === uri.getPort() &&
            this._fragment === uri.getFragment() &&
            this._equalsCaseAppropriate(this.getPath(/*trimTrailingSlash*/ true), uri.getPath(true), this._pathCaseInsensitive) &&
            this._equalsCaseAppropriate(this.getQuery(), uri.getQuery(), this._queryCaseInsensitive);
    };
    /**
     * Does an equivalence check of two URIs. Checks to see if the URIs are
     * equivalent, but they may not be exact! Strings are compared case
     * insensitive and query parameters can be in any order.
     *
     * KNOWN ISSUE: Depending on your definition of "incorrect," this could return
     * incorrect results for URI parts that get decoded.
     * For example: http://somewhere/my%2fpath and http://somewhere/my/path
     * will compare as equal because the comparisons are done to decoded versions.
     */
    Uri.prototype.equivalent = function (uri) {
        return StringHelper_1.equalsCaseInsensitive(this._scheme, uri.getScheme()) &&
            StringHelper_1.equalsCaseInsensitive(this._user, uri.getUser()) &&
            StringHelper_1.equalsCaseInsensitive(this._host, uri.getHost()) &&
            StringHelper_1.equalsCaseInsensitive(this._port, uri.getPort()) &&
            StringHelper_1.equalsCaseInsensitive(this.getPath(/*trimTrailingSlash*/ true), uri.getPath(true)) &&
            ObjectUtil_1.deepCompare(queryToLower(this.getQueryAsObject()), queryToLower(uri.getQueryAsObject())) &&
            StringHelper_1.equalsCaseInsensitive(this._fragment, uri.getFragment());
    };
    /**
     * Note that this returns the URL encoded/escaped while the getXXX() methods
     * for the individual components return the unescaped strings. Returning a
     * concatenation of the decoded components would change the semantics of the
     * URL. See section 2.4.2 of RFC 2396 (http://www.ietf.org/rfc/rfc2396.txt).
     *
     * Use doNotPercentEncodeHost to indicate that the output should not have a
     * percent-encoded host, such as when passing to the url parameter of
     * XmlHttpRequest.open(). Section 3.2.2 of RFC 2396 only allows alphanumeric
     * characters and hyphen in the host of a URL, so percent-encoded hosts are
     * not allowed. While section 3.2.2 of RFC 3986 does not restrict the host
     * character set anymore, not all browsers can handle a percent-encoded host
     * - DNS lookup fails.  But, they will convert the unencoded Unicode to the
     * IDNA encoding (punycode), so leaving the host as-is in this case is preferred.
     */
    Uri.prototype.toString = function (outputOptions) {
        return this._getStringInternal(/*encoded*/ true, outputOptions);
    };
    /**
     * This method should be used to obtain a string for display purposes only,
     * because as mentioned above, a decoded URL may have different semantics than
     * the encoded version.
     */
    Uri.prototype.getDecodedStringForDisplay = function () {
        return this._getStringInternal(/*encoded*/ false);
    };
    /*
     * Input URI of "foo://user:pass@host.com/alpha/beta/gamma/delta;p;a;r;a;m;s?q=1&u=2&e=3&r=4&y=5#fragment"
     * would return "foo://user:pass@host.com/alpha/beta/gamma/delta;p;a;r;a;m;s";
     */
    Uri.prototype.getStringWithoutQueryAndFragment = function () {
        return this._getStringWithoutQueryAndFragmentInternal(/*encoded=*/ true);
    };
    Uri.prototype._equalsCaseAppropriate = function (a, b, isCaseInsensitive) {
        if (isCaseInsensitive) {
            return StringHelper_1.equalsCaseInsensitive(a, b);
        }
        return a === b;
    };
    Uri.prototype._getStringInternal = function (encoded, outputOptions) {
        var ret = this._getStringWithoutQueryAndFragmentInternal(encoded, outputOptions);
        var query = this.getQuery(encoded);
        if (query) {
            ret += "?" + query;
        }
        if (this._fragment) {
            ret += "#" + (encoded ? encodeURIComponent(this._fragment) : this._fragment);
        }
        return ret;
    };
    Uri.prototype._getStringWithoutQueryAndFragmentInternal = function (encoded, outputOptions) {
        var ret = "";
        if (this._scheme) {
            ret += (encoded ? encodeURIComponent(this._scheme) : this._scheme) + ":";
        }
        // Authority includes user, host, and port
        var authority = this._getAuthority(/*encoded=*/ encoded, outputOptions);
        if (authority) {
            ret += "//" + authority;
        }
        if (this._pathEncoded) {
            ret += (encoded ? this._pathEncoded : this._path);
        }
        return ret;
    };
    Uri.prototype._deserializeQuery = function (queryStr) {
        var queryObj = {};
        if (queryStr.indexOf("?") === 0) {
            queryStr = queryStr.substring(1);
        }
        for (var _i = 0, _a = queryStr.split(/[;&]+/); _i < _a.length; _i++) {
            var queryPart = _a[_i];
            var keyEndIndex = queryPart.indexOf('=');
            // "foo" is a legal query string equivalent to "foo="
            if (keyEndIndex < 0) {
                keyEndIndex = queryPart.length;
            }
            if (keyEndIndex > 0) {
                queryObj[queryPart.substr(0, keyEndIndex)] = queryPart.substr(keyEndIndex + 1);
            }
        }
        return queryObj;
    };
    Uri.prototype._serializeQuery = function (encoded) {
        var queryStr = "";
        for (var queryKey in this._query) {
            if (this._query.hasOwnProperty(queryKey)) {
                var key = queryKey;
                var value = this._query[queryKey];
                if (encoded) {
                    key = encodeURIComponent(key);
                    value = encodeURIComponent(value);
                }
                if (value === null || value === "") {
                    queryStr += key + "=&";
                }
                else {
                    queryStr += key + "=" + value + "&";
                }
            }
        }
        if (queryStr !== "") {
            queryStr = queryStr.slice(0, -1); //trim extra & at the end
        }
        return queryStr;
    };
    Uri.prototype._parseURI = function (uriString) {
        var remainingString = uriString;
        // Find fragment
        var fragmentBeginPos = remainingString.indexOf("#");
        if (fragmentBeginPos >= 0) {
            var fragment = remainingString.substring(fragmentBeginPos + 1);
            this.setFragment(fragment);
            remainingString = remainingString.substring(0, fragmentBeginPos); //remove fragment
        }
        // Find scheme
        var schemeEndPos = remainingString.search(DELIMITERS);
        if (schemeEndPos >= 0) {
            if (remainingString[schemeEndPos] === ":") {
                this.setScheme(remainingString.substring(0, schemeEndPos));
                remainingString = remainingString.substring(schemeEndPos + 1); //remove scheme
            }
        }
        else {
            this.setPath(remainingString);
            return;
        }
        // Find authority
        var authority = "";
        var doubleSlashPos = remainingString.indexOf("//");
        if (doubleSlashPos === 0) {
            remainingString = remainingString.substring(2); //skip the //
            var authorityEndPos = remainingString.search(AUTHORITY_TERMINATORS);
            if (authorityEndPos >= 0) {
                authority = remainingString.substring(0, authorityEndPos);
                remainingString = remainingString.substring(authorityEndPos); //remove authority
            }
            else {
                authority = remainingString;
                remainingString = "";
            }
            this.setAuthority(authority);
            if (!remainingString) {
                this.setPath("");
                return;
            }
        }
        // Find query
        var queryBeginPos = remainingString.indexOf("?");
        if (queryBeginPos >= 0) {
            this.setQuery(remainingString.substring(queryBeginPos + 1));
            remainingString = remainingString.substring(0, queryBeginPos);
        }
        this.setPath(remainingString);
    };
    Uri.prototype._parseAuthority = function (authority) {
        this._host = authority;
        var userNameEndPos = authority.lastIndexOf("@");
        if (userNameEndPos >= 0) {
            this._host = this._host.substring(userNameEndPos + 1);
        }
        var hostPortSeparatorPos = this._host.indexOf(":");
        if (userNameEndPos < 0 && hostPortSeparatorPos < 0) {
            return;
        }
        var authorityComponents = authority;
        if (userNameEndPos < 0) {
            this._host = authorityComponents;
        }
        else {
            this._user = authorityComponents.substring(0, userNameEndPos);
            this._host = authorityComponents.substring(userNameEndPos + 1);
        }
        if (hostPortSeparatorPos >= 0) {
            this._port = this._host.substring(hostPortSeparatorPos + 1);
            this._host = this._host.substring(0, hostPortSeparatorPos);
        }
        this._user = decodeURIComponent(this._user);
        this._host = decodeURIComponent(this._host);
    };
    Uri.prototype._parsePath = function (remainingString) {
        this._path = decodeURIComponent(remainingString);
        var pathSegments = this._pathSegments = [];
        this._pathEncoded = remainingString;
        // We have to split the path BEFORE decoding so that encoded / characters
        // don't get interpreted as path separators.
        var encodedPathSegments = remainingString.split("/");
        for (var i = 0; i < encodedPathSegments.length; ++i) {
            pathSegments[i] = decodeURIComponent(encodedPathSegments[i]);
        }
        // Trims first/last element if empty
        if (pathSegments[0] === "") {
            pathSegments.shift(); // remove first element
        }
        if (pathSegments[pathSegments.length - 1] === "") {
            pathSegments.pop(); // remove last element
        }
    };
    Uri.prototype._getAuthority = function (encoded, outputOptions) {
        if (outputOptions === void 0) { outputOptions = {}; }
        // Note that if encoded is false, doNotPercentEncodeHost doesn't matter - the whole URI (including host) will not be encoded.
        var doNotPercentEncodeHost = outputOptions && outputOptions.doNotPercentEncodeHost;
        var authority = "";
        var user;
        var host;
        var port;
        if (encoded) {
            // While technically a reserved character, ':' is commonly used in the
            // username to denote username:password, so we special case not encoding
            // the first occurence of this character.
            user = encodeURIComponent(this._user).replace("%3A", ":");
            if (doNotPercentEncodeHost) {
                host = this._host;
            }
            else {
                host = encodeURIComponent(this._host);
            }
            port = encodeURIComponent(this._port);
        }
        else {
            user = this._user;
            host = this._host;
            port = this._port;
        }
        if (user !== "") {
            authority = user + "@";
        }
        if (this._host !== "") {
            authority += host;
        }
        if (this._port !== "") {
            authority += ":" + port;
        }
        return authority;
    };
    Uri.prototype._decodeQueryString = function (component) {
        // For query strings only, "+" is a valid substitute for a space, but decodeURIComponent
        // doesn't take this into account. (Note that replace("+", " ") only replaces one +.)
        var result = component;
        try {
            result = decodeURIComponent(component.replace(/\+/g, " "));
        }
        catch (e) {
        }
        return result;
    };
    return Uri;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Uri;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(97);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),
/* 158 */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(170),
    isArguments = __webpack_require__(46),
    isArray = __webpack_require__(3),
    isIndex = __webpack_require__(68);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(45);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(165),
    createBaseEach = __webpack_require__(318);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(319);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(164),
    keys = __webpack_require__(11);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1),
    isPrototype = __webpack_require__(41),
    nativeKeysIn = __webpack_require__(356);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(59),
    castPath = __webpack_require__(100),
    isIndex = __webpack_require__(68),
    isKey = __webpack_require__(40),
    isObject = __webpack_require__(1),
    toKey = __webpack_require__(44);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 171 */
/***/ (function(module, exports) {

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(92),
    arraySome = __webpack_require__(272);

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(104);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(104),
    stubArray = __webpack_require__(408);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

module.exports = getSymbols;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(100),
    isArguments = __webpack_require__(46),
    isArray = __webpack_require__(3),
    isIndex = __webpack_require__(68),
    isKey = __webpack_require__(40),
    isLength = __webpack_require__(106),
    toKey = __webpack_require__(44);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(104);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(173);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(110)(module)))

/***/ }),
/* 181 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1),
    now = __webpack_require__(401),
    toNumber = __webpack_require__(109);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(96);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(10),
    stubFalse = __webpack_require__(409);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(110)(module)))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototype = __webpack_require__(174),
    isHostObject = __webpack_require__(67),
    isObjectLike = __webpack_require__(19);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(109);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultEngagementHandler_1 = __webpack_require__(437);
var EngagementLogger = (function () {
    function EngagementLogger() {
    }
    EngagementLogger._initialize = function (logger) {
        EngagementLogger._logger = logger;
    };
    EngagementLogger.logEvent = function (tagName, actionName) {
        if (!tagName || tagName.length === 0) {
            throw new Error('LogEntry is invalid');
        }
        var tagNameRegex = /(\w+)\.(\w+).(\w+)/ig;
        if (tagNameRegex.test(tagName) === false) {
            throw new Error(tagName + " tagName does not follow AppName.ControlName.ActionName pattern");
        }
        if (!actionName || actionName.length === 0) {
            EngagementLogger._logger.logData({ name: tagName });
        }
        else {
            EngagementLogger._logger.logData({
                name: tagName,
                extraData: {
                    action: actionName
                }
            });
        }
    };
    EngagementLogger.logEventWithLogEntry = function (logEntry) {
        if (!logEntry) {
            throw new Error('LogEntry is invalid');
        }
        EngagementLogger._logger.logData({
            name: logEntry.moduleName + '.' + logEntry.logFeature,
            extraData: logEntry.logProperties
        });
    };
    return EngagementLogger;
}());
EngagementLogger._logger = new DefaultEngagementHandler_1.default();
exports.default = EngagementLogger;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogSource_1 = __webpack_require__(111);
var LogManager_1 = __webpack_require__(203);
var LogEvent = (function () {
    function LogEvent(source, data, level, serviceScope) {
        this._validate(source, data);
        this._timestamp = new Date().getTime();
        this._scope = this._getScope(serviceScope);
        this._source = source.substr(0, this._maxSourceLength);
        this._setData(data);
        this._level = level;
        this._prefix = this._getPrefix();
    }
    LogEvent.log = function (source, data, level, serviceScope) {
        var event = new LogEvent(source, data, level, serviceScope);
        LogManager_1.default.log(event);
        return event;
    };
    LogEvent.prototype.toString = function () {
        var timedPrefix = "[" + this._timestamp + "][" + this._prefix + "]";
        if (this._message) {
            return timedPrefix + " " + this._message;
        }
        else {
            return timedPrefix + " " + this._error.toString();
        }
    };
    Object.defineProperty(LogEvent.prototype, "timestamp", {
        get: function () {
            return this._timestamp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "prefix", {
        get: function () {
            return this._prefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "scope", {
        get: function () {
            return this._scope;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "source", {
        get: function () {
            return this._source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "message", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "error", {
        get: function () {
            return this._error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "_maxSourceLength", {
        get: function () {
            return 30;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "_maxMessageLength", {
        get: function () {
            return 100;
        },
        enumerable: true,
        configurable: true
    });
    LogEvent.prototype._validate = function (source, data) {
        if (!source) {
            throw new Error('source cannot be undefined or null for Logger');
        }
        if (!data) {
            throw new Error('data cannot be undefined or null');
        }
    };
    LogEvent.prototype._setData = function (data) {
        if (typeof data === 'string') {
            this._message = data.substr(0, this._maxMessageLength);
        }
        else if (data instanceof Error) {
            this._error = data;
        }
    };
    LogEvent.prototype._getPrefix = function () {
        var prefix = "" + this._source;
        if (this._scope && !this._scope.isEmpty()) {
            prefix = this._scope.id.substr(0, this._maxSourceLength) + "." + prefix;
        }
        return "" + prefix;
    };
    LogEvent.prototype._getScope = function (serviceScope) {
        var parentSource;
        if (serviceScope) {
            serviceScope.whenFinished(function () {
                parentSource = serviceScope.consume(LogSource_1.logSourceServiceKey);
            });
        }
        return parentSource;
    };
    return LogEvent;
}());
exports.default = LogEvent;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Verbose"] = 1] = "Verbose";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogType;
(function (LogType) {
    LogType[LogType["Trace"] = 1] = "Trace";
    LogType[LogType["Event"] = 2] = "Event";
    LogType[LogType["Error"] = 3] = "Error";
})(LogType || (LogType = {}));
exports.default = LogType;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Text_1 = __webpack_require__(29);
var StringsProxy_1 = __webpack_require__(13);
var Validate_1 = __webpack_require__(14);
var Version = (function () {
    function Version(major, minor, patch, revision) {
        this._major = major;
        this._minor = minor;
        this._patch = patch;
        this._revision = revision;
    }
    Version.isValid = function (versionString) {
        return Version.tryParse(versionString) !== undefined;
    };
    Version.parse = function (versionString) {
        var version = Version.tryParse(versionString);
        if (version) {
            return version;
        }
        throw new Error(Text_1.default.format(StringsProxy_1.default.invalidVersionStringError, versionString));
    };
    Version.tryParse = function (versionString) {
        if (versionString) {
            var versionRegex = /^([0-9]+)\.([0-9]+)(?:\.([0-9]+)(?:\.([0-9]+))?)?$/g;
            var regexExecRes = versionRegex.exec(versionString);
            if (regexExecRes) {
                return new Version(parseInt(regexExecRes[1], 10), parseInt(regexExecRes[2], 10), regexExecRes[3] !== undefined ? parseInt(regexExecRes[3], 10) : undefined, regexExecRes[4] !== undefined ? parseInt(regexExecRes[4], 10) : undefined);
            }
        }
        return undefined;
    };
    Version.compare = function (v1, v2) {
        Validate_1.default.isNotNullOrUndefined(v1, 'v1');
        Validate_1.default.isNotNullOrUndefined(v2, 'v2');
        if (v1.major !== v2.major) {
            return v1.major > v2.major ? 1 : -1;
        }
        if (v1.minor !== v2.minor) {
            return v1.minor > v2.minor ? 1 : -1;
        }
        if ((v1.patch || 0) !== (v2.patch || 0)) {
            return (v1.patch || 0) > (v2.patch || 0) ? 1 : -1;
        }
        if ((v1.revision || 0) !== (v2.revision || 0)) {
            return (v1.revision || 0) > (v2.revision || 0) ? 1 : -1;
        }
        return 0;
    };
    Object.defineProperty(Version.prototype, "major", {
        get: function () {
            return this._major;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "minor", {
        get: function () {
            return this._minor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "patch", {
        get: function () {
            return this._patch;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "revision", {
        get: function () {
            return this._revision;
        },
        enumerable: true,
        configurable: true
    });
    Version.prototype.lessThan = function (compareWith) {
        return Version.compare(this, compareWith) < 0;
    };
    Version.prototype.greaterThan = function (compareWith) {
        return Version.compare(this, compareWith) > 0;
    };
    Version.prototype.equals = function (compareWith) {
        return Version.compare(this, compareWith) === 0;
    };
    Version.prototype.satisfies = function (compareWith) {
        Validate_1.default.isNotNullOrUndefined(compareWith, 'compareWith');
        return this.major === compareWith.major && !this.lessThan(compareWith);
    };
    Version.prototype.toString = function () {
        var str = this.major + "." + this.minor;
        if (this.patch !== undefined) {
            str += "." + this.patch;
            if (this.revision !== undefined) {
                str += "." + this.revision;
            }
        }
        return str;
    };
    return Version;
}());
exports.default = Version;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultLogHandler_1 = __webpack_require__(454);
var Log = (function () {
    function Log() {
    }
    Log._initialize = function (logHandler) {
        Log._logHandler = logHandler;
    };
    Log.verbose = function (source, message, scope) {
        Log._logHandler.verbose(source, message, scope);
    };
    Log.info = function (source, message, scope) {
        Log._logHandler.info(source, message, scope);
    };
    Log.warn = function (source, message, scope) {
        Log._logHandler.warn(source, message, scope);
    };
    Log.error = function (source, error, scope) {
        Log._logHandler.error(source, error, scope);
    };
    return Log;
}());
Log._logHandler = new DefaultLogHandler_1.default();
exports.default = Log;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Polyfill for the URLSearchParams class.
 *
 * MDN documentation: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
 *
 * WhatWG Spec: https://url.spec.whatwg.org/
 */

Object.defineProperty(exports, "__esModule", { value: true });
var URLSearchParams = (function () {
    function URLSearchParams(init) {
        this._initialize(init);
    }
    /**
     * Parser following this spec: https://url.spec.whatwg.org/#concept-urlencoded-parser
     */
    URLSearchParams._getParamterPairsFromString = function (str) {
        var strMatches = str.match(/\??(.*)/);
        if (strMatches) {
            str = strMatches[1];
        }
        else {
            // Unexpected format. Return nothing
            return [];
        }
        return (str.split('&') || []).filter(function (token) { return token; }).map(function (token) {
            var splitIndex = token.indexOf('=');
            var key = '';
            var value = '';
            if (splitIndex === -1) {
                // No "=" -> Empty value
                key = token;
            }
            else if (splitIndex === 0) {
                // "=" is the first character -> empty key
                value = token.substr(1);
            }
            else {
                key = token.substring(0, splitIndex);
                value = token.substr(splitIndex + 1);
            }
            // Replace "+" with space
            key = key.replace(/\+/g, ' ');
            value = value.replace(/\+/g, ' ');
            // Decode the key and value
            key = decodeURIComponent(key);
            value = decodeURIComponent(value);
            return { key: key, value: value };
        });
    };
    URLSearchParams.prototype.append = function (key, value) {
        this._queryParameterList.push({ key: key, value: value });
        this._update();
    };
    URLSearchParams.prototype.delete = function (key) {
        for (var i = 0; i < this._queryParameterList.length; i++) {
            if (this._queryParameterList[i].key === key) {
                this._queryParameterList.splice(i, 1);
                i--;
            }
        }
        this._update();
    };
    URLSearchParams.prototype.get = function (key) {
        for (var i = 0; i < this._queryParameterList.length; i++) {
            if (this._queryParameterList[i].key === key) {
                return this._queryParameterList[i].value;
            }
        }
        return null; // tslint:disable-line:no-null-keyword
    };
    URLSearchParams.prototype.getAll = function (key) {
        var result = [];
        for (var i = 0; i < this._queryParameterList.length; i++) {
            if (this._queryParameterList[i].key === key) {
                result.push(this._queryParameterList[i].value);
            }
        }
        return result;
    };
    URLSearchParams.prototype.has = function (key) {
        for (var i = 0; i < this._queryParameterList.length; i++) {
            if (this._queryParameterList[i].key === key) {
                return true;
            }
        }
        return false; // tslint:disable-line:no-null-keyword
    };
    URLSearchParams.prototype.set = function (key, value) {
        var found = false;
        for (var i = 0; i < this._queryParameterList.length; i++) {
            if (this._queryParameterList[i].key === key) {
                if (found) {
                    // Already found a matching key - remove the rest
                    this._queryParameterList.splice(i, 1);
                    i--;
                }
                else {
                    found = true;
                    this._queryParameterList[i].value = value;
                }
            }
        }
        if (!found) {
            this.append(key, value);
            // No need to call _update() here because append() calls it.
        }
        else {
            this._update();
        }
    };
    URLSearchParams.prototype.sort = function () {
        this._queryParameterList.sort(function (a, b) { return a.key.localeCompare(b.key); });
        this._update();
    };
    URLSearchParams.prototype.toString = function () {
        return this._queryParameterList.map(function (_a) {
            var key = _a.key, value = _a.value;
            return encodeURIComponent(key) + "=" + encodeURIComponent(value);
        }).join('&');
    };
    URLSearchParams.prototype._update = function () {
        if (this._url) {
            this._url.search = this.toString();
        }
    };
    URLSearchParams.prototype._initialize = function (init) {
        this._queryParameterList = [];
        if (Array.isArray(init)) {
            // Array
            for (var _i = 0, init_1 = init; _i < init_1.length; _i++) {
                var element = init_1[_i];
                if (!Array.isArray(element) || element.length !== 2) {
                    // Must be an array of two-element arrays
                    throw new TypeError('All elements in init sequence must have exactly two elements');
                }
                else {
                    this._queryParameterList.push({
                        key: element[0],
                        value: element[1]
                    });
                }
            }
        }
        else if (typeof init === 'object') {
            // Dictionary
            for (var key in init) {
                if (init.hasOwnProperty(key)) {
                    this._queryParameterList.push({
                        key: key,
                        value: init[key]
                    });
                }
            }
        }
        else if (typeof init === 'string') {
            // String
            this._queryParameterList = URLSearchParams._getParamterPairsFromString(init);
        }
        else {
            // do nothing
        }
    };
    return URLSearchParams;
}());
exports.default = URLSearchParams;



/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @copyright Microsoft Corporation. All rights reserved.
// @file This file contains an inventory of all of our framework's polyfills.
// All webpart and application code can rely on these libraries being polyfilled by our framework.

Object.defineProperty(exports, "__esModule", { value: true });
// ES6 Harmony Collections Polyfill
// ES6 Harmony Collections  was added as a polyfill to provide a lightweight unobtrusive shim for
// ES2015 collections. The implementations of Map, Set, and WeakMap provided by this polyfill
// adhere to the ES2015 standard. Functions that abide by the ES2015 standard such as Map.get()
// and Set.has() are guaranteed to run in sublinear time rather than the expected constant time
// for a standard hashmap implementation. (See http://stackoverflow.com/a/31092145) The alternative
// popular library to ES6 Harmony Collections is ES6 shim. After running some samples tests, we have
// determined that ES6 Harmony Collections performs better on a larger set of operations than
// the es6-shim. (Tests were run here: https://jsperf.com/es6-shim-vs-es6-collections/2 ).
// ES6 shim is also a much larger library in size.
// https://github.com/WebReflection/es6-collections
__webpack_require__(263);
// ES6 Promise Polyfill
// Adds an implementation of the ES2015-Promise to the browser. The implementation is a subset
// of rsvp.js.
// (See: https://github.com/tildeio/rsvp.js) ES6 Promise is compliant with Promises/A+
// (See: https://promisesaplus.com/)
// Very useful for using Promise in the Safari/IE/Edge (already supported by Chrome/Firefox)
// https://github.com/jakearchibald/es6-promise
__webpack_require__(264);
// Window.Fetch PolyFill
// Adds an implementation of the Fetch standard to the browser.
// Very useful for using the fetch api in the Safari/IE (already supported by Chrome/Firefox/Edge)
// https://github.com/github/fetch
__webpack_require__(432);
// Fill utility for URL types
var UrlFillHelper = __webpack_require__(461);
UrlFillHelper.fillUrlIfNecessary(function () { return __webpack_require__(460).default; });
UrlFillHelper.fillUrlSearchParamsIfNecessary(function () { return __webpack_require__(196).default; });
// TypeScript 2.0 Typings have location.origin and performance as readonly properties.
// This is a polyfill for window.location.origin, which is not supported by the IE browser
if (!window.location.origin) {
    window.location.origin = window.location.protocol // tslint:disable-line:no-any
        + '//'
        + window.location.hostname
        + (window.location.port ? ':' + window.location.port : '');
}
// IE9 doesn't support performance.now(), so we need to polyfill that
if (!window.performance) {
    window.performance = {}; // tslint:disable-line:no-any
}
if (!window.performance.now) {
    // Polyfill performance.now with a function that returns the number of milliseconds since the module loader loaded.
    // Not as accurate as the real performance.now() function, but as accurate as we're able to get with a polyfill.
    var pageLoadTime_1 = Date.now();
    window.performance.now = function () { return Date.now() - pageLoadTime_1; };
}
// ES6 Collection Polyfill does not provide toString function for Set Object, which may cause false negative when
// checking implementation of Set if other polyfill for Set is bundled.
// Check whether toString() is implemented right, if not, provide toString for Set.
if (new Set().toString() === '[object Object]') {
    window.Set.prototype.toString = function () { return '[object Set]'; }; // tslint:disable-line:no-any
}



/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * An IThemingInstruction can specify a rawString to be preserved or a theme slot and a default value
 * to use if that slot is not specified by the theme.
 */

Object.defineProperty(exports, "__esModule", { value: true });
// IE needs to inject styles using cssText. However, we need to evaluate this lazily, so this
// value will initialize as undefined, and later will be set once on first loadStyles injection.
var _injectStylesWithCssText;
// Store the theming state in __themeState__ global scope for reuse in the case of duplicate
// load-themed-styles hosted on the page.
var _root = (typeof window === 'undefined') ? global : window; // tslint:disable-line:no-any
var _themeState = _root.__themeState__ = _root.__themeState__ || {
    theme: undefined,
    lastStyleElement: undefined,
    registeredStyles: []
};
/**
 * Matches theming tokens. For example, "[theme: themeSlotName, default: #FFF]" (including the quotes).
 */
// tslint:disable-next-line:max-line-length
var _themeTokenRegex = /[\'\"]\[theme:\s*(\w+)\s*(?:\,\s*default:\s*([\\"\']?[\.\,\(\)\#\-\s\w]*[\.\,\(\)\#\-\w][\"\']?))?\s*\][\'\"]/g;
/** Maximum style text length, for supporting IE style restrictions. */
var MAX_STYLE_CONTENT_SIZE = 10000;
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load
 * event is fired.
 * @param {string | ThemableArray} styles Themable style text to register.
 */
function loadStyles(styles) {
    var styleParts = Array.isArray(styles) ? styles : splitStyles(styles);
    if (_injectStylesWithCssText === undefined) {
        _injectStylesWithCssText = shouldUseCssText();
    }
    applyThemableStyles(styleParts);
}
exports.loadStyles = loadStyles;
/**
 * Allows for customizable loadStyles logic. e.g. for server side rendering application
 * @param {(processedStyles: string, rawStyles?: string | ThemableArray) => void}
 * a loadStyles callback that gets called when styles are loaded or reloaded
 */
function configureLoadStyles(loadStyles) {
    _themeState.loadStyles = loadStyles;
}
exports.configureLoadStyles = configureLoadStyles;
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load event
 * is fired.
 * @param {string} styleText Style to register.
 * @param {IStyleRecord} styleRecord Existing style record to re-apply.
 */
function applyThemableStyles(stylesArray, styleRecord) {
    if (_themeState.loadStyles) {
        _themeState.loadStyles(resolveThemableArray(stylesArray), stylesArray);
    }
    else {
        _injectStylesWithCssText ?
            registerStylesIE(stylesArray, styleRecord) :
            registerStyles(stylesArray, styleRecord);
    }
}
/**
 * Registers a set theme tokens to find and replace. If styles were already registered, they will be
 * replaced.
 * @param {theme} theme JSON object of theme tokens to values.
 */
function loadTheme(theme) {
    _themeState.theme = theme;
    // reload styles.
    reloadStyles();
}
exports.loadTheme = loadTheme;
/**
 * Clear already registered style elements and style records in theme_State object
 */
function clearStyles() {
    _themeState.registeredStyles.forEach(function (styleRecord) {
        var styleElement = styleRecord && styleRecord.styleElement;
        if (styleElement && styleElement.parentElement) {
            styleElement.parentElement.removeChild(styleElement);
        }
    });
    _themeState.registeredStyles = [];
}
exports.clearStyles = clearStyles;
/**
 * Reloads styles.
 */
function reloadStyles() {
    if (_themeState.theme) {
        for (var _i = 0, _a = _themeState.registeredStyles; _i < _a.length; _i++) {
            var styleRecord = _a[_i];
            applyThemableStyles(styleRecord.themableStyle, styleRecord);
        }
    }
}
/**
 * Find theme tokens and replaces them with provided theme values.
 * @param {string} styles Tokenized styles to fix.
 */
function detokenize(styles) {
    if (styles) {
        styles = resolveThemableArray(splitStyles(styles));
    }
    return styles;
}
exports.detokenize = detokenize;
/**
 * Resolves ThemingInstruction objects in an array and joins the result into a string.
 * @param {ThemableArray} splitStyleArray ThemableArray to resolve and join.
 */
function resolveThemableArray(splitStyleArray) {
    var theme = _themeState.theme;
    // Resolve the array of theming instructions to an array of strings.
    // Then join the array to produce the final CSS string.
    var resolvedArray = (splitStyleArray || []).map(function (currentValue) {
        var themeSlot = currentValue.theme;
        if (themeSlot) {
            // A theming annotation. Resolve it.
            var themedValue = theme ? theme[themeSlot] : undefined;
            var defaultValue = currentValue.defaultValue || 'inherit';
            // Warn to console if we hit an unthemed value even when themes are provided, unless "DEBUG" is false
            // Allow the themedValue to be undefined to explicitly request the default value.
            if (theme && !themedValue && console && !(themeSlot in theme) && ("boolean" === 'undefined' || true)) {
                console.warn("Theming value not provided for \"" + themeSlot + "\". Falling back to \"" + defaultValue + "\".");
            }
            return themedValue || defaultValue;
        }
        else {
            // A non-themable string. Preserve it.
            return currentValue.rawString;
        }
    });
    return resolvedArray.join('');
}
/**
 * Split tokenized CSS into an array of strings and theme specification objects
 * @param {string} styles Tokenized styles to split.
 */
function splitStyles(styles) {
    var result = [];
    if (styles) {
        var pos = 0; // Current position in styles.
        var tokenMatch = void 0; // tslint:disable-line:no-null-keyword
        while (tokenMatch = _themeTokenRegex.exec(styles)) {
            var matchIndex = tokenMatch.index;
            if (matchIndex > pos) {
                result.push({
                    rawString: styles.substring(pos, matchIndex)
                });
            }
            result.push({
                theme: tokenMatch[1],
                defaultValue: tokenMatch[2] // May be undefined
            });
            // index of the first character after the current match
            pos = _themeTokenRegex.lastIndex;
        }
        // Push the rest of the string after the last match.
        result.push({
            rawString: styles.substring(pos)
        });
    }
    return result;
}
exports.splitStyles = splitStyles;
/**
 * Registers a set of style text. If it is registered too early, we will register it when the
 * window.load event is fired.
 * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
 * @param {IStyleRecord} styleRecord May specify a style Element to update.
 */
function registerStyles(styleArray, styleRecord) {
    var head = document.getElementsByTagName('head')[0];
    var styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    styleElement.appendChild(document.createTextNode(resolveThemableArray(styleArray)));
    if (styleRecord) {
        head.replaceChild(styleElement, styleRecord.styleElement);
        styleRecord.styleElement = styleElement;
    }
    else {
        head.appendChild(styleElement);
    }
    if (!styleRecord) {
        _themeState.registeredStyles.push({
            styleElement: styleElement,
            themableStyle: styleArray
        });
    }
}
/**
 * Registers a set of style text, for IE 9 and below, which has a ~30 style element limit so we need
 * to register slightly differently.
 * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
 * @param {IStyleRecord} styleRecord May specify a style Element to update.
 */
function registerStylesIE(styleArray, styleRecord) {
    var head = document.getElementsByTagName('head')[0];
    var registeredStyles = _themeState.registeredStyles;
    var lastStyleElement = _themeState.lastStyleElement;
    var stylesheet = lastStyleElement ? lastStyleElement.styleSheet : undefined;
    var lastStyleContent = stylesheet ? stylesheet.cssText : '';
    var lastRegisteredStyle = registeredStyles[registeredStyles.length - 1];
    var resolvedStyleText = resolveThemableArray(styleArray);
    if (!lastStyleElement || (lastStyleContent.length + resolvedStyleText.length) > MAX_STYLE_CONTENT_SIZE) {
        lastStyleElement = document.createElement('style');
        lastStyleElement.type = 'text/css';
        if (styleRecord) {
            head.replaceChild(lastStyleElement, styleRecord.styleElement);
            styleRecord.styleElement = lastStyleElement;
        }
        else {
            head.appendChild(lastStyleElement);
        }
        if (!styleRecord) {
            lastRegisteredStyle = {
                styleElement: lastStyleElement,
                themableStyle: styleArray
            };
            registeredStyles.push(lastRegisteredStyle);
        }
    }
    lastStyleElement.styleSheet.cssText += detokenize(resolvedStyleText);
    Array.prototype.push.apply(lastRegisteredStyle.themableStyle, styleArray); // concat in-place
    // Preserve the theme state.
    _themeState.lastStyleElement = lastStyleElement;
}
/**
 * Checks to see if styleSheet exists as a property off of a style element.
 * This will determine if style registration should be done via cssText (<= IE9) or not
 */
function shouldUseCssText() {
    var useCSSText = false;
    if (typeof document !== 'undefined') {
        var emptyStyle = document.createElement('style');
        emptyStyle.type = 'text/css';
        useCSSText = !!emptyStyle.styleSheet;
    }
    return useCSSText;
}


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 199 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var odsp_utilities_bundle_1 = __webpack_require__(20);
var sp_core_library_1 = __webpack_require__(0);
var sp_core_library_2 = __webpack_require__(0);
var LogSource_1 = __webpack_require__(111);
var TraceLogger_1 = __webpack_require__(73);
var PerformanceLogger = (function () {
    function PerformanceLogger() {
    }
    PerformanceLogger.initializeApplication = function (applicationName, fullPageLoad) {
        if (fullPageLoad === void 0) { fullPageLoad = true; }
        if (fullPageLoad === false) {
            if (this.isRunning()) {
                var serverUrl = this._logger.getPerformanceDataPropertyValue('ServerUrl');
                TraceLogger_1.default.logVerbose(this._logSource, "Performance data could not be collected for current page " + serverUrl + " before resetting");
            }
            this._logger.resetLogger();
        }
        this._addEnabledFlights();
        this.fullPageLoad = fullPageLoad;
        this._reset(applicationName);
        this._notifyListeners();
    };
    Object.defineProperty(PerformanceLogger, "fullPageLoad", {
        get: function () {
            var pageTransitionType = this._logger.getPerformanceDataPropertyValue('PageTransitionType');
            if (pageTransitionType !== undefined) {
                return pageTransitionType === odsp_utilities_bundle_1.PageTransitionType.fullPageLoad;
            }
            return true;
        },
        set: function (isFullPageLoad) {
            var pageTransitionType = isFullPageLoad ? odsp_utilities_bundle_1.PageTransitionType.fullPageLoad :
                odsp_utilities_bundle_1.PageTransitionType.none;
            this._logger.writePageTransitionType(pageTransitionType, true);
            this._notifyListeners();
        },
        enumerable: true,
        configurable: true
    });
    PerformanceLogger.addComponent = function (tag) {
        if (!this._shouldRunComponent(tag)) {
            return;
        }
        this._logger.addExpectedControl(tag);
        this._notifyListeners();
    };
    PerformanceLogger.startMarkForComponent = function (tag) {
        if (!this._shouldRunComponent(tag)) {
            return;
        }
        var currentTime = this.now();
        this._logger.saveTempData(tag + this._componentStartTimeKey, currentTime);
        this._logger.addEUPLBreakdown(tag + ".start", currentTime);
        this._notifyListeners();
    };
    PerformanceLogger.endMarkForComponent = function (tag) {
        return PerformanceLogger.endMarkForComponentWithTimestamp(tag, this.now());
    };
    PerformanceLogger.endMarkForComponentWithTimestamp = function (tag, endTime) {
        if (!this._shouldRunComponent(tag)) {
            return;
        }
        if (!this._logger.readTempData(tag + this._componentEndTimeKey)) {
            var controlStartTime = this.getComponentStartTime(tag);
            this.reportControlData(tag, controlStartTime, endTime);
            this._logger.saveTempData(tag + this._componentEndTimeKey, endTime);
            this._markComponentCore(tag, 'end', endTime);
            this._notifyListeners();
        }
    };
    PerformanceLogger.markComponent = function (tag, name) {
        if (!this._shouldRunComponent(tag)) {
            return;
        }
        if (this._markComponentCore(tag, name)) {
            this._notifyListeners();
        }
    };
    PerformanceLogger.markComponentModuleLoaded = function (tag) {
        if (!this._shouldRunComponent(tag)) {
            return;
        }
        var nowTime = this._markComponentCore(tag, 'modulesLoaded');
        if (!nowTime) {
            return;
        }
        if (!this._lastModuleLoadedDuration || nowTime > this._lastModuleLoadedDuration) {
            this._lastModuleLoadedDuration = nowTime;
            this._logger.addEUPLBreakdown('lastModuleLoaded', nowTime, true);
        }
        this._notifyListeners();
    };
    PerformanceLogger.getLastModuleLoadedDuration = function () {
        return this._lastModuleLoadedDuration;
    };
    PerformanceLogger.skipComponent = function (name) {
        this._componentsToSkip.add(name);
    };
    PerformanceLogger.clearComponentsToSkip = function () {
        this._componentsToSkip.clear();
    };
    PerformanceLogger.shouldSkipComponent = function (tag) {
        var shouldSkipTag = false;
        this._componentsToSkip.forEach(function (name) {
            shouldSkipTag = shouldSkipTag || (tag.lastIndexOf(name, 0) === 0);
        });
        return shouldSkipTag;
    };
    PerformanceLogger.startMarkForApi = function (tag) {
        if (!this.isRunning()) {
            return;
        }
        this._logger.saveTempData(tag + this._apiStartTimeKey, this.now());
        this._notifyListeners();
    };
    PerformanceLogger.endMarkForApi = function (tag, name, requestUrl, response) {
        if (!this.isRunning()) {
            return;
        }
        var apiStartTime = this.getApiStartTime(tag);
        var apiEndTime = this.now();
        var apiData = new odsp_utilities_bundle_1.APICallPerformanceData(requestUrl, apiEndTime - apiStartTime, response.headers.get('SPRequestGuid'), response.status, apiStartTime.toString(), apiEndTime.toString(), name);
        this._logger.writeAPICallPerformanceData(apiData);
        this._logger.saveTempData(tag + this._apiEndTimeKey, apiEndTime);
        PerformanceLogger._updateDataFetch(apiStartTime, apiEndTime);
        this._notifyListeners();
    };
    PerformanceLogger.getMaxDataFetchTime = function () {
        return PerformanceLogger._logger.getPerformanceDataPropertyValue('DataFetch');
    };
    PerformanceLogger.markSpLoaderStart = function () {
        this._logger.addEUPLBreakdown(this._spLoaderStartKey, this.now(), true);
    };
    PerformanceLogger.markApplicationStart = function () {
        this._mark(this._applicationStartKey);
        this._logger.addEUPLBreakdown(this._applicationStartKey, this.now(), true);
    };
    PerformanceLogger.getApplicationStartTime = function () {
        return this._getMark(this._applicationStartKey);
    };
    PerformanceLogger.getComponentStartTime = function (tag) {
        return this._logger.readTempData(tag + this._componentStartTimeKey);
    };
    PerformanceLogger.getComponentEndTime = function (tag) {
        return this._logger.readTempData(tag + this._componentEndTimeKey);
    };
    PerformanceLogger.getApiStartTime = function (tag) {
        return this._logger.readTempData(tag + this._apiStartTimeKey);
    };
    PerformanceLogger.getApiEndTime = function (tag) {
        return this._logger.readTempData(tag + this._apiEndTimeKey);
    };
    PerformanceLogger.getPerformanceData = function () {
        this._ensureInitialized();
        return this._rumOneLogger.getPerformanceData();
    };
    PerformanceLogger.addListener = function (onDataCallback) {
        this._listeners.push(onDataCallback);
    };
    PerformanceLogger.removeListener = function (onDataCallback) {
        var index = this._listeners.indexOf(onDataCallback);
        if (index > -1) {
            this._listeners.splice(index, 1);
        }
    };
    PerformanceLogger.now = function () {
        if (this.isDateNowKillSwitchOn) {
            return Date.now();
        }
        var navStartOffset = this._logger.readTempData(this._navigationStartOffsetKey) || 0;
        if (!!performance && performance.now && typeof performance.now === 'function') {
            return (Math.round(performance.now()) - navStartOffset);
        }
        else if (!!performance && performance.timing && performance.timing.navigationStart) {
            return (Date.now() - performance.timing.navigationStart - navStartOffset);
        }
        TraceLogger_1.default.logVerbose(this._logSource, "High resolution performance API not supported");
        return Date.now() - this._logger.readTempData('perfStartTime');
    };
    PerformanceLogger._shouldRunComponent = function (tag) {
        return this.isRunning() && !this.shouldSkipComponent(tag);
    };
    PerformanceLogger._ensureInitialized = function () {
        if (!this._rumOneLogger) {
            this._rumOneLogger = odsp_utilities_bundle_1.RumOneLogger.getRUMOneLogger();
        }
    };
    Object.defineProperty(PerformanceLogger, "_logger", {
        get: function () {
            this._ensureInitialized();
            return this._rumOneLogger;
        },
        enumerable: true,
        configurable: true
    });
    PerformanceLogger.isRunning = function () {
        return this._logger.isRunning();
    };
    PerformanceLogger.reportControlData = function (tag, startTime, endTime) {
        if (!this.isRunning) {
            return;
        }
        var controlPerformanceData = new odsp_utilities_bundle_1.ControlPerformanceData(tag, startTime, endTime, !PerformanceLogger.isDateNowKillSwitchOn
            ? this._computeRenderTime.bind(this)
            : this._legacycomputeRenderTime.bind(this), !PerformanceLogger.isDateNowKillSwitchOn
            ? this._checkRenderTimeRequiredDataAvailable.bind(this)
            : this._legacyRenderTimeAvailable.bind(this));
        this._logger.writeControlPerformanceData(controlPerformanceData);
        this._notifyListeners();
    };
    PerformanceLogger._checkRenderTimeRequiredDataAvailable = function (rumone, controlData) {
        return (rumone && controlData && !isNaN(controlData.endTime));
    };
    PerformanceLogger._legacyRenderTimeAvailable = function (rumone, controlData) {
        if (rumone && controlData) {
            var navigationStart = undefined;
            var pageTransitionType = rumone.getPerformanceDataPropertyValue('PageTransitionType');
            if (pageTransitionType === odsp_utilities_bundle_1.PageTransitionType.fullPageLoad) {
                navigationStart = rumone.getPerformanceDataPropertyValue('W3cNavigationStart');
            }
            else if (pageTransitionType === odsp_utilities_bundle_1.PageTransitionType.none) {
                navigationStart = rumone.readTempData('SPClientNavStartTime');
            }
            return Boolean(navigationStart) && Boolean(controlData.endTime);
        }
        return false;
    };
    PerformanceLogger._computeRenderTime = function (rumone, controlData) {
        if (rumone && controlData && controlData.endTime) {
            var renderTime = controlData.endTime;
            if (!isNaN(renderTime) && renderTime < 0) {
                var error = new Error("Component " + controlData.controlId + " render time " + renderTime + " is negative\n            ( StartTime: " + controlData.startTime + "\n            endTime: " + controlData.endTime + " pageTransitionType: " + this.fullPageLoad.toString() + ")");
                TraceLogger_1.default.logError(this._logSource, error, 'negativeRenderTime');
                return 0;
            }
            return renderTime;
        }
        else {
            return 0;
        }
    };
    PerformanceLogger._legacycomputeRenderTime = function (rumone, controlData) {
        if (rumone && controlData) {
            var navigationStart = undefined;
            var pageTransitionType = rumone.getPerformanceDataPropertyValue('PageTransitionType');
            if (pageTransitionType === odsp_utilities_bundle_1.PageTransitionType.fullPageLoad) {
                navigationStart = rumone.getPerformanceDataPropertyValue('W3cNavigationStart');
            }
            else if (pageTransitionType === odsp_utilities_bundle_1.PageTransitionType.none) {
                navigationStart = rumone.readTempData('SPClientNavStartTime');
            }
            if (navigationStart) {
                var renderTime = controlData.endTime - navigationStart;
                if (renderTime < 0) {
                    var error = new Error("Component " + controlData.controlId + " render time " + renderTime + " is negative\n             (navigationStart: " + navigationStart + " StartTime: " + controlData.startTime + "\n              endTime: " + controlData.endTime + " pageTransitionType: " + pageTransitionType + ")");
                    TraceLogger_1.default.logError(this._logSource, error, 'negativeRenderTime');
                }
                else {
                    return renderTime;
                }
            }
        }
    };
    PerformanceLogger._mark = function (tag) {
        this._logger.mark(tag + this._markKey);
        this._notifyListeners();
    };
    PerformanceLogger._getMark = function (tag) {
        return this._logger.getMarkerTime(tag + this._markKey);
    };
    PerformanceLogger._updateDataFetch = function (startTime, endTime) {
        if (startTime && endTime) {
            var previousDuration = PerformanceLogger.getMaxDataFetchTime();
            var newDuration = endTime - startTime;
            if (!previousDuration || newDuration > previousDuration) {
                this._logger.writeDataFetchTime(newDuration, true);
            }
        }
    };
    PerformanceLogger._markComponentCore = function (tag, name, markTime) {
        var startTime = this.getComponentStartTime(tag);
        if (startTime === undefined) {
            return undefined;
        }
        var markedTime = markTime || this.now();
        this._logger.addEUPLBreakdown(tag + "." + name, markedTime);
        return markedTime;
    };
    PerformanceLogger._notifyListeners = function () {
        this._listeners.forEach(function (listner) {
            try {
                listner();
            }
            catch (err) {
            }
        });
    };
    PerformanceLogger._checkExcludeCurrentPage = function () {
        var exclude = false;
        var queryParams = new sp_core_library_2.UrlQueryParameterCollection(window.location.href);
        var moduleLoader = queryParams.getValue('moduleLoader');
        if (moduleLoader && moduleLoader.length > 0) {
            exclude = true;
        }
        else if (true) {
            exclude = true;
        }
        if (exclude && !this.isDateNowKillSwitchOn) {
            this._logger.excludePageForPerfData();
        }
    };
    PerformanceLogger._reset = function (applicationName) {
        this._checkExcludeCurrentPage();
        if (this.isDateNowKillSwitchOn) {
            this._logger.saveTempData('SPClientNavStartTime', this.now());
        }
        this._logger.saveTempData('perfStartTime', Date.now());
        this._logger.saveTempData(this._navigationStartOffsetKey, this.fullPageLoad ? 0 : this.now());
        this._logger.addEUPLBreakdown(this._navigationStartOffsetKey, this._logger.readTempData(this._navigationStartOffsetKey));
        this.clearComponentsToSkip();
        this._lastModuleLoadedDuration = undefined;
        this._logger.writeScenarioId(applicationName, true);
    };
    PerformanceLogger._addEnabledFlights = function () {
        if (!sp_core_library_1._SPKillSwitch.isActivated(sp_core_library_1.Guid.tryParse('80011f76-ec1c-4b33-ba7e-06c542c5221f'), '4/6/2017', 'Do not add Flights to perf data')) {
            var allEnabledFlights = [];
            for (var index = 0; this._flightsOptedABTesting && index < this._flightsOptedABTesting.length; index++) {
                var flight = this._flightsOptedABTesting[index];
                if (sp_core_library_1._SPFlight.isEnabled(flight)) {
                    allEnabledFlights.push(flight.toString());
                }
            }
            this._logger.addFlights(allEnabledFlights);
        }
    };
    Object.defineProperty(PerformanceLogger, "isDateNowKillSwitchOn", {
        get: function () {
            if (this._isDateNowKillSwitchOn === undefined) {
                this._isDateNowKillSwitchOn =
                    sp_core_library_1._SPKillSwitch.isActivated(sp_core_library_1.Guid.tryParse('19a3ca15-2aa2-4b0d-a563-4fbee7d77208'), '4/3/2017', 'Use Date.now() instead of Performance.now()');
            }
            return this._isDateNowKillSwitchOn;
        },
        enumerable: true,
        configurable: true
    });
    return PerformanceLogger;
}());
PerformanceLogger._logSource = LogSource_1.default.create('PerformanceLogger');
PerformanceLogger._componentStartTimeKey = 'ComponentStartTime';
PerformanceLogger._componentEndTimeKey = 'ComponentEndTime';
PerformanceLogger._apiStartTimeKey = 'ApiStartTime';
PerformanceLogger._apiEndTimeKey = 'ApiEndTime';
PerformanceLogger._markKey = 'Mark';
PerformanceLogger._spLoaderStartKey = 'spLoaderStart';
PerformanceLogger._applicationStartKey = 'appStart';
PerformanceLogger._navigationStartOffsetKey = 'navigationStartOffset';
PerformanceLogger._listeners = [];
PerformanceLogger._componentsToSkip = new Set();
PerformanceLogger._flightsOptedABTesting = [
    33 ,
    56 ,
    74 ,
    959 ,
    3039 
];
exports.default = PerformanceLogger;


/***/ }),
/* 201 */,
/* 202 */,
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CircularBuffer_1 = __webpack_require__(436);
var LogManager = (function () {
    function LogManager() {
    }
    Object.defineProperty(LogManager, "_maxVerboseLog", {
        get: function () {
            return 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogManager, "events", {
        get: function () {
            return LogManager._events;
        },
        enumerable: true,
        configurable: true
    });
    LogManager.addHandler = function (handler) {
        if (LogManager._contains(handler)) {
            return;
        }
        LogManager._processAll(handler);
        LogManager._handlers.push(handler);
    };
    LogManager.log = function (event) {
        Object.freeze(event);
        LogManager._events.push(event);
        for (var _i = 0, _a = LogManager._handlers; _i < _a.length; _i++) {
            var handle = _a[_i];
            try {
                handle(event);
            }
            catch (e) {
                console.error('failed to handle event:' + e.toString());
            }
        }
    };
    LogManager.removeHandler = function (handler) {
        for (var i = 0; i < LogManager._handlers.length; i++) {
            if (LogManager._handlers[i] === handler) {
                LogManager._handlers.splice(i, 1);
                break;
            }
        }
    };
    LogManager.reset = function () {
        LogManager._handlers = [];
        LogManager._events.removeAll();
    };
    LogManager._contains = function (handler) {
        for (var _i = 0, _a = LogManager._handlers; _i < _a.length; _i++) {
            var existingHandler = _a[_i];
            if (existingHandler === handler) {
                return true;
            }
        }
        return false;
    };
    LogManager._processAll = function (handler) {
        LogManager._events.forEach(function (event) {
            if (event) {
                try {
                    handler(event);
                }
                catch (e) {
                    console.error('failed to handle event:' + e.toString());
                }
            }
        });
    };
    return LogManager;
}());
LogManager._handlers = [];
LogManager._events = new CircularBuffer_1.default(LogManager._maxVerboseLog);
exports.default = LogManager;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./cc2cc925-b5be-41bb-880a-f0f8030c6aff.manifest.json": 462
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 204;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./8217e442-8ed3-41fd-957d-b112e841286a.manifest.json": 463
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 205;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/*
 RequireJS 2.1.20 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
var requirejs,require,define;
(function(ba){function G(b){return"[object Function]"===K.call(b)}function H(b){return"[object Array]"===K.call(b)}function v(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function T(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));d-=1);}}function t(b,c){return fa.call(b,c)}function n(b,c){return t(b,c)&&b[c]}function A(b,c){for(var d in b)if(t(b,d)&&c(b[d],d))break}function U(b,c,d,e){c&&A(c,function(c,i){if(d||!t(b,i))e&&"object"===typeof c&&c&&!H(c)&&!G(c)&&!(c instanceof
RegExp)?(b[i]||(b[i]={}),U(b[i],c,d,e)):b[i]=c});return b}function u(b,c){return function(){return c.apply(b,arguments)}}function ca(b){throw b;}function da(b){if(!b)return b;var c=ba;v(b.split("."),function(b){c=c[b]});return c}function B(b,c,d,e){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=e;d&&(c.originalError=d);return c}function ga(b){function c(a,j,b){var f,l,c,d,h,e,g,i,j=j&&j.split("/"),p=k.map,m=p&&p["*"];if(a){a=a.split("/");l=a.length-1;k.nodeIdCompat&&
Q.test(a[l])&&(a[l]=a[l].replace(Q,""));"."===a[0].charAt(0)&&j&&(l=j.slice(0,j.length-1),a=l.concat(a));l=a;for(c=0;c<l.length;c++)if(d=l[c],"."===d)l.splice(c,1),c-=1;else if(".."===d&&!(0===c||1===c&&".."===l[2]||".."===l[c-1])&&0<c)l.splice(c-1,2),c-=2;a=a.join("/")}if(b&&p&&(j||m)){l=a.split("/");c=l.length;a:for(;0<c;c-=1){h=l.slice(0,c).join("/");if(j)for(d=j.length;0<d;d-=1)if(b=n(p,j.slice(0,d).join("/")))if(b=n(b,h)){f=b;e=c;break a}!g&&(m&&n(m,h))&&(g=n(m,h),i=c)}!f&&g&&(f=g,e=i);f&&(l.splice(0,
e,f),a=l.join("/"))}return(f=n(k.pkgs,a))?f:a}function d(a){z&&v(document.getElementsByTagName("script"),function(j){if(j.getAttribute("data-requiremodule")===a&&j.getAttribute("data-requirecontext")===h.contextName)return j.parentNode.removeChild(j),!0})}function p(a){var j=n(k.paths,a);if(j&&H(j)&&1<j.length)return j.shift(),h.require.undef(a),h.makeRequire(null,{skipMap:!0})([a]),!0}function g(a){var j,c=a?a.indexOf("!"):-1;-1<c&&(j=a.substring(0,c),a=a.substring(c+1,a.length));return[j,a]}function i(a,
j,b,f){var l,d,e=null,i=j?j.name:null,k=a,p=!0,m="";a||(p=!1,a="_@r"+(K+=1));a=g(a);e=a[0];a=a[1];e&&(e=c(e,i,f),d=n(q,e));a&&(e?m=d&&d.normalize?d.normalize(a,function(a){return c(a,i,f)}):-1===a.indexOf("!")?c(a,i,f):a:(m=c(a,i,f),a=g(m),e=a[0],m=a[1],b=!0,l=h.nameToUrl(m)));b=e&&!d&&!b?"_unnormalized"+(O+=1):"";return{prefix:e,name:m,parentMap:j,unnormalized:!!b,url:l,originalName:k,isDefine:p,id:(e?e+"!"+m:m)+b}}function r(a){var j=a.id,b=n(m,j);b||(b=m[j]=new h.Module(a));return b}function s(a,
j,b){var f=a.id,c=n(m,f);if(t(q,f)&&(!c||c.defineEmitComplete))"defined"===j&&b(q[f]);else if(c=r(a),c.error&&"error"===j)b(c.error);else c.on(j,b)}function w(a,b){var c=a.requireModules,f=!1;if(b)b(a);else if(v(c,function(b){if(b=n(m,b))b.error=a,b.events.error&&(f=!0,b.emit("error",a))}),!f)e.onError(a)}function x(){R.length&&(v(R,function(a){var b=a[0];"string"===typeof b&&(h.defQueueMap[b]=!0);C.push(a)}),R=[])}function y(a){delete m[a];delete V[a]}function F(a,b,c){var f=a.map.id;a.error?a.emit("error",
a.error):(b[f]=!0,v(a.depMaps,function(f,d){var e=f.id,h=n(m,e);h&&(!a.depMatched[d]&&!c[e])&&(n(b,e)?(a.defineDep(d,q[e]),a.check()):F(h,b,c))}),c[f]=!0)}function D(){var a,b,c=(a=1E3*k.waitSeconds)&&h.startTime+a<(new Date).getTime(),f=[],l=[],e=!1,i=!0;if(!W){W=!0;A(V,function(a){var h=a.map,g=h.id;if(a.enabled&&(h.isDefine||l.push(a),!a.error))if(!a.inited&&c)p(g)?e=b=!0:(f.push(g),d(g));else if(!a.inited&&(a.fetched&&h.isDefine)&&(e=!0,!h.prefix))return i=!1});if(c&&f.length)return a=B("timeout",
"Load timeout for modules: "+f,null,f),a.contextName=h.contextName,w(a);i&&v(l,function(a){F(a,{},{})});if((!c||b)&&e)if((z||ea)&&!X)X=setTimeout(function(){X=0;D()},50);W=!1}}function E(a){t(q,a[0])||r(i(a[0],null,!0)).init(a[1],a[2])}function I(a){var a=a.currentTarget||a.srcElement,b=h.onScriptLoad;a.detachEvent&&!Y?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=h.onScriptError;(!a.detachEvent||Y)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}
function J(){var a;for(x();C.length;){a=C.shift();if(null===a[0])return w(B("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));E(a)}h.defQueueMap={}}var W,Z,h,L,X,k={waitSeconds:7,baseUrl:"./",paths:{},bundles:{},pkgs:{},shim:{},config:{}},m={},V={},$={},C=[],q={},S={},aa={},K=1,O=1;L={require:function(a){return a.require?a.require:a.require=h.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?q[a.map.id]=a.exports:a.exports=q[a.map.id]={}},
module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return n(k.config,a.map.id)||{}},exports:a.exports||(a.exports={})}}};Z=function(a){this.events=n($,a.id)||{};this.map=a;this.shim=n(k.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};Z.prototype={init:function(a,b,c,f){f=f||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=u(this,function(a){this.emit("error",a)}));
this.depMaps=a&&a.slice(0);this.errback=c;this.inited=!0;this.ignore=f.ignore;f.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;h.startTime=(new Date).getTime();var a=this.map;if(this.shim)h.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],u(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?
this.callPlugin():this.load()}},load:function(){var a=this.map.url;S[a]||(S[a]=!0,h.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var f=this.exports,l=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(G(l)){if(this.events.error&&this.map.isDefine||e.onError!==ca)try{f=h.execCb(c,l,b,f)}catch(d){a=d}else f=h.execCb(c,l,b,f);this.map.isDefine&&
void 0===f&&((b=this.module)?f=b.exports:this.usingExports&&(f=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",w(this.error=a)}else f=l;this.exports=f;if(this.map.isDefine&&!this.ignore&&(q[c]=f,e.onResourceLoad))e.onResourceLoad(h,this.map,this.depMaps);y(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=
!0)}}else t(h.defQueueMap,c)||this.fetch()}},callPlugin:function(){var a=this.map,b=a.id,d=i(a.prefix);this.depMaps.push(d);s(d,"defined",u(this,function(f){var l,d;d=n(aa,this.map.id);var g=this.map.name,P=this.map.parentMap?this.map.parentMap.name:null,p=h.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(f.normalize&&(g=f.normalize(g,function(a){return c(a,P,!0)})||""),f=i(a.prefix+"!"+g,this.map.parentMap),s(f,"defined",u(this,function(a){this.init([],function(){return a},
null,{enabled:!0,ignore:!0})})),d=n(m,f.id)){this.depMaps.push(f);if(this.events.error)d.on("error",u(this,function(a){this.emit("error",a)}));d.enable()}}else d?(this.map.url=h.nameToUrl(d),this.load()):(l=u(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),l.error=u(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];A(m,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&y(a.map.id)});w(a)}),l.fromText=u(this,function(f,c){var d=a.name,g=i(d),P=M;c&&(f=c);P&&
(M=!1);r(g);t(k.config,b)&&(k.config[d]=k.config[b]);try{e.exec(f)}catch(m){return w(B("fromtexteval","fromText eval for "+b+" failed: "+m,m,[b]))}P&&(M=!0);this.depMaps.push(g);h.completeLoad(d);p([d],l)}),f.load(a.name,p,l,k))}));h.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){V[this.map.id]=this;this.enabling=this.enabled=!0;v(this.depMaps,u(this,function(a,b){var c,f;if("string"===typeof a){a=i(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=
n(L,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;s(a,"defined",u(this,function(a){this.undefed||(this.defineDep(b,a),this.check())}));this.errback?s(a,"error",u(this,this.errback)):this.events.error&&s(a,"error",u(this,function(a){this.emit("error",a)}))}c=a.id;f=m[c];!t(L,c)&&(f&&!f.enabled)&&h.enable(a,this)}));A(this.pluginMaps,u(this,function(a){var b=n(m,a.id);b&&!b.enabled&&h.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=
[]);c.push(b)},emit:function(a,b){v(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};h={config:k,contextName:b,registry:m,defined:q,urlFetched:S,defQueue:C,defQueueMap:{},Module:Z,makeModuleMap:i,nextTick:e.nextTick,onError:w,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=k.shim,c={paths:!0,bundles:!0,config:!0,map:!0};A(a,function(a,b){c[b]?(k[b]||(k[b]={}),U(k[b],a,!0,!0)):k[b]=a});a.bundles&&A(a.bundles,function(a,b){v(a,
function(a){a!==b&&(aa[a]=b)})});a.shim&&(A(a.shim,function(a,c){H(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=h.makeShimExports(a);b[c]=a}),k.shim=b);a.packages&&v(a.packages,function(a){var b,a="string"===typeof a?{name:a}:a;b=a.name;a.location&&(k.paths[b]=a.location);k.pkgs[b]=a.name+"/"+(a.main||"main").replace(ha,"").replace(Q,"")});A(m,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=i(b,null,!0))});if(a.deps||a.callback)h.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;
a.init&&(b=a.init.apply(ba,arguments));return b||a.exports&&da(a.exports)}},makeRequire:function(a,j){function g(c,d,p){var k,n;j.enableBuildCallback&&(d&&G(d))&&(d.__requireJsBuild=!0);if("string"===typeof c){if(G(d))return w(B("requireargs","Invalid require call"),p);if(a&&t(L,c))return L[c](m[a.id]);if(e.get)return e.get(h,c,a,g);k=i(c,a,!1,!0);k=k.id;return!t(q,k)?w(B("notloaded",'Module name "'+k+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):q[k]}J();h.nextTick(function(){J();
n=r(i(null,a));n.skipMap=j.skipMap;n.init(c,d,p,{enabled:!0});D()});return g}j=j||{};U(g,{isBrowser:z,toUrl:function(b){var d,e=b.lastIndexOf("."),j=b.split("/")[0];if(-1!==e&&(!("."===j||".."===j)||1<e))d=b.substring(e,b.length),b=b.substring(0,e);return h.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return t(q,i(b,a,!1,!0).id)},specified:function(b){b=i(b,a,!1,!0).id;return t(q,b)||t(m,b)}});a||(g.undef=function(b){x();var c=i(b,a,!0),e=n(m,b);e.undefed=!0;d(b);delete q[b];delete S[c.url];
delete $[b];T(C,function(a,c){a[0]===b&&C.splice(c,1)});delete h.defQueueMap[b];e&&(e.events.defined&&($[b]=e.events),y(b))});return g},enable:function(a){n(m,a.id)&&r(a).enable()},completeLoad:function(a){var b,c,d=n(k.shim,a)||{},e=d.exports;for(x();C.length;){c=C.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);E(c)}h.defQueueMap={};c=n(m,a);if(!b&&!t(q,a)&&c&&!c.inited){if(k.enforceDefine&&(!e||!da(e)))return p(a)?void 0:w(B("nodefine","No define call for "+a,null,[a]));E([a,
d.deps||[],d.exportsFn])}D()},nameToUrl:function(a,b,c){var d,g,i;(d=n(k.pkgs,a))&&(a=d);if(d=n(aa,a))return h.nameToUrl(d,b,c);if(e.jsExtRegExp.test(a))d=a+(b||"");else{d=k.paths;a=a.split("/");for(g=a.length;0<g;g-=1)if(i=a.slice(0,g).join("/"),i=n(d,i)){H(i)&&(i=i[0]);a.splice(0,g,i);break}d=a.join("/");d+=b||(/^data\:|\?/.test(d)||c?"":".js");d=("/"===d.charAt(0)||d.match(/^[\w\+\.\-]+:/)?"":k.baseUrl)+d}return k.urlArgs?d+((-1===d.indexOf("?")?"?":"&")+k.urlArgs):d},load:function(a,b){e.load(h,
a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||ia.test((a.currentTarget||a.srcElement).readyState))N=null,a=I(a),h.completeLoad(a.id)},onScriptError:function(a){var b=I(a);if(!p(b.id))return w(B("scripterror","Script error for: "+b.id,a,[b.id]))}};h.require=h.makeRequire();return h}var e,x,y,D,I,E,N,J,r,O,ja=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,ka=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,Q=/\.js$/,ha=/^\.\//;x=Object.prototype;var K=
x.toString,fa=x.hasOwnProperty,z=!!("undefined"!==typeof window&&"undefined"!==typeof navigator&&window.document),ea=!z&&"undefined"!==typeof importScripts,ia=z&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,Y="undefined"!==typeof opera&&"[object Opera]"===opera.toString(),F={},s={},R=[],M=!1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(G(requirejs))return;s=requirejs;requirejs=void 0}"undefined"!==typeof require&&!G(require)&&(s=require,require=
void 0);e=requirejs=function(b,c,d,p){var g,i="_";!H(b)&&"string"!==typeof b&&(g=b,H(c)?(b=c,c=d,d=p):b=[]);g&&g.context&&(i=g.context);(p=n(F,i))||(p=F[i]=e.s.newContext(i));g&&p.configure(g);return p.require(b,c,d)};e.config=function(b){return e(b)};e.nextTick="undefined"!==typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=e);e.version="2.1.20";e.jsExtRegExp=/^\/|:|\?|\.js$/;e.isBrowser=z;x=e.s={contexts:F,newContext:ga};e({});v(["toUrl","undef","defined","specified"],
function(b){e[b]=function(){var c=F._;return c.require[b].apply(c,arguments)}});if(z&&(y=x.head=document.getElementsByTagName("head")[0],D=document.getElementsByTagName("base")[0]))y=x.head=D.parentNode;e.onError=ca;e.createNode=function(b){var c=b.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script");c.type=b.scriptType||"text/javascript";c.charset="utf-8";c.async=!0;return c};e.load=function(b,c,d){var p=b&&b.config||{},g;if(z){g=e.createNode(p,
c,d);if(p.onNodeCreated)p.onNodeCreated(g,p,c,d);g.setAttribute("data-requirecontext",b.contextName);g.setAttribute("data-requiremodule",c);g.attachEvent&&!(g.attachEvent.toString&&0>g.attachEvent.toString().indexOf("[native code"))&&!Y?(M=!0,g.attachEvent("onreadystatechange",b.onScriptLoad)):(g.addEventListener("load",b.onScriptLoad,!1),g.addEventListener("error",b.onScriptError,!1));g.src=d;J=g;D?y.insertBefore(g,D):y.appendChild(g);J=null;return g}if(ea)try{importScripts(d),b.completeLoad(c)}catch(i){b.onError(B("importscripts",
"importScripts failed for "+c+" at "+d,i,[c]))}};z&&!s.skipDataMain&&T(document.getElementsByTagName("script"),function(b){y||(y=b.parentNode);if(I=b.getAttribute("data-main"))return r=I,s.baseUrl||(E=r.split("/"),r=E.pop(),O=E.length?E.join("/")+"/":"./",s.baseUrl=O),r=r.replace(Q,""),e.jsExtRegExp.test(r)&&(r=I),s.deps=s.deps?s.deps.concat(r):[r],!0});define=function(b,c,d){var e,g;"string"!==typeof b&&(d=c,c=b,b=null);H(c)||(d=c,c=null);!c&&G(d)&&(c=[],d.length&&(d.toString().replace(ja,"").replace(ka,
function(b,d){c.push(d)}),c=(1===d.length?["require"]:["require","exports","module"]).concat(c)));if(M){if(!(e=J))N&&"interactive"===N.readyState||T(document.getElementsByTagName("script"),function(b){if("interactive"===b.readyState)return N=b}),e=N;e&&(b||(b=e.getAttribute("data-requiremodule")),g=F[e.getAttribute("data-requirecontext")])}g?(g.defQueue.push([b,c,d]),g.defQueueMap[b]=!0):R.push([b,c,d])};define.amd={jQuery:!0};e.exec=function(b){return eval(b)};e(s)}})(this);


/*** EXPORTS FROM exports-loader ***/
exports["requirejs"] = (requirejs);
exports["require"] = (require);
exports["define"] = (define);

/***/ }),
/* 207 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 208 */
/***/ (function(module, exports) {

(function (global) {
  eval('/*\r\n * SystemJS v0.19.25\r\n */\r\n!function(){function e(){!function(e){function t(e,n){if("string"!=typeof e)throw new TypeError("URL must be a string");var r=String(e).replace(/^\\s+|\\s+$/g,"").match(/^([^:\\/?#]+:)?(?:\\/\\/(?:([^:@\\/?#]*)(?::([^:@\\/?#]*))?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);if(!r)throw new RangeError("Invalid URL format");var a=r[1]||"",o=r[2]||"",s=r[3]||"",i=r[4]||"",l=r[5]||"",u=r[6]||"",d=r[7]||"",c=r[8]||"",f=r[9]||"";if(void 0!==n){var m=n instanceof t?n:new t(n),p=!a&&!i&&!o;!p||d||c||(c=m.search),p&&"/"!==d[0]&&(d=d?(!m.host&&!m.username||m.pathname?"":"/")+m.pathname.slice(0,m.pathname.lastIndexOf("/")+1)+d:m.pathname);var h=[];d.replace(/^(\\.\\.?(\\/|$))+/,"").replace(/\\/(\\.(\\/|$))+/g,"/").replace(/\\/\\.\\.$/,"/../").replace(/\\/?[^\\/]*/g,function(e){"/.."===e?h.pop():h.push(e)}),d=h.join("").replace(/^\\//,"/"===d[0]?"/":""),p&&(u=m.port,l=m.hostname,i=m.host,s=m.password,o=m.username),a||(a=m.protocol)}"file:"==a&&(d=d.replace(/\\\\/g,"/")),this.origin=i?a+(""!==a||""!==i?"//":"")+i:"",this.href=a+(a&&i||"file:"==a?"//":"")+(""!==o?o+(""!==s?":"+s:"")+"@":"")+i+d+c+f,this.protocol=a,this.username=o,this.password=s,this.host=i,this.hostname=l,this.port=u,this.pathname=d,this.search=c,this.hash=f}e.URLPolyfill=t}("undefined"!=typeof self?self:global),function(e){function t(e,t){return e instanceof Error?(e.message=t+"\\n	"+e.message,Error.call(e,e.message)):e=t+"\\n	"+e,e}function n(e,n,r){try{new Function(e).call(r)}catch(a){throw t(a,"Evaluating "+n)}}function r(){}function a(t){this._loader={loaderObj:this,loads:[],modules:{},importPromises:{},moduleRecords:{}},z(this,"global",{get:function(){return e}})}function o(){a.call(this),this.paths={}}function s(e,t){var n,r="",a=0;for(var o in e){var s=o.split("*");if(s.length>2)throw new TypeError("Only one wildcard in a path is permitted");if(1==s.length){if(t==o)return e[o];if(t.substr(0,o.length-1)==o.substr(0,o.length-1)&&(t.length<o.length||t[o.length-1]==o[o.length-1])&&"/"==e[o][e[o].length-1])return e[o].substr(0,e[o].length-1)+(t.length>o.length?"/"+t.substr(o.length):"")}else{var i=s[0].length;i>=a&&t.substr(0,s[0].length)==s[0]&&t.substr(t.length-s[1].length)==s[1]&&(a=i,r=o,n=t.substr(s[0].length,t.length-s[1].length-s[0].length))}}var l=e[r];return"string"==typeof n&&(l=l.replace("*",n)),l}function i(){}function l(){o.call(this),J.call(this)}function u(){}function d(e,t){l.prototype[e]=t(l.prototype[e]||function(){})}function c(e){J=e(J||function(){})}function f(e){for(var t=[],n=[],r=0,a=e.length;a>r;r++){var o=I.call(t,e[r]);-1===o?(t.push(e[r]),n.push([r])):n[o].push(r)}return{names:t,indices:n}}function m(e){var t={};if("object"==typeof e||"function"==typeof e)if(C){var n;for(var r in e)(n=Object.getOwnPropertyDescriptor(e,r))&&z(t,r,n)}else{var a=e&&e.hasOwnProperty;for(var r in e)(!a||e.hasOwnProperty(r))&&(t[r]=e[r])}return t["default"]=e,z(t,"__useDefault",{value:!0}),t}function p(e,t,n){for(var r in t)n&&r in e||(e[r]=t[r]);return e}function h(e,t,n){for(var r in t){var a=t[r];r in e?a instanceof Array&&e[r]instanceof Array?e[r]=[].concat(n?a:e[r]).concat(n?e[r]:a):"object"==typeof a&&null!==a&&"object"==typeof e[r]?e[r]=p(p({},e[r]),a,n):n||(e[r]=a):e[r]=a}}function g(e){this.warnings&&"undefined"!=typeof console&&console.warn}function v(e,t){for(var n=e.split(".");n.length;)t=t[n.shift()];return t}function y(){if(H[this.baseURL])return H[this.baseURL];"/"!=this.baseURL[this.baseURL.length-1]&&(this.baseURL+="/");var e=new F(this.baseURL,L);return this.baseURL=e.href,H[this.baseURL]=e}function b(e,t){var n,r=0;for(var a in e)if(t.substr(0,a.length)==a&&(t.length==a.length||"/"==t[a.length])){var o=a.split("/").length;if(r>=o)continue;n=a,r=o}return n}function w(e){this.set("@system-env",this.newModule({browser:O,node:!!this._nodeRequire,production:e,"default":!0}))}function x(e){return("."!=e[0]||!!e[1]&&"/"!=e[1]&&"."!=e[1])&&"/"!=e[0]&&!e.match(B)}function S(e,t){return t&&(t=t.replace(/#/g,"%05")),new F(e,t||X).href.replace(/%05/g,"#")}function E(e,t){return new F(t,y.call(e)).href}function j(e,t){if(!x(e))return S(e,t);var n=b(this.map,e);if(n&&(e=this.map[n]+e.substr(n.length),!x(e)))return S(e);if(this.has(e))return e;if("@node/"==e.substr(0,6)&&-1!=Z.indexOf(e.substr(6))){if(!this._nodeRequire)throw new TypeError("Error loading "+e+". Can only load node core modules in Node.");return this.set(e,this.newModule(m(this._nodeRequire(e.substr(6))))),e}var r=s(this.paths,e);return r&&!x(r)?S(r):E(this,r||e)}function _(e){var t=e.match(V);return t&&"System.register"==e.substr(t[0].length,15)}function k(){return{name:null,deps:null,originalIndices:null,declare:null,execute:null,executingRequire:!1,declarative:!1,normalizedDeps:null,groupIndex:null,evaluated:!1,module:null,esModule:null,esmExports:!1}}function P(t){if("string"==typeof t)return v(t,e);if(!(t instanceof Array))throw new Error("Global exports must be a string or array.");for(var n={},r=!0,a=0;a<t.length;a++){var o=v(t[a],e);r&&(n["default"]=o,r=!1),n[t[a].split(".").pop()]=o}return n}var R="undefined"==typeof window&&"undefined"!=typeof self&&"undefined"!=typeof importScripts,O="undefined"!=typeof window&&"undefined"!=typeof document,M="undefined"!=typeof process&&"undefined"!=typeof process.platform&&!!process.platform.match(/^win/);e.console||(e.console={assert:function(){}});var z,I=Array.prototype.indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(this[t]===e)return t;return-1};!function(){try{Object.defineProperty({},"a",{})&&(z=Object.defineProperty)}catch(e){z=function(e,t,n){try{e[t]=n.value||n.get.call(e)}catch(r){}}}}();var L;if("undefined"!=typeof document&&document.getElementsByTagName){if(L=document.baseURI,!L){var A=document.getElementsByTagName("base");L=A[0]&&A[0].href||window.location.href}L=L.split("#")[0].split("?")[0],L=L.substr(0,L.lastIndexOf("/")+1)}else if("undefined"!=typeof process&&process.cwd)L="file://"+(M?"/":"")+process.cwd()+"/",M&&(L=L.replace(/\\\\/g,"/"));else{if("undefined"==typeof location)throw new TypeError("No environment baseURI");L=e.location.href}var F=e.URLPolyfill||e.URL;z(r.prototype,"toString",{value:function(){return"Module"}}),function(){function o(e){return{status:"loading",name:e,linkSets:[],dependencies:[],metadata:{}}}function s(e,t,n){return new Promise(c({step:n.address?"fetch":"locate",loader:e,moduleName:t,moduleMetadata:n&&n.metadata||{},moduleSource:n.source,moduleAddress:n.address}))}function i(e,t,n,r){return new Promise(function(a,o){a(e.loaderObj.normalize(t,n,r))}).then(function(t){var n;if(e.modules[t])return n=o(t),n.status="linked",n.module=e.modules[t],n;for(var r=0,a=e.loads.length;a>r;r++)if(n=e.loads[r],n.name==t)return n;return n=o(t),e.loads.push(n),l(e,n),n})}function l(e,t){u(e,t,Promise.resolve().then(function(){return e.loaderObj.locate({name:t.name,metadata:t.metadata})}))}function u(e,t,n){d(e,t,n.then(function(n){return"loading"==t.status?(t.address=n,e.loaderObj.fetch({name:t.name,metadata:t.metadata,address:n})):void 0}))}function d(t,r,a){a.then(function(a){return"loading"==r.status?Promise.resolve(t.loaderObj.translate({name:r.name,metadata:r.metadata,address:r.address,source:a})).then(function(e){return r.source=e,t.loaderObj.instantiate({name:r.name,metadata:r.metadata,address:r.address,source:e})}).then(function(a){if(void 0===a)return r.address=r.address||"<Anonymous Module "+ ++j+">",r.isDeclarative=!0,E.call(t.loaderObj,r).then(function(t){var a=e.System,o=a.register;a.register=function(e,t,n){"string"!=typeof e&&(n=t,t=e),r.declare=n,r.depsList=t},n(t,r.address,{}),a.register=o});if("object"!=typeof a)throw TypeError("Invalid instantiate return value");r.depsList=a.deps||[],r.execute=a.execute,r.isDeclarative=!1}).then(function(){r.dependencies=[];for(var e=r.depsList,n=[],a=0,o=e.length;o>a;a++)(function(e,a){n.push(i(t,e,r.name,r.address).then(function(t){if(r.dependencies[a]={key:e,value:t.name},"linked"!=t.status)for(var n=r.linkSets.concat([]),o=0,s=n.length;s>o;o++)m(n[o],t)}))})(e[a],a);return Promise.all(n)}).then(function(){r.status="loaded";for(var e=r.linkSets.concat([]),t=0,n=e.length;n>t;t++)h(e[t],r)}):void 0})["catch"](function(e){r.status="failed",r.exception=e;for(var t=r.linkSets.concat([]),n=0,a=t.length;a>n;n++)g(t[n],r,e)})}function c(e){return function(t,n){var r=e.loader,a=e.moduleName,s=e.step;if(r.modules[a])throw new TypeError(\'"\'+a+\'" already exists in the module table\');for(var i,c=0,m=r.loads.length;m>c;c++)if(r.loads[c].name==a&&(i=r.loads[c],"translate"!=s||i.source||(i.address=e.moduleAddress,d(r,i,Promise.resolve(e.moduleSource))),i.linkSets.length&&i.linkSets[0].loads[0].name==i.name))return i.linkSets[0].done.then(function(){t(i)});var p=i||o(a);p.metadata=e.moduleMetadata;var h=f(r,p);r.loads.push(p),t(h.done),"locate"==s?l(r,p):"fetch"==s?u(r,p,Promise.resolve(e.moduleAddress)):(p.address=e.moduleAddress,d(r,p,Promise.resolve(e.moduleSource)))}}function f(e,t){var n={loader:e,loads:[],startingLoad:t,loadingCount:0};return n.done=new Promise(function(e,t){n.resolve=e,n.reject=t}),m(n,t),n}function m(e,t){if("failed"!=t.status){for(var n=0,r=e.loads.length;r>n;n++)if(e.loads[n]==t)return;e.loads.push(t),t.linkSets.push(e),"loaded"!=t.status&&e.loadingCount++;for(var a=e.loader,n=0,r=t.dependencies.length;r>n;n++)if(t.dependencies[n]){var o=t.dependencies[n].value;if(!a.modules[o])for(var s=0,i=a.loads.length;i>s;s++)if(a.loads[s].name==o){m(e,a.loads[s]);break}}}}function p(e){var t=!1;try{w(e,function(n,r){g(e,n,r),t=!0})}catch(n){g(e,null,n),t=!0}return t}function h(e,t){if(e.loadingCount--,!(e.loadingCount>0)){var n=e.startingLoad;if(e.loader.loaderObj.execute===!1){for(var r=[].concat(e.loads),a=0,o=r.length;o>a;a++){var t=r[a];t.module=t.isDeclarative?{name:t.name,module:_({}),evaluated:!0}:{module:_({})},t.status="linked",v(e.loader,t)}return e.resolve(n)}var s=p(e);s||e.resolve(n)}}function g(e,n,r){var a=e.loader;e:if(n)if(e.loads[0].name==n.name)r=t(r,"Error loading "+n.name);else{for(var o=0;o<e.loads.length;o++)for(var s=e.loads[o],i=0;i<s.dependencies.length;i++){var l=s.dependencies[i];if(l.value==n.name){r=t(r,"Error loading "+n.name+\' as "\'+l.key+\'" from \'+s.name);break e}}r=t(r,"Error loading "+n.name+" from "+e.loads[0].name)}else r=t(r,"Error linking "+e.loads[0].name);for(var u=e.loads.concat([]),o=0,d=u.length;d>o;o++){var n=u[o];a.loaderObj.failed=a.loaderObj.failed||[],-1==I.call(a.loaderObj.failed,n)&&a.loaderObj.failed.push(n);var c=I.call(n.linkSets,e);if(n.linkSets.splice(c,1),0==n.linkSets.length){var f=I.call(e.loader.loads,n);-1!=f&&e.loader.loads.splice(f,1)}}e.reject(r)}function v(e,t){if(e.loaderObj.trace){e.loaderObj.loads||(e.loaderObj.loads={});var n={};t.dependencies.forEach(function(e){n[e.key]=e.value}),e.loaderObj.loads[t.name]={name:t.name,deps:t.dependencies.map(function(e){return e.key}),depMap:n,address:t.address,metadata:t.metadata,source:t.source,kind:t.isDeclarative?"declarative":"dynamic"}}t.name&&(e.modules[t.name]=t.module);var r=I.call(e.loads,t);-1!=r&&e.loads.splice(r,1);for(var a=0,o=t.linkSets.length;o>a;a++)r=I.call(t.linkSets[a].loads,t),-1!=r&&t.linkSets[a].loads.splice(r,1);t.linkSets.splice(0,t.linkSets.length)}function y(e,t,n){try{var a=t.execute()}catch(o){return void n(t,o)}return a&&a instanceof r?a:void n(t,new TypeError("Execution must define a Module instance"))}function b(e,t,n){var r=e._loader.importPromises;return r[t]=n.then(function(e){return r[t]=void 0,e},function(e){throw r[t]=void 0,e})}function w(e,t){var n=e.loader;if(e.loads.length)for(var r=e.loads.concat([]),a=0;a<r.length;a++){var o=r[a],s=y(e,o,t);if(!s)return;o.module={name:o.name,module:s},o.status="linked",v(n,o)}}function x(e,t){return t.module.module}function S(){}function E(){throw new TypeError("ES6 transpilation is only provided in the dev module loader build.")}var j=0;a.prototype={constructor:a,define:function(e,t,n){if(this._loader.importPromises[e])throw new TypeError("Module is already loading.");return b(this,e,new Promise(c({step:"translate",loader:this._loader,moduleName:e,moduleMetadata:n&&n.metadata||{},moduleSource:t,moduleAddress:n&&n.address})))},"delete":function(e){var t=this._loader;return delete t.importPromises[e],delete t.moduleRecords[e],t.modules[e]?delete t.modules[e]:!1},get:function(e){return this._loader.modules[e]?(S(this._loader.modules[e],[],this),this._loader.modules[e].module):void 0},has:function(e){return!!this._loader.modules[e]},"import":function(e,t,n){"object"==typeof t&&(t=t.name);var r=this;return Promise.resolve(r.normalize(e,t)).then(function(e){var t=r._loader;return t.modules[e]?(S(t.modules[e],[],t._loader),t.modules[e].module):t.importPromises[e]||b(r,e,s(t,e,{}).then(function(n){return delete t.importPromises[e],x(t,n)}))})},load:function(e){var t=this._loader;return t.modules[e]?Promise.resolve():t.importPromises[e]||b(this,e,new Promise(c({step:"locate",loader:t,moduleName:e,moduleMetadata:{},moduleSource:void 0,moduleAddress:void 0})).then(function(){delete t.importPromises[e]}))},module:function(e,t){var n=o();n.address=t&&t.address;var r=f(this._loader,n),a=Promise.resolve(e),s=this._loader,i=r.done.then(function(){return x(s,n)});return d(s,n,a),i},newModule:function(e){if("object"!=typeof e)throw new TypeError("Expected object");var t=new r,n=[];if(Object.getOwnPropertyNames&&null!=e)n=Object.getOwnPropertyNames(e);else for(var a in e)n.push(a);for(var o=0;o<n.length;o++)(function(n){z(t,n,{configurable:!1,enumerable:!0,get:function(){return e[n]},set:function(){throw new Error("Module exports cannot be changed externally.")}})})(n[o]);return Object.freeze&&Object.freeze(t),t},set:function(e,t){if(!(t instanceof r))throw new TypeError("Loader.set("+e+", module) must be a module");this._loader.modules[e]={module:t}},normalize:function(e,t,n){return e},locate:function(e){return e.name},fetch:function(e){},translate:function(e){return e.source},instantiate:function(e){}};var _=a.prototype.newModule}();var D;i.prototype=a.prototype,o.prototype=new i;var T;if("undefined"!=typeof XMLHttpRequest)T=function(e,t,n,r){function a(){n(s.responseText)}function o(){r(new Error("XHR error"+(s.status?" ("+s.status+(s.statusText?" "+s.statusText:"")+")":"")+" loading "+e))}var s=new XMLHttpRequest,i=!0,l=!1;if(!("withCredentials"in s)){var u=/^(\\w+:)?\\/\\/([^\\/]+)/.exec(e);u&&(i=u[2]===window.location.host,u[1]&&(i&=u[1]===window.location.protocol))}i||"undefined"==typeof XDomainRequest||(s=new XDomainRequest,s.onload=a,s.onerror=o,s.ontimeout=o,s.onprogress=function(){},s.timeout=0,l=!0),s.onreadystatechange=function(){4===s.readyState&&(0==s.status?s.responseText?a():(s.addEventListener("error",o),s.addEventListener("load",a)):200===s.status?a():o())},s.open("GET",e,!0),s.setRequestHeader&&(s.setRequestHeader("Accept","application/x-es-module, */*"),t&&("string"==typeof t&&s.setRequestHeader("Authorization",t),s.withCredentials=!0)),l?setTimeout(function(){s.send()},0):s.send(null)};else if("undefined"!=typeof require&&"undefined"!=typeof process){var q;T=function(e,t,n,r){if("file:///"!=e.substr(0,8))throw new Error(\'Unable to fetch "\'+e+\'". Only file URLs of the form file:/// allowed running in Node.\');return q=q||require("fs"),e=M?e.replace(/\\//g,"\\\\").substr(8):e.substr(7),q.readFile(e,function(e,t){if(e)return r(e);var a=t+"";"\\ufeff"===a[0]&&(a=a.substr(1)),n(a)})}}else{if("undefined"==typeof self||"undefined"==typeof self.fetch)throw new TypeError("No environment fetch API available.");T=function(e,t,n,r){var a={headers:{Accept:"application/x-es-module, */*"}};t&&("string"==typeof t&&(a.headers.Authorization=t),a.credentials="include"),fetch(e,a).then(function(e){if(e.ok)return e.text();throw new Error("Fetch error: "+e.status+" "+e.statusText)}).then(n,r)}}o.prototype.fetch=function(e){return new Promise(function(t,n){T(e.address,void 0,t,n)})};(function(){function t(t){var r=this;return Promise.resolve(e["typescript"==r.transpiler?"ts":r.transpiler]||(r.pluginLoader||r)["import"](r.transpiler)).then(function(e){e.__useDefault&&(e=e["default"]);var a;return a=e.Compiler?n:e.createLanguageService?s:o,"(function(__moduleName){"+a.call(r,t,e)+\'\\n})("\'+t.name+\'");\\n//# sourceURL=\'+t.address+"!transpiled"})}function n(e,t){var n=this.traceurOptions||{};n.modules="instantiate",n.script=!1,void 0===n.sourceMaps&&(n.sourceMaps="inline"),n.filename=e.address,n.inputSourceMap=e.metadata.sourceMap,n.moduleName=!1;var a=new t.Compiler(n);return r(e.source,a,n.filename)}function r(e,t,n){try{return t.compile(e,n)}catch(r){if(r.length)throw r[0];throw r}}function o(e,t){var n=this.babelOptions||{};return n.modules="system",void 0===n.sourceMap&&(n.sourceMap="inline"),n.inputSourceMap=e.metadata.sourceMap,n.filename=e.address,n.code=!0,n.ast=!1,t.transform(e.source,n).code}function s(e,t){var n=this.typescriptOptions||{};return n.target=n.target||t.ScriptTarget.ES5,void 0===n.sourceMap&&(n.sourceMap=!0),n.sourceMap&&n.inlineSourceMap!==!1&&(n.inlineSourceMap=!0),n.module=t.ModuleKind.System,t.transpile(e.source,n,e.address)}return a.prototype.transpiler="traceur",t})();u.prototype=o.prototype,l.prototype=new u,l.prototype.constructor=l,l.prototype.instantiate=function(){};var J,C=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(U){C=!1}var N,$=["main","format","defaultExtension","meta","map","basePath","depCache"];!function(){function n(e){var t=e.source.lastIndexOf("\\n"),n="global"!=e.metadata.format,r=e.metadata.sourceMap;if(r){if("object"!=typeof r)throw new TypeError("load.metadata.sourceMap must be set to an object.");r=JSON.stringify(r)}return(n?"(function(System, SystemJS, require) {":"")+e.source+(n?"\\n})(System, System);":"")+("\\n//# sourceURL="!=e.source.substr(t,15)?"\\n//# sourceURL="+e.address+(r?"!transpiled":""):"")+(r&&i&&"\\n//# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(r)))||"")}function r(t,n){s=n,0==u++&&(l=e.System),e.System=e.SystemJS=t}function a(){0==--u&&(e.System=e.SystemJS=l),s=void 0}function o(e){m||(m=document.head||document.body||document.documentElement);var o=document.createElement("script");o.text=n(e,!1);var s,i=window.onerror;if(window.onerror=function(n){s=t(n,"Evaluating "+e.address)},r(this,e),e.metadata.integrity&&o.setAttribute("integrity",e.metadata.integrity),e.metadata.nonce&&o.setAttribute("nonce",e.metadata.nonce),m.appendChild(o),m.removeChild(o),a(),window.onerror=i,s)throw s}var s,i="undefined"!=typeof btoa;d("pushRegister_",function(){return function(e){return s?(this.reduceRegister_(s,e),!0):!1}});var l,u=0;N=function(e){if(e.source){if((e.metadata.integrity||e.metadata.nonce)&&c)return o.call(this,e);try{r(this,e),s=e,(0,eval)(n(e)),a()}catch(i){throw a(),t(i,"Evaluating "+e.address)}}};var c=!1;if(O&&"undefined"!=typeof document&&document.getElementsByTagName){var f=document.getElementsByTagName("script");$__curScript=f[f.length-1],window.chrome&&window.chrome.extension||navigator.userAgent.match(/^Node\\.js/)||(c=!0)}var m}();var B=/^[^\\/]+:\\/\\//,H={},X=new F(L);c(function(e){return function(){e.call(this),this.baseURL=L.substr(0,L.lastIndexOf("/")+1),this.map={},this.paths={},this.warnings=!1,this.defaultJSExtensions=!1,this.pluginFirst=!1,this.loaderErrorStack=!1,this.set("@empty",this.newModule({})),w.call(this,!1)}}),"undefined"==typeof require||"undefined"==typeof process||process.browser||(l.prototype._nodeRequire=require);var Z=["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","process","punycode","querystring","readline","repl","stream","string_decoder","sys","timers","tls","tty","url","util","vm","zlib"];d("normalize",function(e){return function(e,t,n){var r=j.call(this,e,t);return n||!this.defaultJSExtensions||".js"==r.substr(r.length-3,3)||x(r)||(r+=".js"),r}});var G="undefined"!=typeof XMLHttpRequest;d("locate",function(e){return function(t){return Promise.resolve(e.call(this,t)).then(function(e){return G?e.replace(/#/g,"%23"):e})}}),d("fetch",function(){return function(e){return new Promise(function(t,n){T(e.address,e.metadata.authorization,t,n)})}}),d("import",function(e){return function(t,n,r){return n&&n.name&&g.call(this,"SystemJS.import(name, { name: parentName }) is deprecated for SystemJS.import(name, parentName), while importing "+t+" from "+n.name),e.call(this,t,n,r).then(function(e){return e.__useDefault?e["default"]:e})}}),d("translate",function(e){return function(t){return"detect"==t.metadata.format&&(t.metadata.format=void 0),e.call(this,t)}}),d("instantiate",function(e){return function(e){if("json"==e.metadata.format&&!this.builder){var t=e.metadata.entry=k();t.deps=[],t.execute=function(){try{return JSON.parse(e.source)}catch(t){throw new Error("Invalid JSON file "+e.name)}}}}}),l.prototype.env="development";var W;l.prototype.config=function(e){function t(e){for(var t in e)if(hasOwnProperty.call(e,t))return!0}var n=this;if("loaderErrorStack"in e&&(W=$__curScript,e.loaderErrorStack?$__curScript=void 0:$__curScript=W),"warnings"in e&&(n.warnings=e.warnings),e.transpilerRuntime===!1&&(n._loader.loadedTranspilerRuntime=!0),e.baseURL){if(t(n.packages)||t(n.meta)||t(n.depCache)||t(n.bundles)||t(n.packageConfigPaths))throw new TypeError("Incorrect configuration order. The baseURL must be configured with the first SystemJS.config call.");n.baseURL=e.baseURL,y.call(n)}if(e.defaultJSExtensions&&(n.defaultJSExtensions=e.defaultJSExtensions,g.call(n,"The defaultJSExtensions configuration option is deprecated, use packages configuration instead.")),e.pluginFirst&&(n.pluginFirst=e.pluginFirst),e.production&&w.call(n,!0),e.paths)for(var r in e.paths)n.paths[r]=e.paths[r];if(e.map){var a="";for(var r in e.map){var o=e.map[r];if("string"!=typeof o){a+=(a.length?", ":"")+\'"\'+r+\'"\';var s=n.defaultJSExtensions&&".js"!=r.substr(r.length-3,3),i=n.decanonicalize(r);s&&".js"==i.substr(i.length-3,3)&&(i=i.substr(0,i.length-3));var l="";for(var u in n.packages)i.substr(0,u.length)==u&&(!i[u.length]||"/"==i[u.length])&&l.split("/").length<u.split("/").length&&(l=u);l&&n.packages[l].main&&(i=i.substr(0,i.length-n.packages[l].main.length-1));var u=n.packages[i]=n.packages[i]||{};u.map=o}else n.map[r]=o}a&&g.call(n,"The map configuration for "+a+\' uses object submaps, which is deprecated in global map.\\nUpdate this to use package contextual map with configs like SystemJS.config({ packages: { "\'+r+\'": { map: {...} } } }).\')}if(e.packageConfigPaths){for(var d=[],c=0;c<e.packageConfigPaths.length;c++){var f=e.packageConfigPaths[c],m=Math.max(f.lastIndexOf("*")+1,f.lastIndexOf("/")),s=n.defaultJSExtensions&&".js"!=f.substr(m-3,3),p=n.decanonicalize(f.substr(0,m));s&&".js"==p.substr(p.length-3,3)&&(p=p.substr(0,p.length-3)),d[c]=p+f.substr(m)}n.packageConfigPaths=d}if(e.bundles)for(var r in e.bundles){for(var v=[],c=0;c<e.bundles[r].length;c++){var s=n.defaultJSExtensions&&".js"!=e.bundles[r][c].substr(e.bundles[r][c].length-3,3),b=n.decanonicalize(e.bundles[r][c]);s&&".js"==b.substr(b.length-3,3)&&(b=b.substr(0,b.length-3)),v.push(b)}n.bundles[r]=v}if(e.packages)for(var r in e.packages){if(r.match(/^([^\\/]+:)?\\/\\/$/))throw new TypeError(\'"\'+r+\'" is not a valid package name.\');var i=j.call(n,r);"/"==i[i.length-1]&&(i=i.substr(0,i.length-1)),n.packages[i]=n.packages[i]||{};var u=e.packages[r];u.modules&&(g.call(n,"Package "+r+\' is configured with "modules", which is deprecated as it has been renamed to "meta".\'),u.meta=u.modules,delete u.modules),"object"==typeof u.main&&(u.map=u.map||{},u.map["./@main"]=u.main,u.main["default"]=u.main["default"]||"./",u.main="@main");for(var S in u)-1==I.call($,S)&&g.call(n,\'"\'+S+\'" is not a valid package configuration option in package \'+r);h(n.packages[i],u)}for(var E in e){var o=e[E];if("baseURL"!=E&&"map"!=E&&"packages"!=E&&"bundles"!=E&&"paths"!=E&&"warnings"!=E&&"packageConfigPaths"!=E&&"loaderErrorStack"!=E)if("object"!=typeof o||o instanceof Array)n[E]=o;else{n[E]=n[E]||{};for(var r in o)if("meta"==E&&"*"==r[0])n[E][r]=o[r];else if("meta"==E){var _=j.call(n,r);n.defaultJSExtensions&&".js"!=_.substr(_.length-3,3)&&!x(_)&&(_+=".js"),n[E][_]=o[r]}else if("depCache"==E){var s=n.defaultJSExtensions&&".js"!=r.substr(r.length-3,3),i=n.decanonicalize(r);s&&".js"==i.substr(i.length-3,3)&&(i=i.substr(0,i.length-3)),n[E][i]=o[r]}else n[E][r]=o[r]}}},function(){function e(e,t){var n,r,a=0;for(var o in e.packages)t.substr(0,o.length)!==o||t.length!==o.length&&"/"!==t[o.length]||(r=o.split("/").length,r>a&&(n=o,a=r));return n}function t(e,t,n,r,a){if(!r||"/"==r[r.length-1]||a||t.defaultExtension===!1)return r;if(r.match(interpolationRegEx))return r;var o=!1;if(t.meta&&p(t.meta,r,function(e,t,n){return 0==n||e.lastIndexOf("*")!=e.length-1?o=!0:void 0}),!o&&e.meta&&p(e.meta,n+"/"+r,function(e,t,n){return 0==n||e.lastIndexOf("*")!=e.length-1?o=!0:void 0}),o)return r;var s="."+(t.defaultExtension||"js");return r.substr(r.length-s.length)!=s?r+s:r}function n(e,n,r,o,s){if(!o){if(!n.main)return r+(e.defaultJSExtensions?".js":"");o="./"==n.main.substr(0,2)?n.main.substr(2):n.main}if(n.map){var i="./"+o,l=b(n.map,i);if(l||(i="./"+t(e,n,r,o,s),i!="./"+o&&(l=b(n.map,i))),l)return a(e,n,r,l,i,s)}return r+"/"+t(e,n,r,o,s)}function r(e,t,n){if("."==e)throw new Error("Package "+n+\' has a map entry for "." which is not permitted.\');if(t.substr(0,e.length)==e&&"/"!=e[e.length-1]&&"/"==t[e.length])throw new Error("Package "+n+\' has a recursive map for "\'+e+\'" which is not permitted.\')}function a(e,n,a,o,s,i){var l=n.map[o];if("object"==typeof l)throw new Error("Synchronous conditional normalization not supported sync normalizing "+o+" in "+a);if(r(o,l,a),"string"!=typeof l&&(l=o=s),r(o,l,a),"."==l)l=a;else if("./"==l.substr(0,2))return a+"/"+t(e,n,a,l.substr(2)+s.substr(o.length),i);return e.normalizeSync(l+s.substr(o.length),a+"/")}function o(e,n,r,a,o){if(!a){if(!n.main)return Promise.resolve(r+(e.defaultJSExtensions?".js":""));a="./"==n.main.substr(0,2)?n.main.substr(2):n.main}var s,l;return n.map&&(s="./"+a,l=b(n.map,s),l||(s="./"+t(e,n,r,a,o),s!="./"+a&&(l=b(n.map,s)))),(l?i(e,n,r,l,s,o):Promise.resolve()).then(function(s){return s?Promise.resolve(s):Promise.resolve(r+"/"+t(e,n,r,a,o))})}function s(e,n,r,a,o,s,i){if("."==o)o=r;else if("./"==o.substr(0,2))return Promise.resolve(r+"/"+t(e,n,r,o.substr(2)+s.substr(a.length),i)).then(function(t){return interpolateConditional.call(e,t,r+"/")});return e.normalize(o+s.substr(a.length),r+"/")}function i(e,t,n,a,o,i){var l=t.map[a];return"string"==typeof l?(r(a,l,n),s(e,t,n,a,l,o,i)):e.builder?Promise.resolve(n+"/#:"+o):e["import"](t.map["@env"]||"@system-env",n).then(function(e){for(var t in l){var n="~"==t[0],r=v(n?t.substr(1):t,e);if(!n&&r||n&&!r)return l[t]}}).then(function(l){if(l){if("string"!=typeof l)throw new Error("Unable to map a package conditional to a package conditional.");return r(a,l,n),s(e,t,n,a,l,o,i)}})}function u(e){var t=e.lastIndexOf("*"),n=Math.max(t+1,e.lastIndexOf("/"));return{length:n,regEx:new RegExp("^("+e.substr(0,n).replace(/[.+?^${}()|[\\]\\\\]/g,"\\\\$&").replace(/\\*/g,"[^\\\\/]+")+")(\\\\/|$)"),wildcard:-1!=t}}function f(e,t){for(var n,r,a=!1,o=0;o<e.packageConfigPaths.length;o++){var s=e.packageConfigPaths[o],i=y[s]||(y[s]=u(s));if(!(t.length<i.length)){var l=t.match(i.regEx);!l||n&&(a&&i.wildcard||!(n.length<l[1].length))||(n=l[1],a=!i.wildcard,r=n+s.substr(i.length))}}return n?{packageName:n,configPath:r}:void 0}function m(e,t,n){var r=e.pluginLoader||e;return(r.meta[n]=r.meta[n]||{}).format="json",r.load(n).then(function(){var a=r.get(n)["default"];a.systemjs&&(a=a.systemjs),a.modules&&(a.meta=a.modules,g.call(e,"Package config file "+n+\' is configured with "modules", which is deprecated as it has been renamed to "meta".\'));for(var o in a)-1==I.call($,o)&&delete a[o];var s=e.packages[t]=e.packages[t]||{};if(h(s,a,!0),a.depCache){for(var i in a.depCache){var l;l="./"==i.substr(0,2)?t+"/"+i.substr(2):j.call(e,i),e.depCache[l]=(e.depCache[l]||[]).concat(a.depCache[i])}delete a.depCache}return"object"==typeof s.main&&(s.map=s.map||{},s.map["./@main"]=s.main,s.main["default"]=s.main["default"]||"./",s.main="@main"),s})}function p(e,t,n){var r;for(var a in e){var o="./"==a.substr(0,2)?"./":"";if(o&&(a=a.substr(2)),r=a.indexOf("*"),-1!==r&&a.substr(0,r)==t.substr(0,r)&&a.substr(r+1)==t.substr(t.length-a.length+r+1)&&n(a,e[o+a],a.split("/").length))return}var s=e[t]&&e.hasOwnProperty&&e.hasOwnProperty(t)?e[t]:e["./"+t];s&&n(s,s,0)}c(function(e){return function(){e.call(this),this.packages={},this.packageConfigPaths=[]}}),l.prototype.normalizeSync=l.prototype.decanonicalize=l.prototype.normalize,d("decanonicalize",function(t){return function(n,r){if(this.builder)return t.call(this,n,r,!0);var a=t.call(this,n,r);if(!this.defaultJSExtensions)return a;var o=e(this,a),s=this.packages[o],i=s&&s.defaultExtension;return void 0==i&&s&&s.meta&&p(s.meta,a.substr(o),function(e,t,n){return 0==n||e.lastIndexOf("*")!=e.length-1?(i=!1,!0):void 0}),(i===!1||i&&".js"!=i)&&".js"!=n.substr(n.length-3,3)&&".js"==a.substr(a.length-3,3)&&(a=a.substr(0,a.length-3)),a}}),d("normalizeSync",function(t){return function(r,o,s){g.call(this,"SystemJS.normalizeSync has been deprecated for SystemJS.decanonicalize.");var i=this;if(s=s===!0,o)var l=e(i,o)||i.defaultJSExtensions&&".js"==o.substr(o.length-3,3)&&e(i,o.substr(0,o.length-3));var u=l&&i.packages[l];if(u&&"."!=r[0]){var d=u.map,c=d&&b(d,r);if(c&&"string"==typeof d[c])return a(i,u,l,c,r,s)}var m=i.defaultJSExtensions&&".js"!=r.substr(r.length-3,3),p=t.call(i,r,o);m&&".js"!=p.substr(p.length-3,3)&&(m=!1),m&&(p=p.substr(0,p.length-3));var h=f(i,p),v=h&&h.packageName||e(i,p);if(!v)return p+(m?".js":"");var y=p.substr(v.length+1);return n(i,i.packages[v]||{},v,y,s)}}),d("normalize",function(t){return function(n,r,a){var s=this;return a=a===!0,Promise.resolve().then(function(){if(r)var t=e(s,r)||s.defaultJSExtensions&&".js"==r.substr(r.length-3,3)&&e(s,r.substr(0,r.length-3));var o=t&&s.packages[t];if(o&&"./"!=n.substr(0,2)){var l=o.map,u=l&&b(l,n);if(u)return i(s,o,t,u,n,a)}return Promise.resolve()}).then(function(i){if(i)return i;var l=s.defaultJSExtensions&&".js"!=n.substr(n.length-3,3),u=t.call(s,n,r);l&&".js"!=u.substr(u.length-3,3)&&(l=!1),l&&(u=u.substr(0,u.length-3));var d=f(s,u),c=d&&d.packageName||e(s,u);if(!c)return Promise.resolve(u+(l?".js":""));var p=s.packages[c],h=p&&(p.configured||!d);return(h?Promise.resolve(p):m(s,c,d.configPath)).then(function(e){var t=u.substr(c.length+1);return o(s,e,c,t,a)})})}});var y={};d("locate",function(t){return function(n){var r=this;return Promise.resolve(t.call(this,n)).then(function(t){var a=e(r,n.name);if(a){var o=r.packages[a],s=n.name.substr(a.length+1);o.format&&(n.metadata.format=n.metadata.format||o.format);var i={};if(o.meta){var l=0;p(o.meta,s,function(e,t,n){n>l&&(l=n),h(i,t,n&&l>n)}),h(n.metadata,i)}}return t})}})}(),function(){function t(){if(s&&"interactive"===s.script.readyState)return s.load;for(var e=0;e<u.length;e++)if("interactive"==u[e].script.readyState)return s=u[e],s.load}function n(e,t){return new Promise(function(e,n){t.metadata.integrity&&n(new Error("Subresource integrity checking is not supported in web workers.")),i=t;try{importScripts(t.address)}catch(r){i=null,n(r)}i=null,t.metadata.entry||n(new Error(t.address+" did not call System.register or AMD define")),e("")})}if("undefined"!=typeof document)var r=document.getElementsByTagName("head")[0];var a,o,s,i=null,l=r&&function(){var e=document.createElement("script"),t="undefined"!=typeof opera&&"[object Opera]"===opera.toString();return e.attachEvent&&!(e.attachEvent.toString&&e.attachEvent.toString().indexOf("[native code")<0)&&!t}(),u=[],c=0,f=[];d("pushRegister_",function(e){return function(n){return e.call(this,n)?!1:(i?this.reduceRegister_(i,n):l?this.reduceRegister_(t(),n):c?f.push(n):this.reduceRegister_(null,n),!0)}}),d("fetch",function(t){return function(i){var d=this;return"json"!=i.metadata.format&&i.metadata.scriptLoad&&(O||R)?R?n(d,i):new Promise(function(t,n){function m(e){if(!g.readyState||"loaded"==g.readyState||"complete"==g.readyState){\r\nif(c--,i.metadata.entry||f.length){if(!l){for(var r=0;r<f.length;r++)d.reduceRegister_(i,f[r]);f=[]}}else d.reduceRegister_(i);h(),i.metadata.entry||i.metadata.bundle||n(new Error(i.name+" did not call System.register or AMD define. If loading a global module configure the global name via the meta exports property for script injection support.")),t("")}}function p(e){h(),n(new Error("Unable to load script "+i.address))}function h(){if(e.System=a,e.require=o,g.detachEvent){g.detachEvent("onreadystatechange",m);for(var t=0;t<u.length;t++)u[t].script==g&&(s&&s.script==g&&(s=null),u.splice(t,1))}else g.removeEventListener("load",m,!1),g.removeEventListener("error",p,!1);r.removeChild(g)}var g=document.createElement("script");g.async=!0,i.metadata.crossOrigin&&(g.crossOrigin=i.metadata.crossOrigin),i.metadata.integrity&&g.setAttribute("integrity",i.metadata.integrity),l?(g.attachEvent("onreadystatechange",m),u.push({script:g,load:i})):(g.addEventListener("load",m,!1),g.addEventListener("error",p,!1)),c++,a=e.System,o=e.require,g.src=i.address,r.appendChild(g)}):t.call(this,i)}})}();var V=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*"[^"]+"\\s*;?|\\s*\'[^\']+\'\\s*;?)*\\s*/;!function(){function t(e,n,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==I.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var a=0,o=e.normalizedDeps.length;o>a;a++){var s=e.normalizedDeps[a],i=n.defined[s];if(i&&!i.evaluated){var l=e.groupIndex+(i.declarative!=e.declarative);if(null===i.groupIndex||i.groupIndex<l){if(null!==i.groupIndex&&(r[i.groupIndex].splice(I.call(r[i.groupIndex],i),1),0==r[i.groupIndex].length))throw new Error("Mixed dependency cycle detected");i.groupIndex=l}t(i,n,r)}}}}function n(e,n){var r=n.defined[e];if(!r.module){r.groupIndex=0;var a=[];t(r,n,a);for(var o=!!r.declarative==a.length%2,i=a.length-1;i>=0;i--){for(var l=a[i],d=0;d<l.length;d++){var c=l[d];o?s(c,n):u(c,n)}o=!o}}}function a(){}function o(e,t){return t[e]||(t[e]={name:e,dependencies:[],exports:new a,importers:[]})}function s(t,n){if(!t.module){var r=n._loader.moduleRecords,a=t.module=o(t.name,r),i=t.module.exports,l=t.declare.call(e,function(e,t){if(a.locked=!0,"object"==typeof e)for(var n in e)i[n]=e[n];else i[e]=t;for(var r=0,o=a.importers.length;o>r;r++){var s=a.importers[r];if(!s.locked){var l=I.call(s.dependencies,a);s.setters[l](i)}}return a.locked=!1,t},{id:t.name});if(a.setters=l.setters,a.execute=l.execute,!a.setters||!a.execute)throw new TypeError("Invalid System.register form for "+t.name);for(var u=0,d=t.normalizedDeps.length;d>u;u++){var c,f=t.normalizedDeps[u],m=n.defined[f],p=r[f];p?c=p.exports:m&&!m.declarative?c=m.esModule:m?(s(m,n),p=m.module,c=p.exports):c=n.get(f),p&&p.importers?(p.importers.push(a),a.dependencies.push(p)):a.dependencies.push(null);for(var h=t.originalIndices[u],g=0,v=h.length;v>g;++g){var y=h[g];a.setters[y]&&a.setters[y](c)}}}}function i(e,t){var n,r=t.defined[e];if(r)r.declarative?p(e,[],t):r.evaluated||u(r,t),n=r.module.exports;else if(n=t.get(e),!n)throw new Error("Unable to load dependency "+e+".");return(!r||r.declarative)&&n&&n.__useDefault?n["default"]:n}function u(t,n){if(!t.module){var a={},o=t.module={exports:a,id:t.name};if(!t.executingRequire)for(var s=0,l=t.normalizedDeps.length;l>s;s++){var d=t.normalizedDeps[s],c=n.defined[d];c&&u(c,n)}t.evaluated=!0;var f=t.execute.call(e,function(e){for(var r=0,a=t.deps.length;a>r;r++)if(t.deps[r]==e)return i(t.normalizedDeps[r],n);var o=n.normalizeSync(e,t.name);if(-1!=I.call(t.normalizedDeps,o))return i(o,n);throw new Error("Module "+e+" not declared as a dependency of "+t.name)},a,o);f&&(o.exports=f),a=o.exports,a&&(a.__esModule||a instanceof r)?t.esModule=a:t.esmExports&&a!==e?t.esModule=m(a):t.esModule={"default":a}}}function p(t,n,r){var a=r.defined[t];if(a&&!a.evaluated&&a.declarative){n.push(t);for(var o=0,s=a.normalizedDeps.length;s>o;o++){var i=a.normalizedDeps[o];-1==I.call(n,i)&&(r.defined[i]?p(i,n,r):r.get(i))}a.evaluated||(a.evaluated=!0,a.module.execute.call(e))}}l.prototype.register=function(e,t,n){if("string"!=typeof e&&(n=t,t=e,e=null),"boolean"==typeof n)return this.registerDynamic.apply(this,arguments);var r=k();r.name=e&&(this.decanonicalize||this.normalize).call(this,e),r.declarative=!0,r.deps=t,r.declare=n,this.pushRegister_({amd:!1,entry:r})},l.prototype.registerDynamic=function(e,t,n,r){"string"!=typeof e&&(r=n,n=t,t=e,e=null);var a=k();a.name=e&&(this.decanonicalize||this.normalize).call(this,e),a.deps=t,a.execute=r,a.executingRequire=n,this.pushRegister_({amd:!1,entry:a})},d("reduceRegister_",function(){return function(e,t){if(t){var n=t.entry,r=e&&e.metadata;if(n.name&&(n.name in this.defined||(this.defined[n.name]=n),r&&(r.bundle=!0)),!n.name||e&&n.name==e.name){if(!r)throw new TypeError("Invalid System.register call. Anonymous System.register calls can only be made by modules loaded by SystemJS.import and not via script tags.");if(r.entry)throw"register"==r.format?new Error("Multiple anonymous System.register calls in module "+e.name+". If loading a bundle, ensure all the System.register calls are named."):new Error("Module "+e.name+" interpreted as "+r.format+" module format, but called System.register.");r.format||(r.format="register"),r.entry=n}}}}),c(function(e){return function(){e.call(this),this.defined={},this._loader.moduleRecords={}}}),z(a,"toString",{value:function(){return"Module"}}),d("delete",function(e){return function(t){return delete this._loader.moduleRecords[t],delete this.defined[t],e.call(this,t)}}),d("fetch",function(e){return function(t){return this.defined[t.name]?(t.metadata.format="defined",""):(t.metadata.deps=t.metadata.deps||[],e.call(this,t))}}),d("translate",function(e){return function(t){return t.metadata.deps=t.metadata.deps||[],Promise.resolve(e.call(this,t)).then(function(e){return("register"==t.metadata.format||!t.metadata.format&&_(t.source))&&(t.metadata.format="register"),e})}}),d("instantiate",function(e){return function(t){"detect"==t.metadata.format&&(t.metadata.format=void 0),e.call(this,t);var r,a=this;if(a.defined[t.name])r=a.defined[t.name],r.declarative||(r.deps=r.deps.concat(t.metadata.deps));else if(t.metadata.entry)r=t.metadata.entry,r.deps=r.deps.concat(t.metadata.deps);else if(!(a.builder&&t.metadata.bundle||"register"!=t.metadata.format&&"esm"!=t.metadata.format&&"es6"!=t.metadata.format)){if("undefined"!=typeof N&&N.call(a,t),!t.metadata.entry&&!t.metadata.bundle)throw new Error(t.name+" detected as "+t.metadata.format+" but didn\'t execute.");r=t.metadata.entry,r&&t.metadata.deps&&(r.deps=r.deps.concat(t.metadata.deps))}r||(r=k(),r.deps=t.metadata.deps,r.execute=function(){}),a.defined[t.name]=r;var o=f(r.deps);r.deps=o.names,r.originalIndices=o.indices,r.name=t.name,r.esmExports=t.metadata.esmExports!==!1;for(var s=[],i=0,l=r.deps.length;l>i;i++)s.push(Promise.resolve(a.normalize(r.deps[i],t.name)));return Promise.all(s).then(function(e){return r.normalizedDeps=e,{deps:r.deps,execute:function(){return n(t.name,a),p(t.name,[],a),a.defined[t.name]=void 0,a.newModule(r.declarative?r.module.exports:r.esModule)}}})}})}();var K="undefined"!=typeof self?"self":"global";d("fetch",function(e){return function(t){return t.metadata.exports&&!t.metadata.format&&(t.metadata.format="global"),e.call(this,t)}}),d("instantiate",function(e){return function(t){var n=this;if(t.metadata.format||(t.metadata.format="global"),"global"==t.metadata.format&&!t.metadata.registered){var r=k();t.metadata.entry=r,r.deps=[];for(var a in t.metadata.globals){var o=t.metadata.globals[a];o&&r.deps.push(o)}r.execute=function(e,r,a){var o;if(t.metadata.globals){o={};for(var s in t.metadata.globals)t.metadata.globals[s]&&(o[s]=e(t.metadata.globals[s]))}var i=t.metadata.exports;i&&(t.source+="\\n"+K+\'["\'+i+\'"] = \'+i+";");var l=n.get("@@global-helpers").prepareGlobal(a.id,i,o);try{N.call(n,t)}catch(u){throw l(),u}return l()}}return e.call(this,t)}}),d("reduceRegister_",function(e){return function(t,n){if(n||!t.metadata.exports)return e.call(this,t,n);t.metadata.format="global";var r=t.metadata.entry=k();r.deps=t.metadata.deps;var a=P(t.metadata.exports);r.execute=function(){return a}}}),c(function(t){return function(){function n(t){if(Object.keys)Object.keys(e).forEach(t);else for(var n in e)s.call(e,n)&&t(n)}function r(t){n(function(n){if(-1==I.call(i,n)){try{var r=e[n]}catch(a){i.push(n)}t(n,r)}})}var a=this;t.call(a);var o,s=Object.prototype.hasOwnProperty,i=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];a.set("@@global-helpers",a.newModule({prepareGlobal:function(t,n,a){var s=e.define;e.define=void 0;var i;if(a){i={};for(var l in a)i[l]=e[l],e[l]=a[l]}return n||(o={},r(function(e,t){o[e]=t})),function(){var t;if(n)t=P(n);else{t={};var a,l;r(function(e,n){o[e]!==n&&"undefined"!=typeof n&&(t[e]=n,"undefined"!=typeof a?l||a===n||(l=!0):a=n)}),t=l?t:a}if(i)for(var u in i)e[u]=i[u];return e.define=s,t}}}))}}),function(){function t(e){function t(e,t){for(var n=0;n<e.length;n++)if(e[n][0]<t.index&&e[n][1]>t.index)return!0;return!1}r.lastIndex=a.lastIndex=o.lastIndex=0;var n,s=[],i=[],l=[];if(e.length/e.split("\\n").length<200){for(;n=o.exec(e);)i.push([n.index,n.index+n[0].length]);for(;n=a.exec(e);)t(i,n)||l.push([n.index,n.index+n[0].length])}for(;n=r.exec(e);)if(!t(i,n)&&!t(l,n)){var u=n[1].substr(1,n[1].length-2);if(u.match(/"|\'/))continue;"/"==u[u.length-1]&&(u=u.substr(0,u.length-1)),s.push(u)}return s}var n=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])(exports\\s*(\\[[\'"]|\\.)|module(\\.exports|\\[\'exports\'\\]|\\["exports"\\])\\s*(\\[[\'"]|[=,\\.]))/,r=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF."\'])require\\s*\\(\\s*("[^"\\\\]*(?:\\\\.[^"\\\\]*)*"|\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\')\\s*\\)/g,a=/(^|[^\\\\])(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/gm,o=/("[^"\\\\\\n\\r]*(\\\\.[^"\\\\\\n\\r]*)*"|\'[^\'\\\\\\n\\r]*(\\\\.[^\'\\\\\\n\\r]*)*\')/g,s=/^\\#\\!.*/;d("instantiate",function(a){return function(o){var i=this;if(o.metadata.format||(n.lastIndex=0,r.lastIndex=0,(r.exec(o.source)||n.exec(o.source))&&(o.metadata.format="cjs")),"cjs"==o.metadata.format){var l=o.metadata.deps,u=o.metadata.cjsRequireDetection===!1?[]:t(o.source);for(var d in o.metadata.globals)o.metadata.globals[d]&&u.push(o.metadata.globals[d]);var c=k();o.metadata.entry=c,c.deps=u,c.executingRequire=!0,c.execute=function(t,n,r){function a(e){return"/"==e[e.length-1]&&(e=e.substr(0,e.length-1)),t.apply(this,arguments)}if(a.resolve=function(e){return i.get("@@cjs-helpers").requireResolve(e,r.id)},!o.metadata.cjsDeferDepsExecute)for(var u=0;u<l.length;u++)a(l[u]);var d=i.get("@@cjs-helpers").getPathVars(r.id),c={exports:n,args:[a,n,r,d.filename,d.dirname,e,e]},f="(function(require, exports, module, __filename, __dirname, global, GLOBAL";if(o.metadata.globals)for(var m in o.metadata.globals)c.args.push(a(o.metadata.globals[m])),f+=", "+m;var p=e.define;e.define=void 0,e.__cjsWrapper=c,o.source=f+") {"+o.source.replace(s,"")+"\\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);",N.call(i,o),e.__cjsWrapper=void 0,e.define=p}}return a.call(i,o)}})}(),c(function(e){return function(){function t(e){return"file:///"==e.substr(0,8)?e.substr(7+!!M):r&&e.substr(0,r.length)==r?e.substr(r.length):e}var n=this;if(e.call(n),"undefined"!=typeof window&&"undefined"!=typeof document&&window.location)var r=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");n.set("@@cjs-helpers",n.newModule({requireResolve:function(e,r){return t(n.normalizeSync(e,r))},getPathVars:function(e){var n,r=e.lastIndexOf("!");n=-1!=r?e.substr(0,r):e;var a=n.split("/");return a.pop(),a=a.join("/"),{filename:t(n),dirname:t(a)}}}))}}),d("fetch",function(t){return function(n){return n.metadata.scriptLoad&&O&&(e.define=this.amdDefine),t.call(this,n)}}),c(function(t){return function(){function n(e,t){e=e.replace(s,"");var n=e.match(u),r=(n[1].split(",")[t]||"require").replace(c,""),a=f[r]||(f[r]=new RegExp(i+r+l,"g"));a.lastIndex=0;for(var o,d=[];o=a.exec(e);)d.push(o[2]||o[3]);return d}function r(e,t,n,a){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof t&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var s=o.defaultJSExtensions&&".js"!=e.substr(e.length-3,3),i=o.decanonicalize(e,a);s&&".js"==i.substr(i.length-3,3)&&(i=i.substr(0,i.length-3));var l=o.get(i);if(!l)throw new Error(\'Module not already loaded loading "\'+e+\'" as \'+i+(a?\' from "\'+a+\'".\':"."));return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var u=[],d=0;d<e.length;d++)u.push(o["import"](e[d],a));Promise.all(u).then(function(e){t&&t.apply(null,e)},n)}function a(t,a,s){function i(t,n,i){function c(e,n,a){return"string"==typeof e&&"function"!=typeof n?t(e):r.call(o,e,n,a,i.id)}for(var f=[],m=0;m<a.length;m++)f.push(t(a[m]));i.uri=i.id,i.config=function(){},-1!=d&&f.splice(d,0,i),-1!=u&&f.splice(u,0,n),-1!=l&&(c.toUrl=function(e){var t=o.defaultJSExtensions&&".js"!=e.substr(e.length-3,3),n=o.decanonicalize(e,i.id);return t&&".js"==n.substr(n.length-3,3)&&(n=n.substr(0,n.length-3)),n},f.splice(l,0,c));var p=e.require;e.require=r;var h=s.apply(-1==u?e:n,f);return e.require=p,"undefined"==typeof h&&i&&(h=i.exports),"undefined"!=typeof h?h:void 0}"string"!=typeof t&&(s=a,a=t,t=null),a instanceof Array||(s=a,a=["require","exports","module"].splice(0,s.length)),"function"!=typeof s&&(s=function(e){return function(){return e}}(s)),void 0===a[a.length-1]&&a.pop();var l,u,d;-1!=(l=I.call(a,"require"))&&(a.splice(l,1),t||(a=a.concat(n(s.toString(),l)))),-1!=(u=I.call(a,"exports"))&&a.splice(u,1),-1!=(d=I.call(a,"module"))&&a.splice(d,1);var c=k();c.name=t&&(o.decanonicalize||o.normalize).call(o,t),c.deps=a,c.execute=i,o.pushRegister_({amd:!0,entry:c})}var o=this;t.call(this);var s=/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/gm,i="(?:^|[^$_a-zA-Z\\\\xA0-\\\\uFFFF.])",l="\\\\s*\\\\(\\\\s*(\\"([^\\"]+)\\"|\'([^\']+)\')\\\\s*\\\\)",u=/\\(([^\\)]*)\\)/,c=/^\\s+|\\s+$/g,f={};a.amd={},d("reduceRegister_",function(e){return function(t,n){if(!n||!n.amd)return e.call(this,t,n);var r=t&&t.metadata,a=n.entry;if(r&&(r.format="amd"),a.name)r&&(r.entry||r.bundle?r.entry&&r.entry.name&&(r.entry=void 0):r.entry=a,r.bundle=!0),a.name in this.defined||(this.defined[a.name]=a);else{if(!r)throw new TypeError("Unexpected anonymous AMD define.");if(r.entry&&!r.entry.name)throw new Error("Multiple anonymous defines in module "+t.name);r.entry=a}}}),o.amdDefine=a,o.amdRequire=r}}),function(){var t=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*("[^"]+"\\s*,\\s*|\'[^\']+\'\\s*,\\s*)?\\s*(\\[(\\s*(("[^"]+"|\'[^\']+\')\\s*,|\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*(\\s*("[^"]+"|\'[^\']+\')\\s*,?)?(\\s*(\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*\\s*\\]|function\\s*|{|[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*\\))/;d("instantiate",function(n){return function(r){var a=this;if("amd"==r.metadata.format||!r.metadata.format&&r.source.match(t))if(r.metadata.format="amd",a.builder||a.execute===!1)r.metadata.execute=function(){return r.metadata.builderExecute.apply(this,arguments)};else{var o=e.define;e.define=this.amdDefine;try{N.call(a,r)}finally{e.define=o}if(!r.metadata.entry&&!r.metadata.bundle)throw new TypeError("AMD module "+r.name+" did not define")}return n.call(a,r)}})}(),function(){function e(e,t){if(t){var n;if(e.pluginFirst){if(-1!=(n=t.lastIndexOf("!")))return t.substr(n+1)}else if(-1!=(n=t.indexOf("!")))return t.substr(0,n);return t}}function t(e,t){var n,r,a=t.lastIndexOf("!");return-1!=a?(e.pluginFirst?(n=t.substr(a+1),r=t.substr(0,a)):(n=t.substr(0,a),r=t.substr(a+1)||n.substr(n.lastIndexOf(".")+1)),{argument:n,plugin:r}):void 0}function n(e,t,n,r){return r&&".js"==t.substr(t.length-3,3)&&(t=t.substr(0,t.length-3)),e.pluginFirst?n+"!"+t:t+"!"+n}function r(e,t){return e.defaultJSExtensions&&".js"!=t.substr(t.length-3,3)}function a(a){return function(o,s,i){var l=this;s=e(this,s);var u=t(l,o);if(!u)return a.call(this,o,s,i);var d=l.normalizeSync(u.argument,s,!0),c=l.normalizeSync(u.plugin,s,!0);return n(l,d,c,r(l,u.argument))}}d("decanonicalize",a),d("normalizeSync",a),d("normalize",function(a){return function(o,s,i){var l=this;s=e(this,s);var u=t(l,o);return u?Promise.all([l.normalize(u.argument,s,!0),l.normalize(u.plugin,s)]).then(function(e){return n(l,e[0],e[1],r(l,u.argument))}):a.call(l,o,s,i)}}),d("locate",function(e){return function(t){var n,r=this,a=t.name;return r.pluginFirst?-1!=(n=a.indexOf("!"))&&(t.metadata.loader=a.substr(0,n),t.name=a.substr(n+1)):-1!=(n=a.lastIndexOf("!"))&&(t.metadata.loader=a.substr(n+1),t.name=a.substr(0,n)),e.call(r,t).then(function(e){return-1==n&&t.metadata.loader?r.normalize(t.metadata.loader,t.name).then(function(n){return t.metadata.loader=n,e}):e}).then(function(e){var n=t.metadata.loader;if(!n)return e;if(t.name==n)throw new Error("Plugin "+n+" cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.");if(r.defined&&r.defined[a])return e;var o=r.pluginLoader||r;return o["import"](n).then(function(n){return t.metadata.loaderModule=n,t.address=e,n.locate?n.locate.call(r,t):e})})}}),d("fetch",function(e){return function(t){var n=this;return t.metadata.loaderModule&&t.metadata.loaderModule.fetch&&"defined"!=t.metadata.format?(t.metadata.scriptLoad=!1,t.metadata.loaderModule.fetch.call(n,t,function(t){return e.call(n,t)})):e.call(n,t)}}),d("translate",function(e){return function(t){var n=this;return t.metadata.loaderModule&&t.metadata.loaderModule.translate&&"defined"!=t.metadata.format?Promise.resolve(t.metadata.loaderModule.translate.call(n,t)).then(function(r){var a=t.metadata.sourceMap;if(a){if("object"!=typeof a)throw new Error("load.metadata.sourceMap must be set to an object.");var o=t.name.split("!")[0];a.file=o+"!transpiled",(!a.sources||a.sources.length<=1)&&(a.sources=[o])}return"string"==typeof r?t.source=r:g.call(this,"Plugin "+t.metadata.loader+" should return the source in translate, instead of setting load.source directly. This support will be deprecated."),e.call(n,t)}):e.call(n,t)}}),d("instantiate",function(e){return function(t){var n=this,r=!1;return t.metadata.loaderModule&&t.metadata.loaderModule.instantiate&&!n.builder&&"defined"!=t.metadata.format?Promise.resolve(t.metadata.loaderModule.instantiate.call(n,t,function(t){if(r)throw new Error("Instantiate must only be called once.");return r=!0,e.call(n,t)})).then(function(a){return r?a:(t.metadata.entry=k(),t.metadata.entry.execute=function(){return a},t.metadata.entry.deps=t.metadata.deps,t.metadata.format="defined",e.call(n,t))}):e.call(n,t)}})}(),function(){d("fetch",function(e){return function(t){var n=t.metadata.alias,r=t.metadata.deps||[];if(n){t.metadata.format="defined";var a=k();return this.defined[t.name]=a,a.declarative=!0,a.deps=r.concat([n]),a.declare=function(e){return{setters:[function(t){for(var n in t)e(n,t[n]);t.__useDefault&&(a.module.exports.__useDefault=!0)}],execute:function(){}}},""}return e.call(this,t)}})}(),function(){function e(e,t,n){for(var r,a=t.split(".");a.length>1;)r=a.shift(),e=e[r]=e[r]||{};r=a.shift(),r in e||(e[r]=n)}c(function(e){return function(){this.meta={},e.call(this)}}),d("locate",function(e){return function(t){var n,r=this.meta,a=t.name,o=0;for(var s in r)if(n=s.indexOf("*"),-1!==n&&s.substr(0,n)===a.substr(0,n)&&s.substr(n+1)===a.substr(a.length-s.length+n+1)){var i=s.split("/").length;i>o&&(o=i),h(t.metadata,r[s],o!=i)}return r[a]&&h(t.metadata,r[a]),e.call(this,t)}});var t=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*"[^"]+"\\s*;?|\\s*\'[^\']+\'\\s*;?)+/,n=/\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\/\\/[^\\n]*|"[^"]+"\\s*;?|\'[^\']+\'\\s*;?/g;d("translate",function(r){return function(a){var o=a.source.match(t);if(o)for(var s=o[0].match(n),i=0;i<s.length;i++){var l=s[i],u=l.length,d=l.substr(0,1);if(";"==l.substr(u-1,1)&&u--,\'"\'==d||"\'"==d){var c=l.substr(1,l.length-3),f=c.substr(0,c.indexOf(" "));if(f){var m=c.substr(f.length+1,c.length-f.length-1);"[]"==f.substr(f.length-2,2)?(f=f.substr(0,f.length-2),a.metadata[f]=a.metadata[f]||[],a.metadata[f].push(m)):a.metadata[f]instanceof Array?(g.call(this,"Module "+a.name+\' contains deprecated "deps \'+m+\'" meta syntax.\\nThis should be updated to "deps[] \'+m+\'" for pushing to array meta.\'),a.metadata[f].push(m)):e(a.metadata,f,m)}else a.metadata[c]=!0}}return r.call(this,a)}})}(),function(){c(function(e){return function(){e.call(this),this.depCache={}}}),d("locate",function(e){return function(t){var n=this,r=n.depCache[t.name];if(r)for(var a=0;a<r.length;a++)n["import"](r[a],t.name);return e.call(n,t)}})}(),D=new l,e.SystemJS=D,D.version="0.19.25 for SPFx","object"==typeof exports&&(module.exports=a),e.Reflect=e.Reflect||{},e.Reflect.Loader=e.Reflect.Loader||a,e.Reflect.global=e.Reflect.global||e,e.LoaderPolyfill=a,D||(D=new o,D.constructor=o),"object"==typeof exports&&(module.exports=D),e.System=D}("undefined"!=typeof self?self:global)}var t="undefined"==typeof Promise;if("undefined"!=typeof document){var n=document.getElementsByTagName("script");if($__curScript=n[n.length-1],t){var r=$__curScript.src,a=r.substr(0,r.lastIndexOf("/")+1);window.systemJSBootstrap=e,document.write(\'<script type="text/javascript" src="\'+a+\'system-polyfills.js"></script>\')}else e()}else if("undefined"!=typeof importScripts){var a="";try{throw new Error("_")}catch(o){o.stack.replace(/(?:at|@).*(http.+):[\\d]+:[\\d]+/,function(e,t){$__curScript={src:t},a=t.replace(/\\/[^\\/]*$/,"/")})}t&&importScripts(a+"system-polyfills.js"),e()}else $__curScript="undefined"!=typeof __filename?{src:__filename}:null,e()}();\r\n');
}.call(exports, (function() { return this; }())))

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = ".heading{font-size:70px;font-family:Helvetica,Arial,sans-serif;font-weight:700;color:red;-webkit-text-stroke:2px #000}.otherLines{font-size:15px;font-family:Helvetica,Arial,sans-serif;font-weight:700;color:#000}"

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings =  false
    ? require('../../resx-strings/en-us.json')
    : __webpack_require__(30);
exports.default = strings['_fwMQe6Xe08yEeCPNxngd+g'];


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var BrowserDeveloperToolsWarning_resx_1 = __webpack_require__(210);
var WARNING_URL = 'https://technet.microsoft.com/en-us/library/bb794823.aspx';
function showBrowserDevToolsWarning() {
    var browserInfo = sp_core_library_1._BrowserDetection.getBrowserInformation();
    var warningHeading = BrowserDeveloperToolsWarning_resx_1.default.warningHeading;
    var warningLine1 = BrowserDeveloperToolsWarning_resx_1.default.warningLine1;
    var warningLine2 = sp_core_library_1.Text.format(BrowserDeveloperToolsWarning_resx_1.default.warningLine2, WARNING_URL);
    if (browserInfo.browser === sp_core_library_1._Browser.Chrome ||
        browserInfo.browser === sp_core_library_1._Browser.Firefox ||
        browserInfo.browser === sp_core_library_1._Browser.Safari) {
        var stylesCss = __webpack_require__(209);
        var headingCss = (stylesCss.match(/\.heading\s*{([^}]+)}/) || [])[1];
        var otherLinesCss = (stylesCss.match(/\.otherLines\s*{([^}]+)}/) || [])[1];
        console.log("\n%c" + warningHeading + "%c\n" + warningLine1 + "\n\n" + warningLine2 + "\n\n", headingCss, otherLinesCss);
    }
    else {
        console.log("\n" + warningHeading + "\n" + warningLine1 + "\n\n" + warningLine2 + "\n\n");
    }
}
exports.showBrowserDevToolsWarning = showBrowserDevToolsWarning;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ComponentStore_1 = __webpack_require__(32);
var SPComponentLoaderProxy_1 = __webpack_require__(74);
var componentConstants = __webpack_require__(21);
var DeveloperToolsLoader_resx_1 = __webpack_require__(213);
var BACKTICK_KEYCODE = 192;
var F12_KEYCODE = 123;
var MAC_PLATFORM_IDENTIFIER = 'MacIntel';
undefined/*! require.include @microsoft/load-themed-styles */;
var _listenerHasBeenRegistered = false;
var _developerTools;
var _developerToolsTabsBacklog = [];
function initialize() {
    if (!_listenerHasBeenRegistered) {
        document.documentElement.addEventListener('keydown', function (event) {
            var isMac = navigator.platform === MAC_PLATFORM_IDENTIFIER;
            if (((event.ctrlKey && !event.metaKey) || (isMac && event.metaKey && !event.ctrlKey)) && !event.altKey) {
                if (event.shiftKey) {
                    if (event.keyCode === BACKTICK_KEYCODE) {
                        alert(DeveloperToolsLoader_resx_1.default.developerToolsKeyComboDeprecationMessage);
                        event.preventDefault();
                    }
                }
                else {
                    if (event.keyCode === F12_KEYCODE) {
                        toggleDeveloperTools();
                        event.preventDefault();
                    }
                }
            }
        });
        _listenerHasBeenRegistered = true;
    }
}
exports.initialize = initialize;
function registerDeveloperToolsTab(developerToolsTab) {
    if (_developerTools) {
        _developerTools.registerDeveloperToolsTab(developerToolsTab);
    }
    else {
        _developerToolsTabsBacklog.push(developerToolsTab);
    }
}
exports.registerDeveloperToolsTab = registerDeveloperToolsTab;
function toggleDeveloperTools() {
    if (_developerTools) {
        _developerTools.toggleDeveloperTools();
    }
    else {
        if (true) {
            undefined/*! require.include react */;
            undefined/*! require.include react-dom */;
            var reactPromise = SPComponentLoaderProxy_1.default.loadComponentById(componentConstants.reactComponentId);
            var reactDomPromise = SPComponentLoaderProxy_1.default.loadComponentById(componentConstants.reactDomComponentId);
            Promise.all([reactPromise, reactDomPromise])
                .then(function (results) {
                var react = results[0];
                var reactDom = results[1];
                _injectReactIntoCache(react, reactDom);
                __webpack_require__.e/* require.ensure */(0).then((function (require) {
                    _initializeDeveloperTools(__webpack_require__(118).default);
                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
            });
        }
        else if (_hasReact()) {
            var reactPromise = ComponentStore_1.default.instance.getComponentById(componentConstants.reactComponentId);
            var reactDomPromise = ComponentStore_1.default.instance.getComponentById(componentConstants.reactDomComponentId);
            Promise.all([reactPromise, reactDomPromise])
                .then(function (results) {
                var react = results[0];
                var reactDom = results[1];
                _injectReactIntoCache(react, reactDom);
                _loadDeveloperTools(_tryFillDevToolsFabric());
            });
        }
        else {
            require.ensure(['react', 'react-dom'], function () {
                require.ensure(['./DeveloperToolsFabric'], function () {
                    require.ensure(['./DeveloperTools'], function (require) {
                        _initializeDeveloperTools(require('./DeveloperTools').default);
                    }, 'developer-tools');
                }, 'developer-tools-fabric');
            }, 'react');
        }
    }
}
exports.toggleDeveloperTools = toggleDeveloperTools;
function _hasReact() {
    var react = ComponentStore_1.default.instance.tryGetComponentById(componentConstants.reactComponentId, false);
    var reactDom = ComponentStore_1.default.instance.tryGetComponentById(componentConstants.reactDomComponentId, false);
    return !!(react && reactDom);
}
function _tryFillDevToolsFabric() {
    var fabricPromise = ComponentStore_1.default.instance.tryGetComponentById(componentConstants.officeUiFabricReactComponentId, false);
    if (fabricPromise) {
        var fabricId_1 = /*require.resolve*/(465);
        return fabricPromise.then(function (fabric) {
            if (!__webpack_require__.c[fabricId_1]) {
                __webpack_require__.c[fabricId_1] = {
                    exports: fabric
                };
            }
            else {
                __webpack_require__.c[fabricId_1].exports = fabric;
            }
            return true;
        }, function (error) {
            return false;
        });
    }
    else {
        return Promise.resolve(false);
    }
}
function _injectReactIntoCache(react, reactDom) {
    var reactId = /*require.resolve*/(116);
    var reactLibId = /*require.resolve*/(466);
    var reactDomId = /*require.resolve*/(117);
    if (!__webpack_require__.c[reactId]) {
        __webpack_require__.c[reactId] = {
            exports: react
        };
    }
    else {
        __webpack_require__.c[reactId].exports = react;
    }
    if (!__webpack_require__.c[reactLibId]) {
        __webpack_require__.c[reactLibId] = {
            exports: react
        };
    }
    else {
        __webpack_require__.c[reactLibId].exports = react;
    }
    if (!__webpack_require__.c[reactDomId]) {
        __webpack_require__.c[reactDomId] = {
            exports: reactDom
        };
    }
    else {
        __webpack_require__.c[reactDomId].exports = reactDom;
    }
}
function _loadDeveloperTools(fabricLoadedPromise) {
    var loadDeveloperTools = function () {
        __webpack_require__.e(/*resolveChunk*/(undefined /* Invalid chunk name "developer-tools" */))
            .then(function () {
            _initializeDeveloperTools(__webpack_require__(/*require.resolve*/(118)).default);
        });
    };
    fabricLoadedPromise.then(function (fabricLoaded) {
        if (!fabricLoaded) {
            __webpack_require__.e(/*resolveChunk*/(undefined /* Invalid chunk name "developer-tools-fabric" */)).then(loadDeveloperTools);
        }
        else {
            loadDeveloperTools();
        }
    });
}
function _initializeDeveloperTools(developerToolsClass) {
    _developerTools = developerToolsClass.instance;
    _developerTools.initialize();
    _developerToolsTabsBacklog.forEach(function (developerToolsTab) {
        _developerTools.registerDeveloperToolsTab(developerToolsTab);
    });
    _developerTools.showHideDeveloperTools(true);
}


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings =  false
    ? require('../resx-strings/en-us.json')
    : __webpack_require__(30);
exports.default = strings['_CmyT6Anz+yC/KJh8Pcbu5g'];


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DeveloperToolsProxy = (function () {
    function DeveloperToolsProxy() {
    }
    DeveloperToolsProxy.initialize = function (developerToolsLoader) {
        DeveloperToolsProxy._instance = developerToolsLoader;
        DeveloperToolsProxy._instance.initialize();
    };
    DeveloperToolsProxy.registerDeveloperToolsTab = function (developerToolsTab) {
        DeveloperToolsProxy._instance.registerDeveloperToolsTab(developerToolsTab);
    };
    return DeveloperToolsProxy;
}());
exports.default = DeveloperToolsProxy;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings =  false
    ? require('resx-strings/en-us.json')
    : __webpack_require__(30);
exports.default = strings['_gIErrcTokcw+/VVwa+ReIA'];


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var strings =  false
    ? require('../resx-strings/en-us.json')
    : __webpack_require__(30);
exports.default = strings['_kf4jigwPPCxeciwsfHc9rA'];


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ensureDebugComponents_1 = __webpack_require__(122);
function showDebugError(innerError, errorText) {
    return ensureDebugComponents_1.default().then(function (debugComponents) { return debugComponents.showError(innerError, errorText); });
}
exports.default = showDebugError;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var ManifestStore_1 = __webpack_require__(4);
var ComponentStore_1 = __webpack_require__(32);
var RequireJsLoader_1 = __webpack_require__(76);
var normalizeName_1 = __webpack_require__(77);
var ComponentOverrider = (function () {
    function ComponentOverrider() {
    }
    ComponentOverrider.overrideComponent = function (componentId, componentModule) {
        sp_core_library_1.Validate.isNonemptyString(componentId, 'componentId');
        sp_core_library_1.Validate.isNotNullOrUndefined(componentModule, 'componentModule');
        var manifest = ManifestStore_1.default.instance.tryGetManifest(componentId);
        if (!manifest) {
            return;
        }
        var normalizedName = normalizeName_1.default(manifest);
        RequireJsLoader_1.default.instance.ensure(normalizedName, componentModule);
        ComponentStore_1.default.instance.storeComponent(manifest.id, manifest.version, Promise.resolve(componentModule));
    };
    return ComponentOverrider;
}());
exports.default = ComponentOverrider;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var BaseComponentLoader_1 = __webpack_require__(119);
var ManifestStore_1 = __webpack_require__(4);
var loadComponent_1 = __webpack_require__(220);
var RequireJsLoader_1 = __webpack_require__(76);
var ComponentOverrider_1 = __webpack_require__(218);
var componentConstants = __webpack_require__(21);
var telemetryConstants = __webpack_require__(6);
var debugManifestProvider_1 = __webpack_require__(75);
var SPLoader_resx_1 = __webpack_require__(5);
var SPRequireJsComponentLoader = (function (_super) {
    __extends(SPRequireJsComponentLoader, _super);
    function SPRequireJsComponentLoader() {
        var _this = _super.call(this) || this;
        _this._isInitialized = false;
        _this._requireJsLoader = RequireJsLoader_1.default.instance;
        return _this;
    }
    SPRequireJsComponentLoader.prototype._initialize = function (preloadedData, bundledComponents) {
        if (this._isInitialized) {
            return Promise.resolve();
        }
        this._isInitialized = true;
        ManifestStore_1.default.instance.registerPreloadedManifests(preloadedData);
        if (true) {
            __webpack_require__(126).initializeNpmModule();
        }
        if (!bundledComponents) {
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLoaderComponentId, __webpack_require__(31));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spCoreLibraryComponentId, __webpack_require__(0));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLodashSubsetComponentId, __webpack_require__(49));
            ComponentOverrider_1.default.overrideComponent(componentConstants.odspUtilitiesBundleComponentId, __webpack_require__(20));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spTelemetryComponentId, __webpack_require__(2));
        }
        else {
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLoaderComponentId, __webpack_require__(31));
            bundledComponents.forEach(function (value, key) {
                ComponentOverrider_1.default.overrideComponent(key, value);
            });
        }
        return debugManifestProvider_1.loadDebugManifests(this).catch(function () {
        });
    };
    SPRequireJsComponentLoader.prototype.loadScript = function (url, options) {
        sp_core_library_1.Validate.isNonemptyString(url, 'url');
        if (typeof options === 'string') {
            var error = new Error(SPLoader_resx_1.default.loadScriptWithStringError);
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadScriptLogSource, error);
            throw error;
        }
        return this._requireJsLoader.requireLoad(url).then(function (module) {
            if (options && options.globalExportsName) {
                return window[options.globalExportsName]; 
            }
            else {
                return module;
            }
        });
    };
    SPRequireJsComponentLoader.prototype.loadComponent = function (manifest) {
        return loadComponent_1.default(manifest);
    };
    return SPRequireJsComponentLoader;
}(BaseComponentLoader_1.BaseComponentLoader));
exports.default = SPRequireJsComponentLoader;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_lodash_subset_1 = __webpack_require__(49);
var sp_telemetry_1 = __webpack_require__(2);
var RequireJsLoader_1 = __webpack_require__(76);
var ManifestStore_1 = __webpack_require__(4);
var ComponentStore_1 = __webpack_require__(32);
var telemetryConstants = __webpack_require__(6);
var normalizeName_1 = __webpack_require__(77);
var ResourceUrlChecker_1 = __webpack_require__(125);
var SPLoader_resx_1 = __webpack_require__(5);
var FIRST_RETRY = 1;
var MAX_NUMBER_RETRIES = 3;
var LOAD_COMPONENT_IMPL_EVENT_NAME = 'loadComponentImpl';
var _requireJsLoader = RequireJsLoader_1.default.instance;
function loadComponent(manifest) {
    sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
    var cachedModule = ComponentStore_1.default.instance.getComponent(manifest.id, manifest.version);
    if (cachedModule) {
        return cachedModule;
    }
    var qosMonitor = new sp_telemetry_1._QosMonitor(telemetryConstants.loadComponentQosScenarioName);
    var qosExtraData = _buildQosExtraData(manifest); 
    var componentPromise = _loadComponentRetryStrategy(manifest, FIRST_RETRY, MAX_NUMBER_RETRIES)
        .then(function (component) {
        qosMonitor.writeSuccess(qosExtraData);
        return component;
    })
        .catch(function (error) {
        qosMonitor.writeUnexpectedFailure(undefined, error, qosExtraData);
        ComponentStore_1.default.instance.deleteComponent(manifest.id, manifest.version);
        throw error;
    });
    ComponentStore_1.default.instance.storeComponent(manifest.id, manifest.version, componentPromise);
    return componentPromise;
}
exports.default = loadComponent;
function _loadComponentRetryStrategy(manifest, currentRetryNumber, maxNumberRetries) {
    if (currentRetryNumber === 1) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentLog, manifest.id, manifest.alias, manifest.version));
    }
    else {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentRetryLog, manifest.id, manifest.alias, currentRetryNumber, maxNumberRetries));
    }
    return _loadComponentImpl(manifest)
        .then(function (component) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentEndLog, manifest.id, manifest.alias, manifest.version));
        return component;
    })
        .catch(function (error) {
        _requireJsLoader.requireDelete(manifest);
        if (currentRetryNumber < maxNumberRetries) {
            return _loadComponentRetryStrategy(manifest, currentRetryNumber + 1, maxNumberRetries);
        }
        else {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentMaxRetriesError, manifest.id, manifest.alias, maxNumberRetries)));
            throw error;
        }
    });
}
function _loadComponentImpl(manifest) {
    try {
        _requireJsLoader.configure(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    var componentDeps = [];
    var pathDeps = [];
    try {
        componentDeps = _loadComponentDependencies(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    try {
        pathDeps = _loadPathDependencies(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    return Promise.all(componentDeps.concat(pathDeps)).then(function (components) {
        return _loadEntryPoint(manifest).then(function (entryPoint) {
            _validateComponentIsNotEmptyOrThrow(entryPoint, manifest);
            return entryPoint;
        });
    }).catch(function (e) {
        var error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentError, manifest.id, manifest.alias, e.message));
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        throw error;
    });
}
function _validateComponentIsNotEmptyOrThrow(component, manifest) {
    var error = undefined;
    if (sp_lodash_subset_1.isEmpty(component)) {
        error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentReturnsEmptyError, manifest.id, manifest.alias));
    }
    var defaultObject = component.default; 
    if (defaultObject && sp_lodash_subset_1.isEmpty(defaultObject) && !defaultObject.prototype) {
        error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentReturnsDefaultEmptyError, manifest.id, manifest.alias));
    }
    if (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        throw error;
    }
}
function _loadComponentDependencies(manifest) {
    var depPromises = [];
    var resources = manifest.loaderConfig.scriptResources;
    var _loop_1 = function (name_1) {
        if (resources[name_1].type === 'component' && !resources[name_1].shouldNotPreload) {
            var moduleConfiguration_1 = resources[name_1];
            var resourceManifest = ManifestStore_1.default.instance.tryGetManifest(moduleConfiguration_1.id, moduleConfiguration_1.version);
            if (resourceManifest) {
                var dep = loadComponent(resourceManifest).catch(function (e) {
                    var error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentDependencyError, name_1, manifest.id, manifest.alias, e.message));
                    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
                    throw error;
                });
                depPromises.push(dep);
            }
            else {
                if (moduleConfiguration_1.failoverPath) {
                    var dep = _requireJsLoader.requireLoad(normalizeName_1.normalizeFailoverPathName(name_1))
                        .catch(function (e) {
                        return _processLoadErrors(manifest, name_1, [ResourceUrlChecker_1.default.checkResourceUrl], sp_core_library_1.Text.format(SPLoader_resx_1.default.loadComponentDependencyFailoverPathError, name_1, moduleConfiguration_1.failoverPath, manifest.id, manifest.alias, e.message));
                    });
                    depPromises.push(dep);
                }
                else {
                    var error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.manifestNotFoundError, moduleConfiguration_1.id, moduleConfiguration_1.version));
                    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
                    depPromises.push(Promise.reject(error));
                }
            }
        }
    };
    for (var name_1 in resources) {
        _loop_1(name_1);
    }
    return depPromises;
}
function _loadPathDependencies(manifest) {
    var resources = manifest.loaderConfig.scriptResources;
    var loadedPathDependencies = new Map();
    for (var name_2 in resources) {
        if ((resources[name_2].type === 'path' || resources[name_2].type === 'localizedPath')
            && !resources[name_2].shouldNotPreload) {
            if (name_2 !== manifest.loaderConfig.entryModuleId) {
                _loadPathDependency(manifest, name_2, loadedPathDependencies);
            }
        }
    }
    return sp_lodash_subset_1.toArray(loadedPathDependencies.values());
}
function _loadPathDependency(manifest, name, loadedPathDependencies) {
    var loadedPathDependency = loadedPathDependencies.get(name);
    if (loadedPathDependency) {
        return loadedPathDependency;
    }
    var qosMonitor = new sp_telemetry_1._QosMonitor(telemetryConstants.loadPathDependencyQosScenarioName);
    var qosExtraData = {
        name: name,
        manifestId: manifest.id,
        version: manifest.version,
        alias: manifest.alias,
        isInternal: manifest.isInternal
    };
    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_1.Text.format(SPLoader_resx_1.default.loadPathDependencyLog, name, manifest.id, manifest.alias));
    var resources = manifest.loaderConfig.scriptResources;
    var pathConfig = resources[name];
    var loadPromise;
    if (pathConfig && pathConfig.globalDependencies) {
        var depPromises = pathConfig.globalDependencies.map(function (dep) { return _loadPathDependency(manifest, dep, loadedPathDependencies); });
        loadPromise = Promise.all(depPromises).then(function () {
            return _requireLoadPathDependency(manifest, name);
        }, function () {
            var error = new Error(sp_core_library_1.Text.format(SPLoader_resx_1.default.loadPathDependencyBlockedByAnotherDependencyError, name, manifest.id, manifest.alias));
            sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
            throw error; 
        });
    }
    else {
        loadPromise = _requireLoadPathDependency(manifest, name);
    }
    loadedPathDependencies.set(name, loadPromise);
    return loadPromise.then(function (load) {
        qosMonitor.writeSuccess(qosExtraData);
        return load;
    }, function (error) {
        qosMonitor.writeUnexpectedFailure(undefined, error, qosExtraData);
        throw error;
    });
}
function _requireLoadPathDependency(manifest, name) {
    return _requireJsLoader.requireLoad(normalizeName_1.default(manifest, name))
        .then(function (module) {
        var globalName = manifest.loaderConfig.scriptResources[name].globalName;
        if (globalName) {
            return window[globalName]; 
        }
        else {
            return module;
        }
    })
        .catch(function (e) {
        return _processLoadErrors(manifest, name, [ResourceUrlChecker_1.default.checkResourceUrl], sp_core_library_1.Text.format(SPLoader_resx_1.default.loadPathDependencyError, manifest.id, manifest.alias, e.message));
    });
}
function _loadEntryPoint(manifest) {
    var entryPointModule = _requireJsLoader.requireLoad(normalizeName_1.default(manifest)).catch(function (e) {
        return _processLoadErrors(manifest, manifest.loaderConfig.entryModuleId, [ResourceUrlChecker_1.default.checkResourceUrl], sp_core_library_1.Text.format(SPLoader_resx_1.default.loadEntryPointError, manifest.id, manifest.alias, e.message));
    });
    return entryPointModule.then(function (module) {
        return _getExportFromModule(manifest, module);
    });
}
function _getExportFromModule(manifest, module) {
    var retValue = module;
    if (manifest.loaderConfig.exportName) {
        retValue = module[manifest.loaderConfig.exportName];
        _requireJsLoader.ensure(normalizeName_1.default(manifest), retValue);
    }
    return retValue;
}
function _buildQosExtraData(manifest) {
    return {
        manifestId: manifest.id,
        version: manifest.version,
        alias: manifest.alias,
        isInternal: manifest.isInternal
    };
}
function _processLoadErrors(manifest, name, errorProcessors, defaultErrorMessage) {
    return Promise.race(errorProcessors.map(function (errorProcessor) { return errorProcessor(manifest, name); }))
        .then(
    function () {
        var error = new Error(defaultErrorMessage);
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
        throw error;
    }, function (e) { throw e; });
}


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var SystemJsLoader_1 = __webpack_require__(78);
var ManifestStore_1 = __webpack_require__(4);
var ComponentStore_1 = __webpack_require__(32);
var normalizeName_1 = __webpack_require__(79);
var ComponentOverrider = (function () {
    function ComponentOverrider() {
    }
    ComponentOverrider.overrideComponent = function (componentId, componentModule) {
        sp_core_library_1.Validate.isNotNullOrUndefined(componentModule, 'componentModule');
        var manifest = ManifestStore_1.default.instance.tryGetManifest(componentId);
        if (!manifest) {
            return;
        }
        var normalizedName = normalizeName_1.default(manifest);
        SystemJsLoader_1.default.instance.ensure(normalizedName, componentModule);
        ComponentStore_1.default.instance.storeComponent(manifest.id, manifest.version, Promise.resolve(componentModule));
    };
    return ComponentOverrider;
}());
exports.default = ComponentOverrider;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_telemetry_1 = __webpack_require__(2);
var SPApplicationLoader_1 = __webpack_require__(120);
var SystemJsLoader_1 = __webpack_require__(78);
var ManifestStore_1 = __webpack_require__(4);
var debugManifestProvider_1 = __webpack_require__(75);
var componentConstants = __webpack_require__(21);
var telemetryConstants = __webpack_require__(6);
var BaseComponentLoader_1 = __webpack_require__(119);
var loadComponent_1 = __webpack_require__(223);
var ComponentOverrider_1 = __webpack_require__(221);
var SPLoader_resx_1 = __webpack_require__(5);
var SPSystemJsComponentLoader = (function (_super) {
    __extends(SPSystemJsComponentLoader, _super);
    function SPSystemJsComponentLoader() {
        var _this = _super.call(this) || this;
        _this._isInitialized = false;
        _this._systemJsLoader = SystemJsLoader_1.default.instance;
        return _this;
    }
    SPSystemJsComponentLoader.prototype.start = function (preloadedData) {
        return this._initialize(preloadedData).then(function () {
            return SPApplicationLoader_1.default.startApplication(preloadedData);
        }).catch(function (error) {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.startLogSource, error);
            throw error;
        });
    };
    SPSystemJsComponentLoader.prototype._initialize = function (preloadedData, bundledComponents) {
        if (bundledComponents === void 0) { bundledComponents = undefined; }
        if (this._isInitialized) {
            return Promise.resolve();
        }
        this._isInitialized = true;
        ManifestStore_1.default.instance.registerPreloadedManifests(preloadedData);
        if (preloadedData.clientSideApplicationId === 'b1ab4aaa-f779-405c-8683-d3a750b5d18d') {
            this._systemJsLoader._baseSystemConfig(SystemJsLoader_1.default.pluginName,  false);
        }
        if (true) {
            __webpack_require__(126).initializeNpmModule();
        }
        if (!bundledComponents) {
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLoaderComponentId, __webpack_require__(31));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spCoreLibraryComponentId, __webpack_require__(0));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLodashSubsetComponentId, __webpack_require__(49));
            ComponentOverrider_1.default.overrideComponent(componentConstants.odspUtilitiesBundleComponentId, __webpack_require__(20));
            ComponentOverrider_1.default.overrideComponent(componentConstants.spTelemetryComponentId, __webpack_require__(2));
        }
        else {
            ComponentOverrider_1.default.overrideComponent(componentConstants.spLoaderComponentId, __webpack_require__(31));
            bundledComponents.forEach(function (value, key) {
                ComponentOverrider_1.default.overrideComponent(key, value);
            });
        }
        return debugManifestProvider_1.loadDebugManifests(this).catch(function () {
        });
    };
    SPSystemJsComponentLoader.prototype.loadScript = function (url, options) {
        sp_core_library_1.Validate.isNonemptyString(url, 'url');
        if (typeof options === 'string') {
            var error = new Error(SPLoader_resx_1.default.loadScriptWithStringError);
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadScriptLogSource, error);
            throw error;
        }
        var globalMetaConfig = {
            meta: {}
        };
        globalMetaConfig.meta[url] = {
            scriptLoad: false
        };
        if (options) {
            if (options.globalExportsName) {
                globalMetaConfig.meta[url] = {
                    format: 'global',
                    exports: options.globalExportsName
                };
            }
        }
        this._systemJsLoader.systemConfig(globalMetaConfig);
        return this._systemJsLoader.systemImport(url);
    };
    SPSystemJsComponentLoader.prototype.loadComponent = function (manifest) {
        return loadComponent_1.default(manifest);
    };
    return SPSystemJsComponentLoader;
}(BaseComponentLoader_1.BaseComponentLoader));
exports.default = SPSystemJsComponentLoader;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var sp_lodash_subset_1 = __webpack_require__(49);
var sp_telemetry_1 = __webpack_require__(2);
var SystemJsLoader_1 = __webpack_require__(78);
var ManifestStore_1 = __webpack_require__(4);
var ComponentStore_1 = __webpack_require__(32);
var telemetryConstants = __webpack_require__(6);
var normalizeName_1 = __webpack_require__(79);
var ResourceUrlChecker_1 = __webpack_require__(125);
var sp_core_library_2 = __webpack_require__(0);
var SPLoader_resx_1 = __webpack_require__(5);
var FIRST_RETRY = 1;
var MAX_NUMBER_RETRIES = 3;
var _systemJsLoader = SystemJsLoader_1.default.instance;
var loadComponentImplEventName = 'loadComponentImpl';
function loadComponent(manifest) {
    sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
    var cachedModule = ComponentStore_1.default.instance.getComponent(manifest.id, manifest.version);
    if (cachedModule) {
        return cachedModule;
    }
    var qosMonitor = new sp_telemetry_1._QosMonitor(telemetryConstants.loadComponentQosScenarioName);
    var qosExtraData = _buildQosExtraData(manifest); 
    var componentPromise = _loadComponentRetryStrategy(manifest, FIRST_RETRY, MAX_NUMBER_RETRIES)
        .then(function (component) {
        qosMonitor.writeSuccess(qosExtraData);
        return component;
    })
        .catch(function (error) {
        qosMonitor.writeUnexpectedFailure(undefined, error, qosExtraData);
        ComponentStore_1.default.instance.deleteComponent(manifest.id, manifest.version);
        throw error;
    });
    ComponentStore_1.default.instance.storeComponent(manifest.id, manifest.version, componentPromise);
    return componentPromise;
}
exports.default = loadComponent;
function _loadComponentRetryStrategy(manifest, currentRetryNumber, maxNumberRetries) {
    if (currentRetryNumber === 1) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentLog, manifest.id, manifest.alias, manifest.version));
    }
    else {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentRetryLog, manifest.id, manifest.alias, currentRetryNumber, maxNumberRetries));
    }
    return _loadComponentImpl(manifest)
        .then(function (component) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentEndLog, manifest.id, manifest.alias, manifest.version));
        return component;
    })
        .catch(function (error) {
        _systemJsLoader.systemDelete(manifest);
        if (currentRetryNumber < maxNumberRetries) {
            return _loadComponentRetryStrategy(manifest, currentRetryNumber + 1, maxNumberRetries);
        }
        else {
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentMaxRetriesError, manifest.id, manifest.alias, maxNumberRetries)));
            throw error;
        }
    });
}
function _loadComponentImpl(manifest) {
    try {
        _systemJsLoader.configure(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, loadComponentImplEventName);
        return Promise.reject(error);
    }
    var componentDeps = [];
    var pathDeps = [];
    try {
        componentDeps = _loadComponentDependencies(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, loadComponentImplEventName);
        return Promise.reject(error);
    }
    try {
        pathDeps = _loadPathDependencies(manifest);
    }
    catch (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, loadComponentImplEventName);
        return Promise.reject(error);
    }
    return Promise.all(componentDeps.concat(pathDeps)).then(function (components) {
        return _loadEntryPoint(manifest).then(function (entryPoint) {
            _validateComponentIsNotEmptyOrThrow(entryPoint, manifest);
            return entryPoint;
        });
    }).catch(function (e) {
        var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentError, manifest.id, manifest.alias, e.message));
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, loadComponentImplEventName);
        throw error;
    });
}
function _validateComponentIsNotEmptyOrThrow(component, manifest) {
    var error = undefined;
    if (sp_lodash_subset_1.isEmpty(component)) {
        error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentReturnsEmptyError, manifest.id, manifest.alias));
    }
    var defaultObject = component.default; 
    if (defaultObject && sp_lodash_subset_1.isEmpty(defaultObject) && !defaultObject.prototype) {
        error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentReturnsDefaultEmptyError, manifest.id, manifest.alias));
    }
    if (error) {
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, loadComponentImplEventName);
        throw error;
    }
}
function _loadComponentDependencies(manifest) {
    var depPromises = [];
    var resources = manifest.loaderConfig.scriptResources;
    var _loop_1 = function (name_1) {
        if (resources[name_1].type === 'component' && !resources[name_1].shouldNotPreload) {
            var moduleConfiguration_1 = resources[name_1];
            var resourceManifest = ManifestStore_1.default.instance.tryGetManifest(moduleConfiguration_1.id, moduleConfiguration_1.version);
            if (resourceManifest) {
                var dep = loadComponent(resourceManifest).catch(function (e) {
                    var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentDependencyError, name_1, manifest.id, manifest.alias, e.message));
                    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
                    throw error;
                });
                depPromises.push(dep);
            }
            else {
                if (moduleConfiguration_1.failoverPath) {
                    var dep = _systemJsLoader.systemImport(normalizeName_1.normalizeFailoverPathName(name_1))
                        .catch(function (e) {
                        return _processSystemImportErrors(manifest, name_1, [ResourceUrlChecker_1.default.checkResourceUrl], sp_core_library_2.Text.format(SPLoader_resx_1.default.loadComponentDependencyFailoverPathError, name_1, moduleConfiguration_1.failoverPath, manifest.id, manifest.alias, e.message));
                    });
                    depPromises.push(dep);
                }
                else {
                    var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.manifestNotFoundError, moduleConfiguration_1.id, moduleConfiguration_1.version));
                    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
                    depPromises.push(Promise.reject(error));
                }
            }
        }
    };
    for (var name_1 in resources) {
        _loop_1(name_1);
    }
    return depPromises;
}
function _loadPathDependencies(manifest) {
    var resources = manifest.loaderConfig.scriptResources;
    var loadedPathDependencies = new Map();
    for (var name_2 in resources) {
        if ((resources[name_2].type === 'path' || resources[name_2].type === 'localizedPath')
            && !resources[name_2].shouldNotPreload) {
            if (name_2 !== manifest.loaderConfig.entryModuleId) {
                _loadPathDependency(manifest, name_2, loadedPathDependencies);
            }
        }
    }
    return sp_lodash_subset_1.toArray(loadedPathDependencies.values());
}
function _loadPathDependency(manifest, name, loadedPathDependencies) {
    var loadedPathDependency = loadedPathDependencies.get(name);
    if (loadedPathDependency) {
        return loadedPathDependency;
    }
    var qosMonitor = new sp_telemetry_1._QosMonitor(telemetryConstants.loadPathDependencyQosScenarioName);
    var qosExtraData = {
        name: name,
        manifestId: manifest.id,
        version: manifest.version,
        alias: manifest.alias,
        isInternal: manifest.isInternal
    };
    sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, sp_core_library_2.Text.format(SPLoader_resx_1.default.loadPathDependencyLog, name, manifest.id, manifest.alias));
    var resources = manifest.loaderConfig.scriptResources;
    var pathConfig = resources[name];
    var loadPromise;
    if (pathConfig && pathConfig.globalDependencies) {
        var depPromises = pathConfig.globalDependencies.map(function (dep) { return _loadPathDependency(manifest, dep, loadedPathDependencies); });
        loadPromise = Promise.all(depPromises).then(function () {
            return _systemImportPathDependency(manifest, name);
        }, function () {
            var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.loadPathDependencyBlockedByAnotherDependencyError, name, manifest.id, manifest.alias));
            sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
            throw error; 
        });
    }
    else {
        loadPromise = _systemImportPathDependency(manifest, name);
    }
    loadedPathDependencies.set(name, loadPromise);
    return loadPromise.then(function (load) {
        qosMonitor.writeSuccess(qosExtraData);
        return load;
    }, function (error) {
        qosMonitor.writeUnexpectedFailure(undefined, error, qosExtraData);
        throw error;
    });
}
function _systemImportPathDependency(manifest, name) {
    return _systemJsLoader.systemImport(normalizeName_1.default(manifest, name)).catch(function (e) {
        return _processSystemImportErrors(manifest, name, [ResourceUrlChecker_1.default.checkResourceUrl], sp_core_library_2.Text.format(SPLoader_resx_1.default.loadPathDependencyError, manifest.id, manifest.alias, e.message));
    });
}
function _loadEntryPoint(manifest) {
    var entryPointModule = _systemJsLoader.systemImport(normalizeName_1.default(manifest)).catch(function (e) {
        return _processSystemImportErrors(manifest, manifest.loaderConfig.entryModuleId, [ResourceUrlChecker_1.default.checkResourceUrl, _checkEntryPointDependenciesError], sp_core_library_2.Text.format(SPLoader_resx_1.default.loadEntryPointError, manifest.id, manifest.alias, e.message));
    });
    return entryPointModule.then(function (module) {
        return _getExportFromModule(manifest, module);
    });
}
function _processSystemImportErrors(manifest, name, errorProcessors, defaultErrorMessage) {
    return Promise.race(errorProcessors.map(function (errorProcessor) { return errorProcessor(manifest, name); }))
        .then(
    function () {
        var error = new Error(defaultErrorMessage);
        sp_telemetry_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message);
        throw error;
    }, function (e) { throw e; });
}
function _checkEntryPointDependenciesError(manifest, name) {
    var dependencies = _systemJsLoader.getDependencies(manifest);
    var resources = manifest.loaderConfig.scriptResources;
    dependencies.forEach(function (depName) {
        if (!resources[depName]) {
            var error = new Error(sp_core_library_2.Text.format(SPLoader_resx_1.default.moduleHasUndeclaredDependencyError, manifest.id, manifest.alias, depName));
            sp_telemetry_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, error);
            throw error;
        }
    });
    return Promise.resolve();
}
function _getExportFromModule(manifest, module) {
    var retValue = module;
    if (manifest.loaderConfig.exportName) {
        retValue = module[manifest.loaderConfig.exportName];
        _systemJsLoader.ensure(normalizeName_1.default(manifest, manifest.loaderConfig.exportName), retValue);
    }
    return retValue;
}
function _buildQosExtraData(manifest) {
    return {
        manifestId: manifest.id,
        version: manifest.version,
        alias: manifest.alias,
        isInternal: manifest.isInternal
    };
}


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sp_core_library_1 = __webpack_require__(0);
var SPLoader_resx_1 = __webpack_require__(5);
var BrowserSupport = (function () {
    function BrowserSupport() {
    }
    BrowserSupport.getBrowserCompatibility = function () {
        var browserInfo = sp_core_library_1._BrowserDetection.getBrowserInformation();
        if (browserInfo.browser === sp_core_library_1._Browser.IE &&
            browserInfo.browserVersion && browserInfo.browserVersion.major <= 9) {
            return {
                supportLevel: sp_core_library_1.BrowserSupportLevel.Blocked,
                warning: SPLoader_resx_1.default.ie9OrOlderNotSupportedError
            };
        }
        if (typeof Headers !== 'undefined' &&
            typeof Headers.prototype.forEach === 'undefined') {
            return {
                supportLevel: sp_core_library_1.BrowserSupportLevel.Blocked,
                warning: undefined
            };
        }
        return {
            supportLevel: sp_core_library_1.BrowserSupportLevel.None,
            warning: undefined
        };
    };
    return BrowserSupport;
}());
exports.default = BrowserSupport;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Uri_1 = __webpack_require__(154);
var Qos_event_1 = __webpack_require__(33);
var EXPIRATION_TOKEN = '_eat_';
var EXPIRATION_TOKEN_SEPARATOR = '_';
// @internalremarks: Note - 'UserPhotoAspx' is defined by a constant UserPhotoKey specified in
// @internalremarks: depot/devmainoverride/sporel/sts/stsom/SitePages/SitePageAlternativeUrlMapBuilder.cs
var USER_PHOTO_KEY = 'UserPhotoAspx';
var DEFAULT_USER_PHOTO_BASE_URL = '/_layouts/15/userphoto.aspx';
var USER_PHOTO_SIZE_PARAM = 'size';
var USER_PHOTO_ACCOUNT_NAME_PARAM = 'accountname';
var _urlTable = {};
var QOS_TRYGETALTERNATIVEURLFAILURE = 'TryGetAlternativeUrlFailure';
/**
 * If an alternative URL is available, then this returns the URL that should be used
 * for rendering the image.  Otherwise, undefined is returned.
 */
function tryGetAlternativeUrl(primaryUrl) {
    try {
        var alternativeUrl = _urlTable && _urlTable[primaryUrl];
        if (!alternativeUrl) {
            return undefined;
        }
        // Check for expired items.
        // Private CDN item will have a query string parameter _eat_=xxxx_yyyyyyyyyy, where xxxx is an expiration
        // time in Epoch format (number of seconds since 1970/1/1).
        // The real URL example is
        // https://privatecdn.sharepointonline.com/msft.spoppe.com/sites/wex/SiteAssets/SitePages/SamplePage/image.jpg
        //   ?_eat_=1480392900_16330f287fe138cea33c424221c6fa1d79e6cdeb470bc0000894645994ba1a14
        //   &_oat_=1480392900_f312136e0ffd87c26165973f042a98dfd40130d4981d6d3fd71643c7e4fdb485
        //   &width=300
        // If the parameter is available in the alternative Url,
        // check whether this is at least 30 seconds out in the future, and return the alternative
        // URL only if still valid. Return undefined otherwise, falling back to the original non-optimized behavior
        // note that the URLs provided by the server always have at least 15 minutes of the valid time, so it is
        // unlikely expired situation will appear too often.
        var uri = new Uri_1.default(alternativeUrl);
        var authToken = uri.getQueryParameter(EXPIRATION_TOKEN);
        if (authToken) {
            var split = authToken.split(EXPIRATION_TOKEN_SEPARATOR);
            var expirationTime = undefined;
            if (split.length === 2) {
                expirationTime = Number(split[0]);
            }
            if (!expirationTime) {
                // hightly unexpected, but logging nevertheless
                var qosEvent = new Qos_event_1.Qos({ name: QOS_TRYGETALTERNATIVEURLFAILURE });
                qosEvent.end({
                    resultType: Qos_event_1.ResultTypeEnum.Failure,
                    resultCode: 'EatParamUnexpectedFormat',
                    extraData: {
                        eatParam: authToken
                    }
                });
                return alternativeUrl;
            }
            // Shift expiration time by 30 seconds to ensure the browser has ample time to fetch the resource
            // before it actually does expire.
            expirationTime -= 30;
            // getTime() returns Epoch time in milliseconds.
            if (Date.now() / 1000 > expirationTime) {
                delete _urlTable[primaryUrl];
                return undefined;
            }
        }
        return alternativeUrl;
    }
    catch (ex) {
        var qosEvent = new Qos_event_1.Qos({ name: QOS_TRYGETALTERNATIVEURLFAILURE });
        qosEvent.end({
            resultType: Qos_event_1.ResultTypeEnum.Failure,
            resultCode: 'Unexpected',
            extraData: {
                error: ex
            }
        });
    }
    return undefined;
}
exports.tryGetAlternativeUrl = tryGetAlternativeUrl;
/**
 * Updates the map by adding the specified entries, overwriting any previous entries
 * with the same key names.
 */
function updateMap(alternativeUrlTable) {
    if (!alternativeUrlTable) {
        return;
    }
    for (var key in alternativeUrlTable) {
        _urlTable[key] = alternativeUrlTable[key];
    }
    ;
}
exports.updateMap = updateMap;
/**
 * For diagnostic purposes, this returns the current map.
 * The key is the primaryUrl, and the value is the alternativeUrl.
 */
function getUrlTable() {
    return _urlTable;
}
exports.getUrlTable = getUrlTable;
/**
 * UserPhoto mapping is auto added into the Alternative URL map when private CDN is enabled
 * and tenant admin configured origin * /userphoto.aspx
 * If CDN is not enabled, the default _layouts/15/userphoto.aspx will be used.
 * @param size Parameter may have value S,L,M. If none or other is provided, S will be used by default.
 */
function getUserPhotoUrl(accountName, size) {
    var userPhotoBaseUrl = tryGetAlternativeUrl(USER_PHOTO_KEY) || DEFAULT_USER_PHOTO_BASE_URL;
    var sizeLetter;
    switch (size) {
        case 2 /* Medium */:
            sizeLetter = 'M';
            break;
        case 3 /* Large */:
            sizeLetter = 'L';
            break;
        default:
            // Default to small if size is not provided. Server will assume small either way, but having the
            // parameter explicitly will reduce variability in CDN, and will increase probability of the cache hit.
            sizeLetter = 'S';
    }
    var userPhotoUri = new Uri_1.default(userPhotoBaseUrl);
    userPhotoUri.setQueryParameter(USER_PHOTO_SIZE_PARAM, sizeLetter);
    // empty accountName will resolve to the default doughboy picture
    userPhotoUri.setQueryParameter(USER_PHOTO_ACCOUNT_NAME_PARAM, accountName || '');
    return userPhotoUri.toString();
}
exports.getUserPhotoUrl = getUserPhotoUrl;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var EventBase_1 = __webpack_require__(22);
var Manager_1 = __webpack_require__(16);
var Beacon_event_1 = __webpack_require__(53);
var ErrorHelper_1 = __webpack_require__(9);
var BeforeUnload_1 = __webpack_require__(227);
var PlatformDetection_1 = __webpack_require__(82);
var StringHelper_1 = __webpack_require__(23);
var ARIA_QOS_NAME = "AriaBeacon";
var ariaTelemetry;
var logger;
var config = {
    logStartEvents: false,
    Init: init
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = config;
function init(tenantToken, context, aria) {
    try {
        ariaTelemetry = aria;
        config.logStartEvents = true;
        var platformDetection = new PlatformDetection_1.default();
        ariaTelemetry.LogManager.initialize(tenantToken);
        logger = new ariaTelemetry.Logger();
        var semanticContext = logger.getSemanticContext();
        var contextMap = semanticContext['contextMap'];
        contextMap.Add("AppInfo.Session", context.session);
        semanticContext.setAppVersion(context.version);
        contextMap.Add("AppInfo.Manifest", context.manifest);
        semanticContext.setUserLanguage(context.market || '');
        semanticContext.setUserId(context.userId);
        semanticContext.setDeviceOsName(platformDetection.osName);
        semanticContext.setDeviceOsVersion(platformDetection.osVersion);
        BeforeUnload_1.default.init();
        BeforeUnload_1.default.registerHandler(function (unload) {
            if (unload) {
                ariaTelemetry.LogManager.flush(null);
            }
            return null;
        });
        var loggerContext = {
            AccountType: EventBase_1.AccountType[context.accountType],
            Environment: context.environment,
            Workload: context.workload,
            IsAuthenticated: context.isAuthenticated ? 1 : 0,
            BrowserName: platformDetection.browserName,
            BrowserMajVer: platformDetection.browserMajor,
            BrowserMinVer: platformDetection.browserMinor,
            BrowserUserAgent: platformDetection.userAgent,
            BrowserIsMobile: platformDetection.isMobile,
            SiteSubscriptionId: context.siteSubscriptionId || ""
        };
        if (context.farmLabel) {
            loggerContext.FarmLabel = context.farmLabel;
        }
        for (var key in loggerContext) {
            logger.setContext(key, loggerContext[key]);
        }
        // Listen to aria beaconing and send qos events to monitor its success rate
        ariaTelemetry.LogManager.addCallbackListener(function (isSuccess, statusCode, tenantToken, events) {
            new Beacon_event_1.Beacon({
                name: ARIA_QOS_NAME,
                retryCount: 0,
                totalRetries: 0,
                eventCount: events ? events.length : 0
            }).end({
                success: isSuccess === 0,
                status: statusCode + ''
            });
            if (true) {
                // Display errors if the aria logger is failing to log
                if (isSuccess !== 0) {
                    ErrorHelper_1.default.log(new Error("Aria logger failed with status code " + statusCode));
                }
            }
        });
        Manager_1.Manager.addLogHandler(safeLogEvent).forEach(safeLogEvent);
    }
    catch (e) {
        if (e instanceof ariaTelemetry.Exception) {
            e = new Error("Aria error: " + e.toString());
        }
        ErrorHelper_1.default.log(e);
    }
}
function safeLogEvent(event) {
    // Try/catch individual events so that one bad event doesn't cause the rest to fail to get logged
    try {
        logEvent(event);
    }
    catch (exception) {
        var error = void 0;
        if (exception instanceof ariaTelemetry.Exception) {
            error = new Error("Aria error: " + exception.toString());
        }
        if (!exception || !exception.handled) {
            // Only log the exception if it was not already logged before
            ErrorHelper_1.default.log(error || exception);
        }
    }
}
function logEvent(event) {
    if (event.enabled && (event.eventType !== EventBase_1.ClonedEventType.Start || config.logStartEvents) &&
        !(Beacon_event_1.Beacon.isTypeOf(event) && event.data && event.data.name === ARIA_QOS_NAME)) {
        var eventProperties = new ariaTelemetry.EventProperties();
        var values = {
            "CorrelationVector": event.vector.toString(),
            "ValidationErrors": event.validationErrors,
            "WebLog_FullName": event.eventName,
            "WebLog_EventType": EventBase_1.ClonedEventType[event.eventType]
        };
        if (event.eventType === EventBase_1.ClonedEventType.End) {
            values['Duration'] = event.endTime - event.startTime;
        }
        var names = event.eventName.split(',');
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_1 = names_1[_i];
            if (name_1) {
                values["WebLog_Type_" + name_1] = 1;
            }
        }
        var data = event.data;
        if (data) {
            for (var field in data) {
                var value = data[field];
                if (value === undefined || value === null) {
                    continue;
                }
                var propertyMetadata = event.metadata[field];
                if (propertyMetadata) {
                    var loggingName = propertyMetadata.isPrefixingDisabled ? StringHelper_1.capitalize(field) : StringHelper_1.capitalize(propertyMetadata.definedInName) + "_" + field;
                    var type = propertyMetadata.type;
                    if (type === 4 /* Object */) {
                        for (var subField in value) {
                            if (value[subField] !== undefined) {
                                values[loggingName + "_" + subField.replace('.', '_')] = value[subField];
                            }
                        }
                    }
                    else {
                        values[loggingName] = type === 6 /* Enum */ ? propertyMetadata.typeRef[value] : value;
                    }
                }
            }
        }
        eventProperties.name = "ev_" + names[names.length - 2];
        setProperties(eventProperties, values);
        logger.logEvent(eventProperties);
    }
}
function setProperties(properties, values) {
    // We are getting a lot of errorCode 3 aria errors complaining about invalid property keys
    // In order to fix the problem we need to know what the problematic keys are
    var key;
    try {
        for (key in values) {
            properties.setProperty(key, values[key]);
        }
    }
    catch (exception) {
        var errorCode = void 0;
        var error = void 0;
        if (exception instanceof ariaTelemetry.Exception) {
            errorCode = exception.ErrorCode();
            error = new Error("Aria error: " + exception.toString());
        }
        if (error) {
            // If it is an aria error that is thrown then log it with the error code and the key we tried to set
            exception.handled = true;
            ErrorHelper_1.default.logError(error, {
                errorCode: errorCode,
                propertyKey: key
            });
        }
        // Regardless of what kind of error it was, rethrow the error so we don't try to log the event
        throw exception;
    }
}


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var ErrorHelper_1 = __webpack_require__(9);
var Async_1 = __webpack_require__(15);
var BeforeUnload = (function () {
    function BeforeUnload() {
        this._localHandlers = [];
    }
    BeforeUnload.init = function () {
        var _this = this;
        if (!this._initialized) {
            this._initialized = true;
            // Wire up before unload
            this._originalBeforeUnload = window.onbeforeunload;
            window.onbeforeunload = window['__onbeforeunload'] = function (ev) {
                return _this._handleBeforeUnload(ev);
            };
        }
    };
    BeforeUnload.registerHandler = function (callback) {
        this._handlers.push(callback);
    };
    BeforeUnload.unRegisterHandler = function (callback) {
        for (var x = 0; x < this._handlers.length; x++) {
            if (this._handlers[x] === callback) {
                this._handlers.splice(x, 1);
                break;
            }
        }
    };
    BeforeUnload.dispose = function () {
        if (this._originalBeforeUnload) {
            window.onbeforeunload = this._originalBeforeUnload;
        }
        else {
            window.onbeforeunload = null;
        }
    };
    BeforeUnload._handleBeforeUnload = function (ev) {
        var response = undefined;
        if (!this._allowNavs) {
            for (var x = 0; x < this._handlers.length; x++) {
                try {
                    response = this._handlers[x](true);
                    if (response) {
                        break;
                    }
                }
                catch (e) {
                    ErrorHelper_1.default.log(e);
                }
            }
            if (!response && this._originalBeforeUnload) {
                try {
                    response = this._originalBeforeUnload(ev);
                }
                catch (e) {
                    ErrorHelper_1.default.log(e);
                }
            }
        }
        // Make sure the response is undefined so ie will not block
        return response ? response : undefined;
    };
    BeforeUnload.prototype.registerHashNavDialogCallback = function (callback) {
        this._hashNavDialogCallback = callback;
    };
    BeforeUnload.prototype.allowHashNav = function (allowNavCallback, disallowNavCallback) {
        var response = undefined;
        if (!BeforeUnload._isDialogOpen && !BeforeUnload._allowNavs) {
            for (var x = 0; x < BeforeUnload._handlers.length; x++) {
                try {
                    response = BeforeUnload._handlers[x](false);
                    if (response) {
                        break;
                    }
                }
                catch (e) {
                    ErrorHelper_1.default.log(e);
                }
            }
            if (response) {
                BeforeUnload._isDialogOpen = true;
                this._hashNavDialogCallback(response)
                    .then(function () {
                    BeforeUnload._isDialogOpen = false;
                    BeforeUnload._allowNavs = true;
                    // Dont block until we have a new stack
                    if (!BeforeUnload._blockNavsAgainId) {
                        BeforeUnload._blockNavsAgainId = BeforeUnload._async.setImmediate(function () {
                            BeforeUnload._allowNavs = false;
                            BeforeUnload._blockNavsAgainId = null;
                        });
                    }
                    if (allowNavCallback) {
                        allowNavCallback();
                    }
                }, function () {
                    BeforeUnload._isDialogOpen = false;
                    if (disallowNavCallback) {
                        disallowNavCallback();
                    }
                });
            }
        }
        return !response && !BeforeUnload._isDialogOpen;
    };
    BeforeUnload.prototype.registerHandler = function (callback) {
        this._localHandlers.push(callback);
        BeforeUnload.registerHandler(callback);
    };
    BeforeUnload.prototype.unRegisterHandler = function (callback) {
        for (var x = 0; x < this._localHandlers.length; x++) {
            if (this._localHandlers[x] === callback) {
                this._localHandlers.splice(x, 1);
                break;
            }
        }
        BeforeUnload.unRegisterHandler(callback);
    };
    BeforeUnload.prototype.dispose = function () {
        // Clean up any hanging handlers
        for (var _i = 0, _a = this._localHandlers; _i < _a.length; _i++) {
            var handler = _a[_i];
            BeforeUnload.unRegisterHandler(handler);
        }
    };
    return BeforeUnload;
}());
BeforeUnload._handlers = [];
BeforeUnload._async = new Async_1.default();
BeforeUnload._initialized = false;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BeforeUnload;
BeforeUnload.init();


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Scope_1 = __webpack_require__(149);
var Resources_1 = __webpack_require__(255);
/**
 * Base class for lifetime-managed, scoped components.
 *
 * Many web components ultimately need to set up subscriptions to events,
 * manage HTML elements, wait on asychronous activities, and clean up
 * loaded state. The `Component` base class provides a way to create a hierarchy
 * of objects with lifetime management and automatic resource scoping.
 *
 * `Component` combines the benefits of `ResourceScope` and `Scope` into a single
 *  package for convenience.
 *
 * If a component-like class needs the benefits of lifetime management but cannot
 * extend `Component`, consider wrapping a `Scope` and a `ResourceScope` in order
 * to create child components.
 *
 * @export
 * @class Component
 * @implements {IDisposable}
 *
 * @example
 *  export interface ISearchServiceParams extends IComponentParams {
 *      searchMode: SearchMode;
 *  }
 *
 *  export interface ISearchDependencies extends IComponentDependencies {
 *      context: IContext
 *      DataRequestor?: typeof DataRequestor;
 *  }
 *
 *  export default class SearchService extends Component {
 *      public static readonly dependencies: IResourceDependencies<ISearchDependencies> = {
 *          ...Component.dependencies,
 *          context: contextKey
 *      }
 *
 *      private _dataRequestor: DataRequestor;
 *      private _context: IContext;
 *      private _searchMode: SearchMode;
 *
 *      constructor(params: ISearchServiceParams, dependencies: ISearchServiceDependencies) {
 *          super(params, dependencies);
 *
 *          const {
 *              searchMode
 *          } = params;
 *
 *          const {
 *              context
 *              DataRequestor: dataRequestorType // This parameter is only used in unit tests
 *          } = dependencies;
 *
 *          this._searchMode = searchMode;
 *
 *          this._context = context;
 *
 *          this._dataRequestor = new (this.child(dataRequestorType))();
 *      }
 *
 *      public search(options: ISearchOptions): Promise<ISearchResult> {
 *          return this._dataRequestor.getData(...).then((data: ISearchResponse) => {
 *              return this._processResponse(data);
 *          });
 *      }
 *  }
 */
var Component = (function () {
    /**
     * Creates an instance of Component.
     * In general, derived classes should invoke `super(params, dependencies)`, supplying both
     * `params` and `dependencies` to the `Component` class.
     * When creating a new instance of a derived component, use either
     * `new (resources.injected(MyComponent))()`
     * when outside a `Component` or
     * `new (this.child(MyComponent))()`
     * when inside a `Component`. This will ensure that resources are properly passed and lifetimes
     * are properly managed.
     *
     * @param {IComponentParams} [params={}] Optional params to control behaviors of this class.
     * In general, classes which extend components
     * @param {IComponentDependencies} [dependencies={}] Optional dependencies to override types consumed by this class.
     * `dependencies` is intended for use during unit testing, to override types consumed outside of resourcing.
     * Most dependency injection should be done using `ResourceScope`.
     */
    function Component(params, dependencies) {
        if (params === void 0) { params = {}; }
        if (dependencies === void 0) { dependencies = {}; }
        var _a = this.resources, resources = _a === void 0 ? (dependencies.resources ?
            // If the resource scope comes via dependencies, then it might not be unique to this component instance.
            // To be safe, create a new child resource scope for resource exposures.
            new Resources_1.ResourceScope(dependencies.resources) :
            params.resources) : _a;
        this.resources = resources;
        this._Component_scope = new Scope_1.default();
    }
    Object.defineProperty(Component.prototype, "scope", {
        /**
         * Gets the lifetime scope manager for this component.
         * In general, use `new (this.child(Type))()` to create child components
         * with proper lifetime management.
         * However, `this.scope` can be used to attach arbitrary disposable objects
         * to bind their lifetimes to the current component instance.
         *
         * @protected
         * @type {Scope}
         */
        get: function () {
            return this._Component_scope;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "isDisposed", {
        /**
         * Determines whether or not this component has been disposed.
         *
         * @readonly
         * @protected
         * @type {boolean}
         */
        get: function () {
            return this.scope.isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Component.prototype.dispose = function () {
        this._Component_scope.dispose();
    };
    /**
     * Produces a constructor for a type which injects instances
     * with this component's current resources and binds them
     * to this component's lifetime. New code should prefer `this.child`.
     *
     * @protected
     * @template T
     * @param {T} type
     * @returns {T}
     */
    Component.prototype.managed = function (type) {
        if (this.resources) {
            type = this.resources.injected(type);
        }
        return this.scope.attached(type);
    };
    Component.prototype.child = function (keyOrType) {
        var type;
        if (keyOrType instanceof Resources_1.ResourceKey) {
            type = this.resources.consume(keyOrType);
        }
        else if (this.resources) {
            type = this.resources.injected(keyOrType, {
                injectChildResourceScope: true
            });
        }
        else {
            type = keyOrType;
        }
        return this.scope.attached(type);
    };
    return Component;
}());
Component.dependencies = {
    resources: Resources_1.resourceScopeKey
};
exports.Component = Component;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Component;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

/**
 * This datasource makes a call to the Acronyms and Colors service and returns an IAcronymColor object.
 */
var SiteHeaderLogoAcronym = (function () {
    /**
     * @constructor
     */
    function SiteHeaderLogoAcronym(hostSettings) {
        this._hostSettings = hostSettings;
    }
    /**
     * Given a site name, return an URL to a REST endpoint where the site logo acronym and color information can be retrieved from.
     * The REST endpoint is through the GetAcronymsAndColors API.
     * Note: API takes in additional optional arguments like lcid, which as of this writing this method doesn't support.
     *       Please extend as appropriate.
     *
     * @param {string} siteName Name of the site.
     * @returns { string} the REST endpoint relative URL.
     */
    SiteHeaderLogoAcronym.prototype.getAcronymRESTUrl = function (siteName) {
        return this._hostSettings.webServerRelativeUrl + ("/_api/sphome/GetAcronymsAndColors?labels=[{Text:" + encodeURIComponent('"' + siteName + '"') + "}]");
    };
    SiteHeaderLogoAcronym.prototype.getAcronymColor = function (responseText) {
        //parse the responseText
        var rtnObj = { acronym: undefined, color: undefined };
        try {
            var response = JSON.parse(responseText);
            var responseResult = response.d.GetAcronymsAndColors.results[0];
            rtnObj.acronym = responseResult.Acronym;
            rtnObj.color = responseResult.Color;
        }
        catch (e) {
            // try xml parsing
            var parser = this._parseFn();
            var elements = void 0;
            var xmlDoc = parser(responseText);
            if (elements = xmlDoc.getElementsByTagName("element")) {
                var element = elements[0];
                for (var i = 0; i < element.childNodes.length; i++) {
                    switch (element.childNodes[i].nodeName) {
                        case 'Acronym':
                            rtnObj.acronym = element.childNodes[i].nodeValue;
                            break;
                        case 'Color':
                            rtnObj.color = element.childNodes[i].nodeValue;
                            break;
                    }
                }
            }
        }
        return rtnObj;
    };
    /**
     * Returns an XML parser.
     */
    SiteHeaderLogoAcronym.prototype._parseFn = function () {
        var parseXml;
        if (DOMParser) {
            parseXml = function (xmlStr) {
                return (new DOMParser()).parseFromString(xmlStr, "text/xml");
            };
        }
        else if (ActiveXObject &&
            new ActiveXObject("Microsoft.XMLDOM")) {
            parseXml = function (xmlStr) {
                var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(xmlStr);
                return xmlDoc;
            };
        }
        else {
            throw new Error("No XML parser found");
        }
        return parseXml;
    };
    return SiteHeaderLogoAcronym;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SiteHeaderLogoAcronym;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var StringHelper_1 = __webpack_require__(23);
var MembersList_1 = __webpack_require__(231);
/**
 * This datasource makes server call to get group related information.
 */
var GroupDataSource = (function () {
    /**
     * @constructor
     */
    function GroupDataSource(hostSettings) {
        this._hostSettings = hostSettings;
    }
    /**
     * Get REST Url to get group properties
     * @param {string} Id (Guid) of the group
     * @returns the REST url that can be used to get group basic properties
     */
    GroupDataSource.prototype.getGroupBasicPropertiesRESTUrl = function (groupId, withMembership) {
        return this._getRESTUrl(StringHelper_1.format(withMembership ? GroupDataSource.groupBasicPropertiesWithMembershipUrlTemplate : GroupDataSource.groupBasicPropertiesUrlTemplate, groupId), 'SP.Directory.DirectorySession');
    };
    GroupDataSource.prototype.getGroupBasicProperties = function (responseText) {
        var group = {};
        try {
            var response = JSON.parse(responseText);
            if (response.d) {
                group = this._copyGroup(response.d);
                this._calculateMissingGroupProperties(group, group.id);
            }
        }
        catch (e) {
            group = {};
        }
        return group;
    };
    GroupDataSource.prototype._getRESTUrl = function (op, ns) {
        return this._hostSettings.webServerRelativeUrl + '/_api/' + ns + '/' + op;
    };
    /**
     * Given response from the server convert it into a group
     */
    GroupDataSource.prototype._copyGroup = function (src) {
        var groupInfo = {};
        if (src.description) {
            groupInfo.description = src.description;
        }
        if (src.alias) {
            groupInfo.alias = src.alias;
        }
        if (src.displayName) {
            groupInfo.name = src.displayName;
        }
        if (src.principalName) {
            groupInfo.principalName = src.principalName;
        }
        if (src.creationTime) {
            groupInfo.creationTime = src.creationTime;
        }
        if (src.pictureUrl) {
            groupInfo.pictureUrl = src.pictureUrl;
        }
        if (src.inboxUrl) {
            groupInfo.inboxUrl = src.inboxUrl;
        }
        if (src.calendarUrl) {
            groupInfo.calendarUrl = src.calendarUrl;
        }
        if (src.documentsUrl) {
            groupInfo.filesUrl = src.documentsUrl;
        }
        if (src.siteUrl) {
            groupInfo.sharePointUrl = src.siteUrl;
        }
        if (src.editGroupUrl) {
            groupInfo.editUrl = src.editGroupUrl;
        }
        if (src.peopleUrl) {
            groupInfo.membersUrl = src.peopleUrl;
        }
        if (src.notebookUrl) {
            groupInfo.notebookUrl = src.notebookUrl;
        }
        if (src.isPublic) {
            groupInfo.isPublic = src.isPublic;
        }
        if (src.mail) {
            groupInfo.mail = src.mail;
        }
        // TODO: remove this once all branches get lowerCamelCase changelist
        if (src.Description) {
            groupInfo.description = src.Description;
        }
        if (src.Alias) {
            groupInfo.alias = src.Alias;
        }
        if (src.DisplayName) {
            groupInfo.name = src.DisplayName;
        }
        if (src.PrincipalName) {
            groupInfo.principalName = src.PrincipalName;
        }
        if (src.CreationTime) {
            groupInfo.creationTime = src.CreationTime;
        }
        if (src.PictureUrl) {
            groupInfo.pictureUrl = src.PictureUrl;
        }
        if (src.InboxUrl) {
            groupInfo.inboxUrl = src.InboxUrl;
        }
        if (src.CalendarUrl) {
            groupInfo.calendarUrl = src.CalendarUrl;
        }
        if (src.DocumentsUrl) {
            groupInfo.filesUrl = src.DocumentsUrl;
        }
        if (src.SiteUrl) {
            groupInfo.sharePointUrl = src.SiteUrl;
        }
        if (src.EditGroupUrl) {
            groupInfo.editUrl = src.EditGroupUrl;
        }
        if (src.PeopleUrl) {
            groupInfo.membersUrl = src.PeopleUrl;
        }
        if (src.NotebookUrl) {
            groupInfo.notebookUrl = src.NotebookUrl;
        }
        if (src.IsPublic) {
            groupInfo.isPublic = src.IsPublic;
        }
        if (src.Mail) {
            groupInfo.mail = src.Mail;
        }
        if (src.members || src.owners) {
            this._copyMembership(src);
        }
        return groupInfo;
    };
    /**
     *  Remove once federated directory makes appropriate fixes
     */
    GroupDataSource.prototype._calculateMissingGroupProperties = function (group, groupId) {
        if (!group.creationTime) {
            group.creationTime = Date.now();
        }
        if (!group.pictureUrl) {
            group.pictureUrl = group.pictureUrl.replace("EWS/Exchange.asmx/s/GetUserPhoto", "OWA/service.svc/s/GetPersonaPhoto");
        }
        if (!group.profileUrl) {
            group.profileUrl = this._getProfileUrl(groupId);
        }
        if (!group.notebookUrl && groupId) {
            group.notebookUrl = this._getGroupStatusNotebookUrl(groupId);
        }
    };
    GroupDataSource.prototype._getProfileUrl = function (id) {
        return this._hostSettings.siteAbsoluteUrl + StringHelper_1.format(GroupDataSource.groupStatusPageTemplate, id, 'profile');
    };
    GroupDataSource.prototype._getGroupStatusNotebookUrl = function (id) {
        return this._hostSettings.siteAbsoluteUrl + StringHelper_1.format(GroupDataSource.groupStatusPageTemplate, id, 'notebook');
    };
    GroupDataSource.prototype._copyMembership = function (src) {
        var membershipInfo = {};
        if (src.members && src.members.results) {
            var membersList = this._copyMembers(src.members.results);
            membershipInfo.membersList = membersList;
        }
        if (src.owners && src.owners.results) {
            var ownersList = this._copyMembers(src.owners.results);
            membershipInfo.ownersList = ownersList;
        }
        return membershipInfo;
    };
    /**
     * Copy from member list json to memberList object
     */
    GroupDataSource.prototype._copyMembers = function (src) {
        var membersList = new MembersList_1.default();
        var members = new Array();
        for (var i = 0; i < src.length; i++) {
            var member = this._copyMember(src[i]);
            members.push(member);
        }
        membersList.members = members;
        membersList.totalCount = members.length;
        return membersList;
    };
    /**
     * Copy from json to IPerson object
     */
    GroupDataSource.prototype._copyMember = function (src) {
        var user = {};
        if (src.alias) {
            user.sip = src.alias;
        }
        if (src.id) {
            user.userId = src.id;
        }
        if (src.principalName) {
            user.email = src.principalName;
        }
        if (src.displayName) {
            user.name = src.displayName;
        }
        if (src.title) {
            user.job = src.title;
        }
        if (src.pictureUrl) {
            user.image = src.pictureUrl;
        }
        if (src.profilePage) {
            user.profilePage = src.profilePage;
        }
        return user;
    };
    return GroupDataSource;
}());
/**
 * Static members
 */
// Url templates
GroupDataSource.groupBasicPropertiesUrlTemplate = 'Group(\'{0}\')?$select=PrincipalName,DisplayName,Alias,Description,InboxUrl,CalendarUrl,DocumentsUrl,SiteUrl,EditGroupUrl,PictureUrl,PeopleUrl,NotebookUrl,Mail,IsPublic,CreationTime';
GroupDataSource.groupBasicPropertiesWithMembershipUrlTemplate = 'Group(\'{0}\')?$expand=Members,Owners&$select=PrincipalName,DisplayName,Alias,Description,InboxUrl,CalendarUrl,DocumentsUrl,SiteUrl,EditGroupUrl,PictureUrl,PeopleUrl,NotebookUrl,Mail,IsPublic,CreationTime,Members/PrincipalName,Members/Id,Members/DisplayName,Members/PictureUrl,Owners/PrincipalName,Owners/Id,Owners/DisplayName,Owners/PictureUrl';
GroupDataSource.groupStatusPageTemplate = '_layouts/15/groupstatus?id={0}&target={1}';
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GroupDataSource;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

;
var MembersList = (function () {
    function MembersList() {
        this.totalCount = 0;
        this.members = new Array();
    }
    /**
     * Add given user to the members list of the group
     */
    MembersList.prototype.addUserToList = function (user) {
        this.members.unshift(user);
        this.totalCount++;
    };
    /**
     * Remove user from members list of a group
     */
    MembersList.prototype.removeUserFromList = function (user) {
        var indexToRemove = -1; // not found by default
        for (var i = 0; i < this.members.length; i++) {
            if (this.members[i].userId === user.userId) {
                indexToRemove = i; // find the index
            }
        }
        // If user exists in members list then remove it
        if (indexToRemove >= 0) {
            this.members.splice(indexToRemove, 1);
            this.totalCount--;
        }
    };
    return MembersList;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MembersList;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var DatetimeResx = __webpack_require__(233);
var Locale_1 = __webpack_require__(132);
var StringHelper_1 = __webpack_require__(23);
// this is the difference between the .net ticks and the javascript Date ticks
var TICKS_CONVERSION_CONSTANT = 62135596800000;
// number of milliseconds for the given timespan
// copied from SPRelativeDateTime, including 32 days to a month
var ONE_SECOND = 1000;
var ONE_MINUTE = 60 * ONE_SECOND;
var TWO_MINUTES = 2 * ONE_MINUTE;
var ONE_HOUR = 60 * ONE_MINUTE;
var TWO_HOURS = 2 * ONE_HOUR;
var ONE_DAY = 24 * ONE_HOUR;
var TWO_DAYS = 2 * ONE_DAY;
var ONE_WEEK = 7 * ONE_DAY;
var ONE_MONTH = 32 * ONE_DAY;
var _getLocale;
var supportsTimeZoneDateOptions;
var shortDateFormat;
var shortTimeFormat;
var shortDateFormatUTC;
var shortTimeFormatUTC;
var formatShortDate;
var formatShortTime;
var formatShortDateUTC;
var formatShortTimeUTC;
/**
 * Convert a date-time string to a JavaScript Date object, for IE8 compat.
 *  Modern browsers and IE9+ can just take the string directly to the Date constructor.
 *  Format is: 1999-12-31T12:34:56.0000000Z
 *  Trailing Z indicates UTC timezone, otherwise it uses the browser's time zone.
 */
function iso8601DateTimeToJsDate(dateTime) {
    'use strict';
    // note that Date.parse() doesn't work for this format in IE8 either
    var isUTC = false;
    if (dateTime.toUpperCase().indexOf('Z') === dateTime.length - 1) {
        isUTC = true;
    }
    var timeValues = dateTime.split(/[^0-9]/);
    if (timeValues.length < 6) {
        return; // error
    }
    // note that Date 0-indexes months
    if (!isUTC) {
        return new Date(Number(timeValues[0]), Number(timeValues[1]) - 1, Number(timeValues[2]), Number(timeValues[3]), Number(timeValues[4]), Number(timeValues[5]));
    }
    else {
        return new Date(Date.UTC(Number(timeValues[0]), Number(timeValues[1]) - 1, Number(timeValues[2]), Number(timeValues[3]), Number(timeValues[4]), Number(timeValues[5])));
    }
}
exports.iso8601DateTimeToJsDate = iso8601DateTimeToJsDate;
/**
 * Get a string like "X minutes ago" that reflects the time elapsed since the input time.
 * Only works for past times, future times just return a browser-determined localized time string.
 */
function getRelativeDateTimeStringPast(pastTime, startWithLowerCase) {
    'use strict';
    if (startWithLowerCase === void 0) { startWithLowerCase = false; }
    var timespan = Date.now() - pastTime.getTime(); // time elapsed in ms
    if (timespan < -5 * ONE_MINUTE) {
        return pastTime.toLocaleDateString(Locale_1.default.language);
    }
    else if (timespan < ONE_MINUTE) {
        // "Less than a minute ago"
        return startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_LessThanAMinute_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_LessThanAMinute;
    }
    else if (timespan < TWO_MINUTES) {
        // "About a minute ago"
        return startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAMinute_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAMinute;
    }
    else if (timespan < ONE_HOUR) {
        // "{0} minutes ago"
        var minutes = Math.floor(timespan / ONE_MINUTE);
        return StringHelper_1.getLocalizedCountValue(DatetimeResx.strings.RelativeDateTime_XMinutes, DatetimeResx.strings.RelativeDateTime_XMinutesIntervals, minutes).replace("{0}", String(minutes));
    }
    else if (timespan < TWO_HOURS) {
        // "About an hour ago"
        return startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAnHour_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAnHour;
    }
    else if (timespan < ONE_DAY) {
        // "{0} hours ago"
        var hours = Math.floor(timespan / ONE_HOUR);
        return StringHelper_1.getLocalizedCountValue(DatetimeResx.strings.RelativeDateTime_XHours, DatetimeResx.strings.RelativeDateTime_XHoursIntervals, hours).replace("{0}", String(hours));
    }
    else if (timespan < TWO_DAYS) {
        // "Yesterday at {0}"
        return startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_YesterdayAndTime_StartWithLowerCase.replace("{0}", pastTime.toLocaleTimeString(Locale_1.default.language)) :
            DatetimeResx.strings.RelativeDateTime_YesterdayAndTime.replace("{0}", pastTime.toLocaleTimeString(Locale_1.default.language));
    }
    else if (timespan < ONE_MONTH) {
        // "{0} days ago" (in the past month-ish)
        var days = Math.floor(timespan / ONE_DAY);
        return StringHelper_1.getLocalizedCountValue(DatetimeResx.strings.RelativeDateTime_XDays, DatetimeResx.strings.RelativeDateTime_XDaysIntervals, days).replace("{0}", String(days));
    }
    // Any other time, just return the regular full original time
    return pastTime.toLocaleDateString(Locale_1.default.language); // browser-determined localized date (no time)
}
exports.getRelativeDateTimeStringPast = getRelativeDateTimeStringPast;
/**
 * This is a modified implementation of DateTime.GetRelativeDateTimeStringPast(...).
 * The differences here are as follows:
 *      (1) The time string for yesterday does not include the seconds
 *      (2) Instead of showing 'X days ago' for dates older than a month, default to showing the full date
 *      (3) The full date will also include the time (also without seconds)
 */
function getRelativeDateTimeStringPastWithHourMinute(pastTime) {
    'use strict';
    var timespan = Date.now() - pastTime.getTime(); // time elapsed in ms
    var date = pastTime.toLocaleDateString(Locale_1.default.language); // browser-determined localized date
    var time = pastTime.toLocaleTimeString(Locale_1.default.language, { hour: 'numeric', minute: '2-digit' }); //time without seconds
    if (timespan < ONE_DAY) {
        return getRelativeDateTimeStringPast(pastTime);
    }
    else if (timespan < TWO_DAYS) {
        // "Yesterday at {0}" without seconds
        return StringHelper_1.format(DatetimeResx.strings.RelativeDateTime_YesterdayAndTime, time);
    }
    // Any other time, just return the regular full original date with time, without seconds
    return StringHelper_1.format(DatetimeResx.strings.DateTime_DateAndTime, date, time);
}
exports.getRelativeDateTimeStringPastWithHourMinute = getRelativeDateTimeStringPastWithHourMinute;
/**
 * True if the date is on or between the first and last day of the current week. This uses the Date function getDay()
 * which returns the day of the week for the specified date according to local time, where 0 represents Sunday.
 */
function isThisWeek(pastTime) {
    'use strict';
    var today = new Date();
    var start = new Date(today.getTime() - today.getDay() * ONE_DAY);
    var end = new Date(start.getTime() + ONE_WEEK - ONE_DAY);
    var isThisWeek = (start.getTime() <= pastTime.getTime() && pastTime.getTime() <= end.getTime());
    return isThisWeek;
}
exports.isThisWeek = isThisWeek;
/**
 * True if the date is on or between the first and last day of the previous week. This uses the Date function getDay()
 * which returns the day of the week for the specified date according to local time, where 0 represents Sunday.
 */
function isLastWeek(pastTime) {
    'use strict';
    var today = new Date();
    var start = new Date(today.getTime() - today.getDay() * ONE_DAY - ONE_WEEK);
    var end = new Date(start.getTime() + ONE_WEEK - ONE_DAY);
    var isLastWeek = (start.getTime() <= pastTime.getTime() && pastTime.getTime() <= end.getTime());
    return isLastWeek;
}
exports.isLastWeek = isLastWeek;
// for use with lists' server-processed date value
/**
 * @param relativeDateTimeJSString: list server-processed date value string
 * @startWithLowerCase: use this option when the return string is not at beginning of the sentence.
 */
function getRelativeDateTimeStringForLists(relativeDateTimeJSString, startWithLowerCase) {
    'use strict';
    if (startWithLowerCase === void 0) { startWithLowerCase = false; }
    var ret = null;
    var retTemplate = null;
    var codes = relativeDateTimeJSString.split('|');
    // Passthrough case
    if (codes[0] === "0") {
        return relativeDateTimeJSString.substring(2);
    }
    var bFuture = codes[1] === "1";
    var timeBucket = codes[2];
    var timeValue = codes.length >= 4 ? codes[3] : null;
    var timeValue2 = codes.length >= 5 ? codes[4] : null;
    switch (timeBucket) {
        // a few seconds
        case "1":
            ret = bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AFewSecondsFuture_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AFewSecondsFuture) :
                (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AFewSeconds_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AFewSeconds);
            break;
        // about a minute
        case "2":
            ret = bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAMinuteFuture_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAMinuteFuture) :
                (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAMinute_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAMinute);
            break;
        // x minutes
        case "3":
            retTemplate = StringHelper_1.getLocalizedCountValue(bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_XMinutesFuture_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_XMinutesFuture)
                : DatetimeResx.strings.RelativeDateTime_XMinutes, bFuture ? DatetimeResx.strings.RelativeDateTime_XMinutesFutureIntervals : DatetimeResx.strings.RelativeDateTime_XMinutesIntervals, Number(timeValue));
            break;
        // about an hour
        case "4":
            ret = bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAnHourFuture_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAnHourFuture)
                : (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_AboutAnHour_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_AboutAnHour);
            break;
        // yesterday / tomorrow
        case "5":
            if (timeValue == null) {
                ret = bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_Tomorrow_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_Tomorrow)
                    : (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_Yesterday_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_Yesterday);
            }
            else {
                retTemplate = bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_TomorrowAndTime_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_TomorrowAndTime)
                    : (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_YesterdayAndTime_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_YesterdayAndTime);
            }
            break;
        // x hours
        case "6":
            retTemplate = StringHelper_1.getLocalizedCountValue(bFuture ? (startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_XHoursFuture_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_XHoursFuture)
                : DatetimeResx.strings.RelativeDateTime_XHours, bFuture ? DatetimeResx.strings.RelativeDateTime_XHoursFutureIntervals : DatetimeResx.strings.RelativeDateTime_XHoursIntervals, Number(timeValue));
            break;
        // day and time
        case "7":
            if (timeValue2 === null) {
                ret = timeValue;
            }
            else {
                retTemplate = DatetimeResx.strings.RelativeDateTime_DayAndTime;
            }
            break;
        // <Days> days
        case "8":
            retTemplate = StringHelper_1.getLocalizedCountValue(bFuture ? DatetimeResx.strings.RelativeDateTime_XDaysFuture : DatetimeResx.strings.RelativeDateTime_XDays, bFuture ? DatetimeResx.strings.RelativeDateTime_XDaysFutureIntervals : DatetimeResx.strings.RelativeDateTime_XDaysIntervals, Number(timeValue));
            break;
        // today
        case "9":
            ret = startWithLowerCase ? DatetimeResx.strings.RelativeDateTime_Today_StartWithLowerCase : DatetimeResx.strings.RelativeDateTime_Today;
            break;
    }
    if (retTemplate !== null) {
        ret = retTemplate.replace("{0}", timeValue);
        if (timeValue2 !== null) {
            ret = ret.replace("{1}", timeValue2);
        }
    }
    return ret;
}
exports.getRelativeDateTimeStringForLists = getRelativeDateTimeStringForLists;
/**
 * Converts a given date string into its UTC/ISO standard format
 */
function convertDateToISOString(expiration) {
    'use strict';
    var expirationDate = new Date(expiration);
    // For more info on the time zone offset and its signage, see:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
    var isOffsetNegative = (expirationDate.getTimezoneOffset() < 0) ? true : false;
    var year = expirationDate.getFullYear().toString();
    var month = _padStringWithZeroes((expirationDate.getMonth() + 1).toString(), 2); //zero based month
    var day = _padStringWithZeroes(expirationDate.getDate().toString(), 2);
    var hours = _padStringWithZeroes(expirationDate.getHours().toString(), 2);
    var minutes = _padStringWithZeroes(expirationDate.getMinutes().toString(), 2);
    var seconds = _padStringWithZeroes(expirationDate.getSeconds().toString(), 2);
    var offsetHours = _padStringWithZeroes((isOffsetNegative ? Math.ceil(expirationDate.getTimezoneOffset() / 60).toString().replace("-", "") : Math.floor(expirationDate.getTimezoneOffset() / 60).toString()), 2);
    var offsetMinutes = _padStringWithZeroes((expirationDate.getTimezoneOffset() % 60).toString().replace("-", ""), 2);
    var expirationString = year + month + day + 'T' + hours + minutes + seconds + (isOffsetNegative ? '+' : '-') + offsetHours + offsetMinutes;
    return expirationString;
}
exports.convertDateToISOString = convertDateToISOString;
/**
 * get the last day of the month based on the input date
 */
function getLastDayOfMonth(date) {
    'use strict';
    var lastDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1, 0, 0, 0, 0));
    // To get the last day of the month we will increment the month
    lastDay.setUTCMonth(lastDay.getUTCMonth() + 1);
    // Then subtract a day
    lastDay.setUTCDate(lastDay.getUTCDate() - 1);
    // Then set the time to be the last second of the day
    lastDay.setUTCHours(23, 59, 59, 999);
    return lastDay;
}
exports.getLastDayOfMonth = getLastDayOfMonth;
/**
 * Given the .Net ticks of a date, convert it to a Date
 */
function getDateFromDotNetTicks(dotNetTicks) {
    'use strict';
    if (!dotNetTicks) {
        return null;
    }
    var ticksInMilliseconds = (dotNetTicks / 10000) - TICKS_CONVERSION_CONSTANT;
    return new Date(ticksInMilliseconds);
}
exports.getDateFromDotNetTicks = getDateFromDotNetTicks;
function createShortDateFormatters() {
    'use strict';
    var locale = _getLocale();
    var supportsUTC = _supportsTimeZoneDateOptions();
    if (window['Intl'] && window['Intl']['DateTimeFormat']) {
        var dateOptions = {};
        var timeOptions = { hour: '2-digit', minute: '2-digit' };
        shortDateFormat = new Intl.DateTimeFormat(locale, dateOptions);
        shortTimeFormat = new Intl.DateTimeFormat(locale, timeOptions);
        if (supportsUTC) {
            dateOptions.timeZone = 'UTC';
            timeOptions.timeZone = 'UTC';
        }
        shortDateFormatUTC = new Intl.DateTimeFormat(locale, dateOptions);
        shortTimeFormatUTC = new Intl.DateTimeFormat(locale, timeOptions);
        formatShortDate = shortDateFormat.format;
        formatShortTime = shortTimeFormat.format;
        formatShortDateUTC = shortDateFormatUTC.format;
        formatShortTimeUTC = shortTimeFormatUTC.format;
    }
    else {
        // No support for formatter objects.
        formatShortDate = formatShortDateUTC = function (date) {
            return date.toLocaleDateString(locale);
        };
        formatShortTime = formatShortTimeUTC = function (date) {
            return date.toLocaleTimeString(locale);
        };
    }
}
/**
 * Returns a short version of a date to display (e.g. 11:45 PM if today, or 11/2/2015 if not today)
 */
function getShortDisplayDate(date, useUTCTimezone) {
    'use strict';
    if (!date) {
        return '';
    }
    if (!formatShortDate) {
        createShortDateFormatters();
    }
    var now = new Date();
    var isToday = date.getDate() === now.getDate() && Math.abs(now.getTime() - date.getTime()) < ONE_DAY;
    var formatter;
    if (useUTCTimezone) {
        if (isToday) {
            formatter = formatShortTimeUTC;
        }
        else {
            formatter = formatShortDateUTC;
        }
    }
    else {
        if (isToday) {
            formatter = formatShortTime;
        }
        else {
            formatter = formatShortDate;
        }
    }
    return formatter(date);
}
exports.getShortDisplayDate = getShortDisplayDate;
/**
 * Returns a full version of a date to display (e.g. 11/2/2015 11:45 PM)
 * useUTCTimezone defaults to false
 * useHour12 is ignored, and will be determined by the locale.
 */
function getFullDisplayDate(date, useUTCTimezone, useHour12) {
    'use strict';
    if (!formatShortDate) {
        createShortDateFormatters();
    }
    var dateString = useUTCTimezone ? formatShortDateUTC(date) : formatShortDate(date);
    var timeString = useUTCTimezone ? formatShortTimeUTC(date) : formatShortTime(date);
    return StringHelper_1.format(DatetimeResx.strings.DateAndTime, dateString, timeString);
}
exports.getFullDisplayDate = getFullDisplayDate;
_getLocale = function () {
    'use strict';
    var validLocale;
    var locales = [
        window['$Config'] && window['$Config']['mkt'],
        Locale_1.default.language,
        navigator.language,
        'en'
    ].filter(function (str) { return !!str; });
    for (var _i = 0, locales_1 = locales; _i < locales_1.length; _i++) {
        var locale = locales_1[_i];
        try {
            new Date().toLocaleDateString(locale);
            validLocale = locale;
            break;
        }
        catch (e) {
        }
    }
    _getLocale = function () { return validLocale; };
    return validLocale;
};
function _supportsTimeZoneDateOptions() {
    'use strict';
    if (supportsTimeZoneDateOptions === void 0) {
        try {
            var locale = _getLocale();
            (new Date()).toLocaleDateString(locale, { timeZone: 'UTC' });
            supportsTimeZoneDateOptions = true;
        }
        catch (E) {
            // We know of some versions of IE 11 that fail when date options with a timezone is specified.
            supportsTimeZoneDateOptions = false;
        }
    }
    return supportsTimeZoneDateOptions;
}
/**
 * Pads a date string with the request number of '0' characters
 */
function _padStringWithZeroes(toPad, numDigits) {
    'use strict';
    var paddedString = toPad;
    while (paddedString.length < numDigits) {
        paddedString = '0' + paddedString;
    }
    return paddedString;
}


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

exports.strings = { "RelativeDateTime_AFewSeconds": "A few seconds ago", "RelativeDateTime_AFewSeconds_StartWithLowerCase": "a few seconds ago", "RelativeDateTime_Format_DateTimeFormattingString_Override": "", "RelativeDateTime_Format_DateTimeFormattingString": "{0}, {1}", "RelativeDateTime_AFewSecondsFuture": "In a few seconds", "RelativeDateTime_AFewSecondsFuture_StartWithLowerCase": "in a few seconds", "RelativeDateTime_AboutAMinuteFuture": "In about a minute", "RelativeDateTime_AboutAMinuteFuture_StartWithLowerCase": "in about a minute", "RelativeDateTime_LessThanAMinute": "Less than a minute ago", "RelativeDateTime_LessThanAMinute_StartWithLowerCase": "less than a minute ago", "RelativeDateTime_AboutAMinute": "About a minute ago", "RelativeDateTime_AboutAMinute_StartWithLowerCase": "about a minute ago", "RelativeDateTime_XMinutesFuture": "In {0} minute||In {0} minutes", "RelativeDateTime_XMinutesFuture_StartWithLowerCase": "in {0} minute||in {0} minutes", "RelativeDateTime_XMinutesFutureIntervals": "1||2-", "RelativeDateTime_XMinutesIntervals": "1||2-", "RelativeDateTime_AboutAnHourFuture": "In about an hour", "RelativeDateTime_AboutAnHourFuture_StartWithLowerCase": "in about an hour", "RelativeDateTime_AboutAnHour": "About an hour ago", "RelativeDateTime_AboutAnHour_StartWithLowerCase": "about an hour ago", "RelativeDateTime_Tomorrow": "Tomorrow", "RelativeDateTime_Tomorrow_StartWithLowerCase": "tomorrow", "RelativeDateTime_Yesterday": "Yesterday", "RelativeDateTime_Yesterday_StartWithLowerCase": "yesterday", "RelativeDateTime_YesterdayAndTime": "Yesterday at {0}", "RelativeDateTime_YesterdayAndTime_StartWithLowerCase": "yesterday at {0}", "DateTime_DateAndTime": "{0} at {1}", "RelativeDateTime_TomorrowAndTime": "Tomorrow at {0}", "RelativeDateTime_TomorrowAndTime_StartWithLowerCase": "tomorrow at {0}", "RelativeDateTime_XHoursFuture": "In {0} hour||In {0} hours", "RelativeDateTime_XHoursFuture_StartWithLowerCase": "in {0} hour||in {0} hours", "RelativeDateTime_XHours": "{0} hour ago||{0} hours ago", "RelativeDateTime_XHoursFutureIntervals": "1||2-", "RelativeDateTime_XHoursIntervals": "1||2-", "RelativeDateTime_DayAndTime": "{0} at {1}", "RelativeDateTime_XDaysFuture": "{0} day from now||{0} days from now", "RelativeDateTime_XDays": "{0} day ago||{0} days ago", "RelativeDateTime_XDaysFutureIntervals": "1||2-", "RelativeDateTime_XDaysIntervals": "1||2-", "RelativeDateTime_Today": "Today", "RelativeDateTime_Today_StartWithLowerCase": "today", "RelativeDateTime_XMinutes": "{0} minute ago||{0} minutes ago", "DateAndTime": "{0} {1}" };


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// encode <>&'"
var ENCODE_HTML_TEXT_REGEX = /[<>&'"\\]/g;
var CODES = {
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;',
    '"': '&quot;',
    '\'': '&#39;',
    '\\': '&#92;'
};
function replacer(match) {
    return CODES[match];
}
var HtmlEncoding = (function () {
    function HtmlEncoding() {
    }
    /**
     * Encodes a string for use in HTML text. Not recommended for attribute values
     * or anything that might be used in a URL.
     */
    HtmlEncoding.encodeText = function (inputString) {
        if (!inputString) {
            return "";
        }
        return inputString.replace(ENCODE_HTML_TEXT_REGEX, replacer);
    };
    return HtmlEncoding;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HtmlEncoding;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TAG_BODY = '(?:[^"\'>]|"[^"]*"|\'[^\']*\')*';
/** Regex that matches all non-text in an HTML string. */
var NONTEXT_PATTERN = new RegExp('<(?:'
    + '!--(?:(?:-*[^->])*--+|-?)'
    + '|script\\b' + TAG_BODY + '>[\\s\\S]*?</script\\s*'
    + '|style\\b' + TAG_BODY + '>[\\s\\S]*?</style\\s*'
    + '|/?[a-z]' + TAG_BODY
    + ')>', 'gi');
/**
 * Contains utility functions to sanitize user input.
 * This should only be used for DISPLAYING user input, not for sending it to the server. The server itself
 * also needs to sanitize user input to avoid security risks.
 */
var Sanitize = (function () {
    function Sanitize() {
    }
    /**
     * Takes a string with HTML elements and returns only the text contents that the user would read.
     * This differs from .innerText in that it also removes the contents of script tags, and other similar differences.
     */
    Sanitize.getTextFromHtml = function (html) {
        var oldHtml = '';
        do {
            oldHtml = html;
            html = oldHtml.replace(NONTEXT_PATTERN, '');
        } while (oldHtml !== html);
        return html;
    };
    /**
     * Sanitizes the text by calling getTextFromHtml(), then decodes the HTML Entities, for example "&lt" to "<"
     */
    Sanitize.decodeHtmlEntities = function (text) {
        text = Sanitize.getTextFromHtml(text);
        var element = document.createElement('div');
        element.innerHTML = text;
        return element.textContent;
    };
    return Sanitize;
}());
exports.Sanitize = Sanitize;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Sanitize;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FileTypeIconMap_1 = __webpack_require__(129);
var ItemType_1 = __webpack_require__(85);
var SharingTypeHelper = __webpack_require__(131);
var GENERIC_FILE = 'genericfile';
var CODE_FILE = 'code';
var ONENOTE_FILE = 'one';
var FOLDER = 'folder';
var SHARED_FOLDER = 'sharedfolder';
var DOCSET_FOLDER = 'docset';
var VIDEO_FILE = 'video';
var PHOTO_FILE = 'photo';
var LIST_ITEM = 'listitem';
var _extensionToIconName;
exports.genericFile = GENERIC_FILE;
exports.codeFile = CODE_FILE;
exports.videoFile = VIDEO_FILE;
exports.photoFile = PHOTO_FILE;
function getIconNameFromItem(item) {
    var iconName = '';
    if (item.type === ItemType_1.default.Folder) {
        iconName = SharingTypeHelper.usePrivateFolderIcon(item.sharingType) ? FOLDER : SHARED_FOLDER;
        if (item.isDocSet) {
            iconName = DOCSET_FOLDER;
        }
    }
    else if (item.type === ItemType_1.default.OneNote) {
        iconName = ONENOTE_FILE;
    }
    else if (item.listItem) {
        iconName = LIST_ITEM;
    }
    else if (item.textEditorMimeType === 'text/typescript') {
        iconName = CODE_FILE;
    }
    else {
        iconName = getIconNameFromExtension(item.extension);
    }
    return iconName;
}
exports.getIconNameFromItem = getIconNameFromItem;
function getItemTypeFromExtension(extension) {
    var itemType;
    try {
        if (extension) {
            var iconName = getIconNameFromExtension(extension);
            if (FileTypeIconMap_1.default[iconName]) {
                var iconItemType = FileTypeIconMap_1.default[iconName].type;
                if (iconItemType === (void 0)) {
                    iconItemType = ItemType_1.default.File;
                }
                itemType = iconItemType;
            }
        }
    }
    catch (e) {
    }
    if (itemType === (void 0)) {
        itemType = ItemType_1.default.Unknown;
    }
    return itemType;
}
exports.getItemTypeFromExtension = getItemTypeFromExtension;
function getIconNameFromExtension(extension) {
    if (!_extensionToIconName) {
        _extensionToIconName = {};
        for (var iconName in FileTypeIconMap_1.default) {
            var extensions = FileTypeIconMap_1.default[iconName].extensions;
            if (extensions) {
                for (var i = 0; i < extensions.length; i++) {
                    _extensionToIconName[extensions[i]] = iconName;
                }
            }
        }
    }
    // Strip periods, force lowercase.
    extension = extension.replace('.', '').toLowerCase();
    return _extensionToIconName[extension] || GENERIC_FILE;
}
exports.getIconNameFromExtension = getIconNameFromExtension;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Killswitch = (function () {
    function Killswitch() {
    }
    /**
     * Performs the static initialization of the kill switches map.
     * @param {{[key: string]: boolean}} killSwitches - The map of all active killswitches.
     */
    Killswitch.initKillSwitches = function (killSwitches) {
        Killswitch._killSwitches = killSwitches || {};
    };
    /**
     * Returns true if the given SPO killswitch is found in the static map
     * of active killswitches.
     * @requires - The application should initialize the static map
     * of active killswitches using initKillSwitches before invoking this method.
     * @param {string} killSwitch - The string representation of the guid identifying the
     * killswitch to check.
     * @param {string} date - The date when the kill switch check has been added to the codebase.
     * @param {string} message - A text message associated with the kill switch.
     * @returns {boolean} - True if the given kill switch is found active.
     */
    Killswitch.isActivated = function (killSwitch, date, message) {
        // use _spPageContextInfo for backward compatibility while still available
        var _spPageContextInfo = window['_spPageContextInfo'];
        if (!Killswitch._killSwitches && _spPageContextInfo && _spPageContextInfo.killSwitches) {
            Killswitch.initKillSwitches(_spPageContextInfo.killSwitches);
        }
        return killSwitch && Killswitch._killSwitches &&
            Killswitch._killSwitches[killSwitch.toUpperCase()];
    };
    return Killswitch;
}());
Killswitch._killSwitches = null;
exports.Killswitch = Killswitch;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Features_1 = __webpack_require__(52);
exports.HASHTAG_DISPLAY_PREFIX = "#";
exports.HASHTAG_DELIMITER = ";";
exports.MVL_DELIMITER = ";#";
exports.HASHTAG_FIELD_ID = "968052CC-891E-4197-ABBB-19C3EDFF3CD2";
var Hashtags = { ODB: 581, ODC: null, Fallback: false };
var HashtagsUI = { ODB: 824, ODC: null, Fallback: false };
function isHashtagEnabled() {
    return Features_1.default.isFeatureEnabled(Hashtags) && Features_1.default.isFeatureEnabled(HashtagsUI);
}
exports.isHashtagEnabled = isHashtagEnabled;
function isClientFormHashtagField(field) {
    return (field &&
        field.schema &&
        isHashtagField(field.schema.FieldType, field.schema.Id));
}
exports.isClientFormHashtagField = isClientFormHashtagField;
function isHashtagField(fieldType, fieldId) {
    return (isHashtagEnabled() &&
        fieldType &&
        fieldType.toLowerCase() === "lookupmulti" &&
        fieldId &&
        fieldId.toLowerCase() === exports.HASHTAG_FIELD_ID.toLowerCase());
}
exports.isHashtagField = isHashtagField;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Features_1 = __webpack_require__(52);
var ShortcutLink = { ODB: 563, ODC: null, Fallback: false };
var ShortcutUtilities;
(function (ShortcutUtilities) {
    'use strict';
    /**
     * Returns true if item is a Shortcut item, and false otherwise.
     * Checks the file extension for .url and .website
     */
    function isShortcutItem(item) {
        if (!item || !item.extension) {
            return false;
        }
        var fileType;
        if (item.extension[0] !== '.') {
            // Technically, extension should always start with a '.' but that's not actually the case
            fileType = item.extension;
        }
        else {
            fileType = item.extension.slice(1);
        }
        return isShortcutFileType(fileType);
    }
    ShortcutUtilities.isShortcutItem = isShortcutItem;
    /**
     * Identifies whether or not a given file type should be treated as a shortcut item.
     * Note that while a file extension has a preceding '.' character, a file type does not.
     */
    function isShortcutFileType(fileType) {
        // note: lnk files are not supported in odb's SP shortcuts API, we should not treat .lnk files as shortcut files.
        return fileType === 'url' || fileType === 'website';
    }
    ShortcutUtilities.isShortcutFileType = isShortcutFileType;
    function isShortcutEnabled() {
        return Features_1.default.isFeatureEnabled(ShortcutLink);
    }
    ShortcutUtilities.isShortcutEnabled = isShortcutEnabled;
    var ShortcutErrors;
    (function (ShortcutErrors) {
        /** Generic unknown error */
        ShortcutErrors[ShortcutErrors["UnknownError"] = 0] = "UnknownError";
        /** File already exists (error during new file creation). */
        ShortcutErrors[ShortcutErrors["NewFileCreationFileAlreadyExistsError"] = 1] = "NewFileCreationFileAlreadyExistsError";
        /** Filename contains an invalid character, such as # % * : < > ? / | */
        ShortcutErrors[ShortcutErrors["InvalidCharacterError"] = 2] = "InvalidCharacterError";
    })(ShortcutErrors = ShortcutUtilities.ShortcutErrors || (ShortcutUtilities.ShortcutErrors = {}));
})(ShortcutUtilities || (ShortcutUtilities = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ShortcutUtilities;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Engagement_event_1 = __webpack_require__(54);
;
;
/**
 * Enum for the types of targets that can be used to run an experiment.
 * @enum {number}
 */
var TargetType;
(function (TargetType) {
    /** Value for user population. */
    TargetType[TargetType["user"] = 1] = "user";
    /** Value for tenant population.  */
    TargetType[TargetType["tenant"] = 2] = "tenant";
    /** Value for farm population. */
    TargetType[TargetType["farm"] = 3] = "farm";
})(TargetType = exports.TargetType || (exports.TargetType = {}));
/**
 * This class will be used for AB Testing type of experiments.
 */
var ABExperiment = (function () {
    /**
     * @constructor
     * @param {IABExperimentData} experimentData The data for the experiment.
     * @example
     * // set the experiment data
     * let newMenuExperimentData: IABExperimentData = { name: "NewMenu", startDate: "11/17/2016", segmentPopulation: 0.4};
     * // create the experiment object
     * let newMenuExperiment: ABExperiment = new ABExperiment(newMenuExperimentData);
     */
    function ABExperiment(experimentData) {
        // set the _experimentData
        // if segementPopulation is not specified set it to half, 0.5
        // if targetType is not specified set it to user type
        this._experimentData = {
            name: experimentData.name,
            startDate: experimentData.startDate,
            segmentPopulation: (experimentData.segmentPopulation === undefined) ? 0.5 : experimentData.segmentPopulation,
            targetType: (experimentData.targetType === undefined) ? TargetType.user : experimentData.targetType
        };
        // set isOn to false, by default
        this._isOn = false;
        if (ABExperiment._hostSettings === null || ABExperiment._hostSettings === undefined) {
            // log that the App that wasnts to do experiments
            // does not have host settings and quit doing the experiment checks
            Engagement_event_1.Engagement.logData({ name: this._experimentData.name + ".Experiment.HostSettingsMissing" });
        }
        else {
            // set the isOn flag based on the target type
            // if it ever reaches the default then return false
            switch (this._experimentData.targetType) {
                case TargetType.user:
                    this._isOn = this._isUserExperimentOn();
                    break;
                case TargetType.tenant:
                    this._isOn = this._isTenantExperimentOn();
                    break;
                case TargetType.farm:
                    this._isOn = this._isFarmExperimentOn();
                    break;
            }
        }
    }
    /**
     * Initializes ABExperiment with the hostSettings.
     * @param {IABContext} hostSettings The host settings of the app where is experiment is running.
     */
    ABExperiment.Init = function (hostSettings) {
        ABExperiment._hostSettings = hostSettings;
        ABExperiment._hostSettings = {
            userLoginName: hostSettings.userLoginName || 'missing_user',
            siteSubscriptionId: hostSettings.siteSubscriptionId || 'missing_tenant',
            farmLabel: hostSettings.farmLabel || 'missing_farm'
        };
    };
    /**
     * Returns the experiment data to be used for logging purposes.
     * @return {IABExperimentData}.
     */
    ABExperiment.prototype.GetExperimentData = function () {
        return this._experimentData;
    };
    /**
     * Checks if the current specified target is being selected to be part of the experiment.
     * @param {string} targetType is the type of target that the experiment will run on. It can be user, tenant, or farm.
     * @return {boolean}.
     */
    ABExperiment.prototype.IsExperimentOn = function () {
        return this._isOn;
    };
    /**
     * Checks if the current user is being selected to be part of the experiment.
     * @return {boolean}.
     */
    ABExperiment.prototype._isUserExperimentOn = function () {
        // in case there are no host settings default to no experiments
        if (ABExperiment._hostSettings === null) {
            return false;
        }
        // build an uber token
        var targetToken = this._experimentData.name + '_' +
            ABExperiment._hostSettings.userLoginName + '_' +
            ABExperiment._hostSettings.siteSubscriptionId + '_' +
            ABExperiment._hostSettings.farmLabel;
        return this._isExperimentOn(targetToken);
    };
    /**
     * Checks if the current tenant is being selected to be part of the experiment.
     * @return {boolean}.
     */
    ABExperiment.prototype._isTenantExperimentOn = function () {
        // in case there are no settings default to no experiment path
        if (ABExperiment._hostSettings === null) {
            return false;
        }
        // build an uber token
        var targetToken = this._experimentData.name + '_' +
            ABExperiment._hostSettings.siteSubscriptionId + '_' +
            ABExperiment._hostSettings.farmLabel;
        return this._isExperimentOn(targetToken);
    };
    /**
     * Checks if the current farm is being selected to be part of the experiment.
     * @return {boolean}.
     */
    ABExperiment.prototype._isFarmExperimentOn = function () {
        // in case there are no settings default to no experiment path
        if (ABExperiment._hostSettings === null) {
            return false;
        }
        // build the token
        var targetToken = this._experimentData.name + '_' +
            ABExperiment._hostSettings.farmLabel;
        return this._isExperimentOn(targetToken);
    };
    /**
     * Returns true if the curent target type is being selected to be part of the experiment.
     * @param {string} targetToken this is the unique identfier for target.
     * @returns {boolean} true if the targetToken is in the segementPopulation defined for the experiment.
     */
    ABExperiment.prototype._isExperimentOn = function (targetToken) {
        if (targetToken === null) {
            return false;
        }
        // get the hash number for the specified targetToken
        var varHash = this._getHashNumber(targetToken);
        // it returns true if varHash is less than segementPopulation
        // same time, it logs experiment info
        if (varHash <= this._experimentData.segmentPopulation) {
            this._logData(true);
            return true;
        }
        else {
            this._logData(false);
            return false;
        }
    };
    /**
     * Returns an unique number based on the string provided.
     * @param {string} inputString this is the unique uber identfier for target.
     * @returns {number}.
     */
    ABExperiment.prototype._getHashNumber = function (inputString) {
        // in case there will be empty strings returns 1
        // this will take it to the experiment off path
        if (inputString.length === 0) {
            return 1;
        }
        var hash = 5381;
        for (var i = 0; i < inputString.length; ++i) {
            hash = ((hash << 5) + hash) + inputString.charCodeAt(i);
            hash = hash & hash;
        }
        hash = hash & 0xFFFF;
        return hash / 0xFFFF;
    };
    ;
    /**
     * Log the experiment data for teting purposes.
     */
    ABExperiment.prototype._logData = function (isOn) {
        // prepare the extraData
        var extraData = { isTreatment: isOn,
            startDate: this._experimentData.startDate,
            isExternalGuestUser: ABExperiment._hostSettings.isExternalGuestUser,
            isAnonymousGuestUser: ABExperiment._hostSettings.isAnonymousGuestUser,
            farmLabel: ABExperiment._hostSettings.farmLabel,
            targetType: this._experimentData.targetType
        };
        // the tag will look like this <ScenarioName>.<experimentName>.Experiment
        Engagement_event_1.Engagement.logData({ name: this._experimentData.name + ".Experiment", extraData: extraData });
    };
    return ABExperiment;
}());
exports.ABExperiment = ABExperiment;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Manager_1 = __webpack_require__(16);
var EventBatchCache_1 = __webpack_require__(242);
var XHR_1 = __webpack_require__(262);
var Beacon_event_1 = __webpack_require__(53);
var BeaconBase = (function () {
    function BeaconBase(endPointUrl, batchSize, flushTimeouts, useSlidingWindow, maxCriticalFlushInterval, totalRetries, resetTotalRetriesAfter, ignorePreviousEvents) {
        var _this = this;
        this._lastSendBeacon = 0;
        this._endPointUrl = endPointUrl;
        this._maxCriticalFlushInterval = maxCriticalFlushInterval;
        this._totalRetries = totalRetries === undefined ? BeaconBase.DEFAULT_TOTAL_RETRIES : totalRetries;
        this._totalRetriesStartValue = this._totalRetries;
        this._resetTotalRetriesAfter = resetTotalRetriesAfter === undefined ? BeaconBase.DEFAULT_RESET_TOTAL_RETRIES_AFTER : resetTotalRetriesAfter;
        this._ignorePreviousEvents = ignorePreviousEvents === undefined ? false : ignorePreviousEvents;
        this._eventBatchCache = new EventBatchCache_1.default(batchSize, flushTimeouts, function (event) {
            if (_this._onNewEvent) {
                _this._onNewEvent(event);
            }
        }, function (events) {
            // Create the beacon request
            _this._createBeaconRequest(events);
        }, useSlidingWindow);
        this.init();
    }
    BeaconBase.prototype.sendBeacon = function (json, headers, requestTimeoutInMS) {
        this._sendBeacon(json, headers, requestTimeoutInMS, 0);
    };
    BeaconBase.prototype._sendBeacon = function (json, headers, requestTimeoutInMS, retryCount) {
        var _this = this;
        if (retryCount === 0) {
            this._lastSendBeacon = Manager_1.Manager.getTime();
        }
        var xhr = new XHR_1.default({
            url: this._endPointUrl,
            json: json,
            headers: headers,
            requestTimeoutInMS: requestTimeoutInMS
        });
        var beaconEvent = new Beacon_event_1.Beacon({
            retryCount: retryCount,
            totalRetries: this._totalRetries
        });
        xhr.start(function (xhr, status) {
            beaconEvent.end({ status: status + '', success: true });
            if (++_this._successfulLogRequests >= _this._resetTotalRetriesAfter) {
                _this._successfulLogRequests = _this._resetTotalRetriesAfter;
                _this._totalRetries = _this._totalRetriesStartValue;
            }
        }, function (xhr, status, timeout) {
            _this._successfulLogRequests = 0;
            beaconEvent.end({ status: status + '', success: false });
            // Retry if we timed out since we failed
            if (status === -2 /* timeout */ && _this._totalRetries > 0) {
                _this._totalRetries--;
                _this._sendBeacon(json, headers, requestTimeoutInMS, retryCount + 1);
            }
        });
    };
    BeaconBase.prototype.init = function () {
        var _this = this;
        var bufferedEvents = Manager_1.Manager.addLogHandler(function (event) {
            _this.addEvent(event);
        });
        if (!this._ignorePreviousEvents) {
            for (var x = 0; x < bufferedEvents.length; x++) {
                this.addEvent(bufferedEvents[x]);
            }
        }
    };
    BeaconBase.prototype.addEvent = function (event) {
        if (event.enabled) {
            this._eventBatchCache.addEvent(event);
            if (event.critical &&
                (!this._lastSendBeacon ||
                    Manager_1.Manager.getTime() - this._lastSendBeacon > this._maxCriticalFlushInterval)) {
                this._eventBatchCache.flush();
            }
        }
    };
    return BeaconBase;
}());
BeaconBase.DEFAULT_TOTAL_RETRIES = 3;
BeaconBase.DEFAULT_RESET_TOTAL_RETRIES_AFTER = 3;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BeaconBase;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var Async_1 = __webpack_require__(15);
var Beacon_event_1 = __webpack_require__(53);
var ErrorHelper_1 = __webpack_require__(9);
var EventBatchCache = (function () {
    function EventBatchCache(maxSize, maxFlushTimes, newEventHandler, flushHandler, useSlidingWindow) {
        this._events = [];
        this._flushCount = 0;
        this._async = new Async_1.default(this);
        this._maxSize = maxSize;
        this._newEventHandler = newEventHandler;
        this._flushHandler = flushHandler;
        this._maxFlushTimes = maxFlushTimes;
        this._useSlidingWindow = useSlidingWindow;
    }
    EventBatchCache.prototype.addEvent = function (event) {
        this._events.push(event);
        if (this._newEventHandler) {
            try {
                this._newEventHandler(event);
            }
            catch (e) {
                ErrorHelper_1.default.log(e);
            }
        }
        // Dont create a timer for events that are of type beacon
        if (Beacon_event_1.Beacon.isTypeOf(event)) {
            return;
        }
        if (this._events.length >= this._maxSize) {
            this.flush();
        }
        else {
            this._setFlushTimeout(false);
        }
    };
    EventBatchCache.prototype.flush = function () {
        this._setFlushTimeout(true);
    };
    EventBatchCache.prototype._handleFlush = function () {
        this._clearFlushTimeout();
        if (this._events.length) {
            this._flushHandler(this._events);
            // Reset the events array
            this._events = [];
        }
    };
    EventBatchCache.prototype._clearFlushTimeout = function () {
        if (this._flushTimeoutId) {
            this._async.clearTimeout(this._flushTimeoutId);
            this._flushTimeoutId = null;
        }
        if (this._immediateflushTimeoutId) {
            this._async.clearTimeout(this._immediateflushTimeoutId);
            this._immediateflushTimeoutId = null;
        }
    };
    EventBatchCache.prototype._setFlushTimeout = function (immediate) {
        var _this = this;
        // if another immediate flush is already queued, disregard
        if (!!this._immediateflushTimeoutId) {
            return;
        }
        if (this._useSlidingWindow) {
            this._clearFlushTimeout();
            if (immediate) {
                this._immediateflushTimeoutId = this._async.setTimeout(function () {
                    _this._handleFlush();
                }, 0);
            }
            else {
                this._flushTimeoutId = this._async.setTimeout(function () {
                    _this._handleFlush();
                }, this._getFlushTime());
            }
        }
        else {
            if (immediate) {
                if (!this._immediateflushTimeoutId) {
                    this._immediateflushTimeoutId = this._async.setTimeout(function () {
                        _this._handleFlush();
                    }, 0);
                }
            }
            else if (!this._flushTimeoutId) {
                this._flushTimeoutId = this._async.setTimeout(function () {
                    _this._handleFlush();
                }, this._getFlushTime());
            }
        }
    };
    EventBatchCache.prototype._getFlushTime = function () {
        if (this._flushCount < this._maxFlushTimes.length) {
            var flushCount = this._flushCount;
            this._flushCount++;
            return this._maxFlushTimes[flushCount];
        }
        else {
            return this._maxFlushTimes[this._maxFlushTimes.length - 1];
        }
    };
    return EventBatchCache;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EventBatchCache;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RequireJSError_event_1 = __webpack_require__(138);
var ErrorHelper_1 = __webpack_require__(9);
var RequireJSErrorHandler = (function () {
    function RequireJSErrorHandler() {
    }
    RequireJSErrorHandler.log = function (err) {
        // Log the error as data an fire log error so it shows up in the error logs
        RequireJSError_event_1.RequireJSError.logData(err);
        // Only log script errors to log error
        if (err &&
            (err.requireType === "define" ||
                err.requireType === "require") &&
            err.stack &&
            err.requireModules) {
            ErrorHelper_1.default.log(err);
        }
    };
    RequireJSErrorHandler.registerRequireOnError = function () {
        if (window["requirejs"] && typeof window["requirejs"] === 'function') {
            var prevOnError = window["requirejs"].onError;
            window["requirejs"].onError = function (err) {
                RequireJSErrorHandler.log(err);
                if (prevOnError && !err.isTest) {
                    prevOnError(err);
                }
            };
        }
    };
    return RequireJSErrorHandler;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RequireJSErrorHandler;
RequireJSErrorHandler.registerRequireOnError();


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.Nav = SingleEventBase_1.createSingleEvent({
    eventName: 'Nav,',
    shortEventName: 'Nav'
}, {
    viewParams: 4 /* Object */,
    url: 1 /* String */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Nav;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var SingleEventBase_1 = __webpack_require__(7);
exports.UnhandledError = SingleEventBase_1.createSingleEvent({
    eventName: 'UnhandledError,',
    shortEventName: 'UnhandledError',
    critical: true,
    requiresParent: false
}, {
    message: 1 /* String */,
    stack: 1 /* String */,
    builtStack: 1 /* String */,
    line: 2 /* Number */,
    col: 2 /* Number */,
    url: 1 /* String */
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.UnhandledError;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ErrorHelper_1 = __webpack_require__(9);
var BeaconBase_1 = __webpack_require__(241);
var BeaconCache_1 = __webpack_require__(141);
var BaseDataStore_1 = __webpack_require__(55);
var DataStoreCachingType_1 = __webpack_require__(35);
var LogProcessor_1 = __webpack_require__(142);
var Beacon;
(function (Beacon) {
    "use strict";
    var LOGGING_REQUEST_TIMEOUT = 10000; // 10 seconds
    var FLUSH_TIMEOUT = 5000; // 5 seconds
    var BEACON_BATCH_SIZE = 100;
    var BEACON_MAX_CRITICAL_FLUSH_INTERVAL_SIZE = 5000; // 5 seconds
    // SLAPI
    var SLAPI_STREAM_ID = 1234;
    var SLAPI_JSON_VERSION = "V1";
    var SLAPI_IDX_VERSION = 0;
    var SLAPI_IDX_EVENTNAME = 1;
    var SLAPI_IDX_PROPERTY_START = 2;
    // BSQM Constants
    var SLAPI_MAX_DATA_SIZE = 64 * 1024;
    var SLAPI_MAX_ROWS_IN_STREAM = 1000;
    var SLAPI_SIZE_DWORD = 4;
    var SLAPI_SIZE_DATAPOINT_ENTRY = 3 * 4 /*SIZE_DWORD*/;
    var SLAPI_SIZE_STREAM_ENTRY = 3 * 4 /*SIZE_DATAPOINT_ENTRY*/;
    var SLAPI_MS_BTN_EPOCHS = 11644473600000; // Milliseconds between 1/1/1070 and 1/1/1601
    var SLAPI_MAX_INT32 = 0xFFFFFFFF;
    var SLAPI_MAX_SQM_DATAID = 0x7FFFFFFF;
    var SLAPI_DATAKEY_SESSION_NORMAL = 0;
    var SLAPI_DATAKEY_SESSION_CONTINUATION = 1;
    var SLAPI_FLAG_BSQM_ENABLED = 0x00000010;
    // const SLAPI_FLAG_QOS_ENABLED = 0x00000020;
    // SQM Datapoints
    var SLAPI_DATAID_BSQM_MAXSTREAMROWSSTREAMID = 8048;
    var SLAPI_DATAID_BSQM_MAXSTREAMROWS = 7993;
    var SLAPI_DATAID_SESSION_TYPE = 60;
    var WSAStreamRow = (function () {
        function WSAStreamRow(values) {
            this.Tic = 0;
            this.Vals = null;
            var _this = this;
            _this.Tic = _getTicks32();
            var numValues = values.length;
            _this.Vals = new Array(numValues);
            for (var i = 0; i < numValues; i++) {
                _this.Vals[i] = values[i];
            }
        }
        return WSAStreamRow;
    }());
    var WSADatapoint = (function () {
        function WSADatapoint(id, value) {
            var _this = this;
            _this.Id = id;
            _this.Val = value;
            _this.Tic = _getTicks32();
        }
        return WSADatapoint;
    }());
    var WSAStream = (function () {
        function WSAStream(id, width) {
            var _this = this;
            _this.Id = id;
            _this.Width = width;
            _this.Rows = new Array(0);
        }
        return WSAStream;
    }());
    var WSAData = (function () {
        function WSAData() {
            this.StartTime = null;
            this.EndTime = null;
            this.Flags = 0;
            this.wsaDatapoints = null;
            this.wsaStreams = null;
            var _this = this;
            _this.StartTime = _getTicks64();
            _this.EndTime = null;
            _this.CorrelationId = null;
            _this.Flags = SLAPI_FLAG_BSQM_ENABLED;
            _this.wsaDatapoints = new Array(0);
            _this.wsaStreams = new Array(0);
        }
        return WSAData;
    }());
    var _startTicks = 0;
    var _wsaData = null;
    var _numDatapoints = 0;
    var _numStreams = 0;
    var _numStreamBytes = 0;
    var _dictStreams = null;
    var _dictDatapoints = null;
    var _streamRowCount = 0;
    var _isDataAvailableForUpload = false;
    var _isContinuation = false;
    var _isInitialized = false;
    var _emptyCorrelationId = '00000000-0000-0000-0000-000000000000';
    var _eventNamePrefix = "";
    var _store = null;
    var _storeSize = null;
    var _instance = null;
    var _handlers = null;
    if (true) {
        try {
            console.log("Beacon: To disable logging to the console set \"window.disableBeaconLogToConsole = true\" in the debug window");
        }
        catch (error) {
        }
    }
    var OdbBeacon = (function (_super) {
        __extends(OdbBeacon, _super);
        function OdbBeacon(eventNamePrefix, handlers, cacheEnabled, correlationId, flushTimeout) {
            if (flushTimeout === void 0) { flushTimeout = FLUSH_TIMEOUT; }
            var _this = _super.call(this, '/_layouts/15/WsaUpload.ashx', BEACON_BATCH_SIZE, [flushTimeout], true, /* useSlidingWindow */ BEACON_MAX_CRITICAL_FLUSH_INTERVAL_SIZE, BeaconBase_1.default.DEFAULT_TOTAL_RETRIES, BeaconBase_1.default.DEFAULT_RESET_TOTAL_RETRIES_AFTER, cacheEnabled /* ignorePreviousEvents */) || this;
            _eventNamePrefix = eventNamePrefix;
            _handlers = handlers;
            _store = new BaseDataStore_1.default(LogProcessor_1.default.STORE_KEY,  true ? DataStoreCachingType_1.default.sharedMemory : DataStoreCachingType_1.default.session);
            _storeSize = _store.getValue(LogProcessor_1.default.STORE_SIZE_KEY);
            if (!_storeSize) {
                _storeSize = 0;
            }
            if (correlationId) {
                _this._cid = correlationId;
            }
            return _this;
        }
        OdbBeacon.prototype.beacon = function () {
            if (false) {
                var json = _getUploadData();
                if (json != null && json.length > 0) {
                    var headers = {};
                    headers["Content-Type"] = "application/json";
                    this.sendBeacon(json, headers, LOGGING_REQUEST_TIMEOUT);
                }
            }
            else if (!window["disableBeaconLogToConsole"]) {
                try {
                    console.log("Beacon: Uploaded to COSMOS (To disable logging to the console set \"window.disableBeaconLogToConsole = true\" in the debug window)");
                }
                catch (error) {
                }
            }
            // Set session storage size to zero instead of clearing
            _storeSize = 0;
            _store.setValue(LogProcessor_1.default.STORE_SIZE_KEY, _storeSize);
        };
        OdbBeacon.prototype._createBeaconRequest = function (events) {
            _SetCorrelationId(this._correlationId);
            // Converts to SP logging format
            for (var x = 0; x < events.length; x++) {
                var event = events[x];
                LogProcessor_1.default.processAndLogEvent({
                    event: event,
                    logFunc: function (streamName, dictProperties) {
                        _WriteLog(streamName, dictProperties);
                    },
                    eventNamePrefix: _eventNamePrefix,
                    handlers: _handlers
                });
            }
            this.beacon();
        };
        OdbBeacon.prototype._onNewEvent = function (event) {
            // BeaconCache puts every new event to the session storage so that Sharepoint can upload it for us
            // if user navigates away before Beacon event. So we do nothing here.
        };
        Object.defineProperty(OdbBeacon.prototype, "_correlationId", {
            get: function () {
                // Avoid reading from the global variable if correlationId has been passed in.
                // The _spPageContextInfo may not always exist.
                if (this._cid) {
                    return this._cid;
                }
                var spPageContextInfo = window['_spPageContextInfo'];
                if (spPageContextInfo) {
                    return spPageContextInfo.CorrelationId;
                }
                return _emptyCorrelationId;
            },
            enumerable: true,
            configurable: true
        });
        return OdbBeacon;
    }(BeaconBase_1.default));
    function addToLoggingManager(eventNamePrefix, handlers, correlationId, flushTimeout) {
        if (!_instance) {
            var cacheEnabled = false;
            if (BeaconCache_1.default.instance) {
                eventNamePrefix = BeaconCache_1.default.eventNamePrefix;
                handlers = BeaconCache_1.default.handlers;
                cacheEnabled = true;
            }
            if (!eventNamePrefix || !handlers) {
                throw new Error("You have to pass in eventNamePrefix and IBeaconHandlers object if no BeaconCache present.");
            }
            _instance = new OdbBeacon(eventNamePrefix, handlers, cacheEnabled, correlationId, flushTimeout);
            // read any events Sharepoint (or BeaconCache) put into session storage but haven't uploaded
            for (var i = 0; i < _storeSize; i++) {
                var item = _store.getValue(i.toString());
                if (!item || !item['name'] || !item['props']) {
                    continue;
                }
                _WriteLog(item['name'], item['props']);
            }
        }
        else {
            throw new Error("The beacon has already been added to the logging manager with event name prefix " + _eventNamePrefix + ".");
        }
    }
    Beacon.addToLoggingManager = addToLoggingManager;
    function _initialize() {
        if (_isInitialized) {
            return;
        }
        _wsaData = new WSAData();
        _dictStreams = new Array(0);
        _dictDatapoints = new Array(0);
        _createStream(SLAPI_STREAM_ID, 1);
        _isInitialized = true;
    }
    function _createStream(streamId, width) {
        if (!Boolean(_dictStreams[streamId])) {
            var wsaStream = new WSAStream(streamId, width);
            var idxStream = _numStreams;
            _wsaData.wsaStreams[idxStream] = wsaStream;
            _numStreams++;
            _numStreamBytes += SLAPI_SIZE_STREAM_ENTRY;
            _dictStreams[streamId] = idxStream;
        }
    }
    function _addToStream(streamId, dictValues) {
        try {
            var wsaStreamRow = new WSAStreamRow(dictValues);
            if (_isMaxSizeReachedCheck()) {
                return;
            }
            _isDataAvailableForUpload = true;
            _setDatapoint(SLAPI_DATAID_BSQM_MAXSTREAMROWSSTREAMID, streamId);
            var wsaStream = _wsaData.wsaStreams[_dictStreams[streamId]];
            if (Boolean(wsaStream)) {
                if (_streamRowCount < SLAPI_MAX_ROWS_IN_STREAM) {
                    wsaStream.Rows[_streamRowCount++] = wsaStreamRow;
                    _numStreamBytes += _getTotalBytesForRow(wsaStreamRow);
                    _setDatapoint(SLAPI_DATAID_BSQM_MAXSTREAMROWS, _streamRowCount); // update row count datapoint
                }
                else {
                    throw ("Beacon: MAX_ROWS_IN_STREAM exceeded for stream ID " + String(streamId));
                }
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
        }
    }
    function _getTotalBytesForRow(row) {
        var numTotalBytes = SLAPI_SIZE_DWORD;
        for (var i = 0; i < row.Vals.length; i++) {
            var value = String(row.Vals[i]);
            numTotalBytes += value.length * 2; // A JavaScript char is 16 bit 2 byte
        }
        numTotalBytes += (row.Vals.length - 1) * 6; // plus the commas and quotes when serialized
        return numTotalBytes;
    }
    function _setDatapoint(datapointId, datapointValue) {
        if (datapointId < 1 || datapointId > SLAPI_MAX_SQM_DATAID) {
            return;
        }
        if (datapointValue < 0 || datapointValue > SLAPI_MAX_INT32) {
            return;
        }
        var savedDatapoint = null;
        var idxDP = _dictDatapoints[datapointId];
        if (Boolean(idxDP)) {
            savedDatapoint = _wsaData.wsaDatapoints[idxDP];
        }
        if (savedDatapoint == null) {
            var datapoint = new WSADatapoint(datapointId, datapointValue);
            var idxDatapoint = _numDatapoints;
            _wsaData.wsaDatapoints[idxDatapoint] = datapoint;
            _dictDatapoints[datapointId] = idxDatapoint;
            _numDatapoints++;
        }
        else {
            savedDatapoint.Val = datapointValue;
        }
    }
    function _uploadData() {
        if (_wsaData == null) {
            return "";
        }
        try {
            if (_isDataAvailableForUpload) {
                // Add final datapoints
                if (Boolean(_isContinuation)) {
                    _setDatapoint(SLAPI_DATAID_SESSION_TYPE, SLAPI_DATAKEY_SESSION_CONTINUATION);
                }
                else {
                    _setDatapoint(SLAPI_DATAID_SESSION_TYPE, SLAPI_DATAKEY_SESSION_NORMAL);
                    _isContinuation = true;
                }
                _wsaData.EndTime = _getTicks64();
                var jsonString = null;
                try {
                    jsonString = JSON.stringify(_wsaData);
                }
                catch (e) {
                    ErrorHelper_1.default.log(e);
                }
                // Initialize the session data for continuation session
                _initContinuationSession();
                return jsonString;
            }
        }
        catch (e) {
            ErrorHelper_1.default.log(e);
            return "";
        }
    }
    function _initContinuationSession() {
        _dictStreams = new Array(0);
        _dictDatapoints = new Array(0);
        _numDatapoints = 0;
        _numStreams = 0;
        _streamRowCount = 0;
        _numStreamBytes = 0;
        _numDatapoints = 0;
        var sessID = _wsaData.CorrelationId;
        _wsaData = new WSAData();
        _wsaData.CorrelationId = sessID;
        _createStream(SLAPI_STREAM_ID, 1);
        _isDataAvailableForUpload = false;
    }
    function _isMaxSizeReachedCheck() {
        var size = _numDatapoints * SLAPI_SIZE_DATAPOINT_ENTRY + _numStreamBytes;
        if (size >= SLAPI_MAX_DATA_SIZE) {
            _instance.beacon();
            size = _numDatapoints * SLAPI_SIZE_DATAPOINT_ENTRY + _numStreamBytes;
            return size >= SLAPI_MAX_DATA_SIZE;
        }
        return false;
    }
    function _SetCorrelationId(correlationId) {
        _initialize();
        if (Boolean(_wsaData)) {
            if (correlationId !== null && correlationId !== undefined) {
                _wsaData.CorrelationId = correlationId;
            }
            else {
                _wsaData.CorrelationId = _emptyCorrelationId;
            }
        }
    }
    function _WriteLog(eventName, dictProperties) {
        _initialize();
        if ((!Boolean(eventName)) || (!Boolean(dictProperties))) {
            return;
        }
        if (false) {
            var values = new Array(SLAPI_IDX_PROPERTY_START + 1);
            values[SLAPI_IDX_VERSION] = SLAPI_JSON_VERSION;
            values[SLAPI_IDX_EVENTNAME] = eventName;
            var index = SLAPI_IDX_PROPERTY_START;
            for (var key in dictProperties) {
                var propVal = dictProperties[key];
                if (propVal !== undefined && propVal !== null) {
                    if (propVal instanceof Date) {
                        propVal = propVal.getTime();
                    }
                    values[index++] = key;
                    values[index++] = propVal;
                }
            }
            _addToStream(SLAPI_STREAM_ID, values);
        }
        else if (!window["disableBeaconLogToConsole"]) {
            try {
                console.log("Beacon: Logged to " + eventName + " with properties: " + JSON.stringify(dictProperties));
            }
            catch (error) {
            }
        }
    }
    function _getUploadData() {
        _initialize();
        return _uploadData();
    }
    function _getTicks32() {
        var timeNow = new Date();
        var ticks64 = timeNow.getTime();
        if (_startTicks === 0) {
            _startTicks = ticks64;
        }
        return ((1 + ticks64 - _startTicks) & 0x7FFFFFFF);
    }
    function _getTicks64() {
        var timeNow = new Date();
        var ticks64 = timeNow.getTime();
        ticks64 = ticks64 + SLAPI_MS_BTN_EPOCHS; // Epoch change from 1/1/1070 to 1/1/1601
        ticks64 = ticks64 * 10000; // 1ms to 100ns resolution
        return ticks64;
    }
})(Beacon || (Beacon = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Beacon;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var DebugPriorityLevel;
(function (DebugPriorityLevel) {
    DebugPriorityLevel[DebugPriorityLevel["Low"] = 0] = "Low";
    DebugPriorityLevel[DebugPriorityLevel["Normal"] = 1] = "Normal";
})(DebugPriorityLevel || (DebugPriorityLevel = {}));
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DebugPriorityLevel;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var RUMOneLogger_1 = __webpack_require__(89);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RUMOneLogger_1.APICallPerformanceData;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// OneDrive:IgnoreCodeCoverage
var RUMOneLogger_1 = __webpack_require__(89);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RUMOneLogger_1.ControlPerformanceData;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage
//Intentionally Override the normal camel casing style to title casing style because the schema has to match exactly the server side schema which is Title casing.
//Please do not change back to camel casing.

var RUMOneErrorsSLAPI = (function () {
    function RUMOneErrorsSLAPI() {
        this.Reason = null;
        this.Message = null;
    }
    return RUMOneErrorsSLAPI;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RUMOneErrorsSLAPI;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RequireJSErrorHandler_1 = __webpack_require__(243);
var PerformanceCollection_1 = __webpack_require__(146);
var Signal_1 = __webpack_require__(81);
var ModuleHelper = __webpack_require__(145);
/**
 * Function to load a resource asynchronously which resolves the default export
 * from a given module.
 *
 * This function checks for the presense of a 'default' export in the loaded module
 * and resolves it if present. Otherwise, it assumes the module is a legacy module
 * and returns its identity export.
 *
 * @export
 * @template TExport
 * @param {IModuleDefinition<IModule<TExport>>} moduleDefinition
 * @returns {Promise<TExport>}
 *
 * @example
 *  import MyComponent from '../myComponent/MyComponent';
 *
 *  loadModule<typeof MyComponent>({
 *      path: '../myComponent/MyComponent'
 *      require: require
 *  }).then((myComponentType: typeof MyComponent) => {
 *      let component = new myComponentType();
 *
 *      return component;
 *  })
 */
function loadModule(moduleDefinition) {
    var path = moduleDefinition.path, require = moduleDefinition.require;
    return loadModuleExport({
        path: path,
        require: require,
        getExport: ModuleHelper.getDefaultExport
    });
}
exports.loadModule = loadModule;
/**
 * Function to load a resource asynchronously which resolves directly to the module.
 *
 * @export
 * @template TModule
 * @param {IModuleDefinition<TModule>} exportDefinition
 * @returns {Promise<TModule>}
 *
 * @example
 *  import MyUtilitiesModule = require('../../utilities/MyUtilities');
 *
 *  loadModuleIdentity<typeof MyUtilitiesModule>({
 *      path: '../../utilities/MyUtilities',
 *      require: require
 *  }).then((myUtilities: typeof MyUtilitiesModule) => {
 *      return myUtilities.doStuff();
 *  });
 */
function loadModuleIdentity(exportDefinition) {
    var path = exportDefinition.path, require = exportDefinition.require;
    return load(require, path);
}
exports.loadModuleIdentity = loadModuleIdentity;
/**
 * Function to load a resource asynchronously which resolves a specific export
 * from a given module.
 *
 * @export
 * @template TModule
 * @template TExport
 * @param {IExportDefinition<TModule, TExport>} exportDefinition
 * @returns {Promise<TExport>}
 *
 * @example
 *  import MyUtilitiesModule = require('../../utilities/MyUtilities');
 *
 *  loadModuleExport({
 *      path: '../../utilities/MyUtilities',
 *      require: require,
 *      getExport: (module: typeof MyUtilitiesModule) => module.doStuff
 *  }).then((doStuff: typeof MyUtilitiesModule.doStuff) => {
 *      return doStuff();
 *  });
 */
function loadModuleExport(exportDefinition) {
    var path = exportDefinition.path, require = exportDefinition.require, getExport = exportDefinition.getExport;
    return load(require, path).then(function (module) {
        return getExport(module);
    });
}
exports.loadModuleExport = loadModuleExport;
/**
 * Internal helper to invoke `require` on the input path and log performance and errors.
 *
 * @template TModule
 * @param {IRequire<TModule>} require
 * @param {string} path
 * @returns {Promise<TModule>}
 */
function load(require, path) {
    PerformanceCollection_1.default.mark("Module_" + path, 20);
    var signal = new Signal_1.default();
    require([path], function (module) {
        signal.complete(module);
    }, function (error) {
        RequireJSErrorHandler_1.default.log(error);
        signal.error(error);
    });
    return signal.getPromise();
}


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ModuleLoader_1 = __webpack_require__(251);
exports.loadModule = ModuleLoader_1.loadModule;
exports.loadModuleExport = ModuleLoader_1.loadModuleExport;
exports.loadModuleIdentity = ModuleLoader_1.loadModuleIdentity;
var ModuleHelper_1 = __webpack_require__(145);
exports.getDefaultExport = ModuleHelper_1.getDefaultExport;
exports.getIdentityExport = ModuleHelper_1.getIdentityExport;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

function deserializeQuery(paramsString) {
    var viewParams = {};
    if (paramsString) {
        var paramParts = paramsString.split("&");
        for (var i = 0; i < paramParts.length; i++) {
            var param = paramParts[i].split("=");
            // For query strings only, "+" is a valid substitute for a space, but decodeURIComponent
            // doesn't take this into account.
            if (typeof param[1] !== 'undefined') {
                param[1] = param[1].replace(/\+/g, " ");
            }
            viewParams[param[0]] = decodeURIComponent(param[1]);
        }
    }
    return viewParams;
}
exports.deserializeQuery = deserializeQuery;
function getQueryStringFromUrl(url) {
    return url.substring(url.indexOf('?') + 1);
}
exports.getQueryStringFromUrl = getQueryStringFromUrl;
function getUrlWithoutQueryString(url) {
    return url.substring(0, url.indexOf('?'));
}
exports.getUrlWithoutQueryString = getUrlWithoutQueryString;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ProtocolHandlerEncodeOption;
(function (ProtocolHandlerEncodeOption) {
    ProtocolHandlerEncodeOption[ProtocolHandlerEncodeOption["none"] = 0] = "none";
    ProtocolHandlerEncodeOption[ProtocolHandlerEncodeOption["encodeUrl"] = 1] = "encodeUrl";
    ProtocolHandlerEncodeOption[ProtocolHandlerEncodeOption["encodeCommand"] = 2] = "encodeCommand";
})(ProtocolHandlerEncodeOption = exports.ProtocolHandlerEncodeOption || (exports.ProtocolHandlerEncodeOption = {}));
;
var ProtocolHandlerHelper = (function () {
    function ProtocolHandlerHelper() {
    }
    /**
     * Create protocol handler Url based in inputs to laucch Office Client
     * @param strApp Input appName, like ms-excel
     * @param strUrl Input url of the file.
     * @param command Input open command, like ofv or ofe for view or edit.
     * @param defaultSaveUrl Input to specify save Url. Used for new operation.
     * @param encodeOption Input to specify if we need to encode the whole output url, or only encode the command part of the url.
     * @param isSPO Input to specify if this is for SPO output.
     */
    ProtocolHandlerHelper.CreateProtocolHandlerUrl = function (strApp, strUrl, command, defaultSaveUrl, encodeOption, isSPO) {
        var ret = [];
        // OpenApp="protocol[|UsePlain[|IgnoreCheck]]"/>
        var protocolList = strApp.split('|');
        if (protocolList.length === 2) {
            ret.push(protocolList[0]);
            ret.push(':');
            ret.push(strUrl);
            return ret.join('');
        }
        else if (protocolList.length === 3) {
            strApp = protocolList[0];
        }
        ret.push(strApp);
        ret.push(':');
        ret.push(command);
        if (isSPO && strApp === "ms-excel" && command !== this.protocolCommand.New) {
            ret.push(encodeOption === ProtocolHandlerEncodeOption.encodeCommand ? '%7Cofc' : '|ofc');
        }
        ret.push(encodeOption === ProtocolHandlerEncodeOption.encodeCommand ? '%7Cu%7C' : '|u|');
        ret.push(strUrl);
        if (command === this.protocolCommand.New) {
            ret.push(encodeOption === ProtocolHandlerEncodeOption.encodeCommand ? '%7Cs%7C' : '|s|');
            ret.push(defaultSaveUrl);
        }
        // encode uri when necessary.
        var retUrl = ret.join('');
        return encodeOption === ProtocolHandlerEncodeOption.encodeUrl ? encodeURI(retUrl) : retUrl;
    };
    return ProtocolHandlerHelper;
}());
// tslint:disable-next-line:typedef
ProtocolHandlerHelper.protocolCommand = { View: 'ofv', Edit: 'ofe', New: 'nft' };
exports.ProtocolHandlerHelper = ProtocolHandlerHelper;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ProtocolHandlerHelper;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var ResourceScope_1 = __webpack_require__(148);
var Disposable_1 = __webpack_require__(83);
/**
 * An implementation of IResourceLoader that constructs a {ResolvedResourceFactory} from the type that the load function resolves to.
 */
var ResolvedResourceLoader = (function () {
    function ResolvedResourceLoader(load, dependencies) {
        this._load = load;
        this._dependencies = dependencies;
    }
    ResolvedResourceLoader.prototype.load = function () {
        var _this = this;
        var promise = this._load().then(function (type) {
            return new ResolvedResourceFactory(type, _this._dependencies);
        });
        this.load = function () { return promise; };
        return promise;
    };
    return ResolvedResourceLoader;
}());
exports.ResolvedResourceLoader = ResolvedResourceLoader;
/**
 * An implementation of IResourceFactory that instantiates the passed type, resolving any dependencies from resources.
 */
var ResolvedResourceFactory = (function () {
    function ResolvedResourceFactory(type, dependencies) {
        this._type = type;
        this.dependencies = __assign({}, (type.dependencies || {}), (dependencies || {}));
    }
    ResolvedResourceFactory.prototype.create = function (dependencies) {
        var instance = new this._type({}, dependencies);
        return {
            instance: instance,
            disposable: instance
        };
    };
    return ResolvedResourceFactory;
}());
exports.ResolvedResourceFactory = ResolvedResourceFactory;
/**
 * An implementation of IResourceFactory that provides a constructor for the passed type with dependencies resolved from resources.
 */
var ResolvedResourceTypeFactory = (function () {
    function ResolvedResourceTypeFactory(type, dependencies) {
        this._type = type;
        this.dependencies = __assign({}, (type.dependencies || {}), (dependencies || {}));
    }
    ResolvedResourceTypeFactory.prototype.create = function (dependencies) {
        return {
            instance: ResourceScope_1.getResolvedConstructor(this._type, dependencies)
        };
    };
    return ResolvedResourceTypeFactory;
}());
exports.ResolvedResourceTypeFactory = ResolvedResourceTypeFactory;
/**
 * An implementation of IResourceFactory for classes that have no dependencies and take no parameters.
 */
var SimpleResourceFactory = (function () {
    function SimpleResourceFactory(type) {
        this._type = type;
        this.dependencies = {};
    }
    SimpleResourceFactory.prototype.create = function () {
        var instance = new this._type();
        return {
            instance: instance,
            disposable: Disposable_1.isDisposable(instance) && instance
        };
    };
    return SimpleResourceFactory;
}());
exports.SimpleResourceFactory = SimpleResourceFactory;
var AliasResourceLoader = (function () {
    function AliasResourceLoader(load) {
        this._load = load;
    }
    AliasResourceLoader.prototype.load = function () {
        var promise = this._load().then(function (dependency) {
            return new AliasResourceFactory(dependency);
        });
        this.load = function () { return promise; };
        return promise;
    };
    return AliasResourceLoader;
}());
exports.AliasResourceLoader = AliasResourceLoader;
/**
 * An implementation of IResourceFactory which wraps an existing resource key.
 */
var AliasResourceFactory = (function () {
    function AliasResourceFactory(dependency) {
        this.dependencies = {
            value: dependency.lazy
        };
    }
    AliasResourceFactory.prototype.create = function (dependencies) {
        return {
            instance: dependencies.value()
        };
    };
    return AliasResourceFactory;
}());
exports.AliasResourceFactory = AliasResourceFactory;
function createDefaultResourceKey(require, type, dependencies) {
    return new ResourceScope_1.ResourceKey({
        name: require('module').id,
        factory: new ResolvedResourceFactory(type, dependencies)
    });
}
exports.createDefaultResourceKey = createDefaultResourceKey;
function createDefaultTypeResourceKey(require, type, dependencies) {
    return new ResourceScope_1.ResourceKey({
        name: require('module').id,
        factory: new ResolvedResourceTypeFactory(type, dependencies)
    });
}
exports.createDefaultTypeResourceKey = createDefaultTypeResourceKey;
__export(__webpack_require__(148));


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:CoverageThreshold(100)

var CircularBuffer = (function () {
    function CircularBuffer(size) {
        this._length = 0;
        this._head = -1;
        if (size <= 0) {
            throw new Error("Size must be positive");
        }
        this._size = size;
        this._buffer = new Array(size);
    }
    CircularBuffer.prototype.push = function (item) {
        if (this._length < this._size) {
            this._length++;
        }
        this._head++;
        if (this._head === this._size) {
            this._head = 0;
        }
        this._buffer[this._head] = item;
    };
    CircularBuffer.prototype.popOldest = function () {
        if (this._length === 0) {
            return null;
        }
        var tail = (this._head - this._length + 1 + this._size) % this._size;
        this._length--;
        return this._buffer[tail];
    };
    return CircularBuffer;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CircularBuffer;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var StringHelper = __webpack_require__(23);
var StringUtilities_resx_1 = __webpack_require__(150);
var oneKiloByte = 1024;
var oneMegaByte = 1048576;
var oneGigaByte = 1073741824;
var oneTeraByte = 1099511627776;
var DriveSpaceHelper = (function () {
    function DriveSpaceHelper() {
    }
    /**
     * Creates a display string for the given number in bytes.
     * This function produces a string value meant to mimic that displyed by file explorer.
     */
    DriveSpaceHelper.getDisplayString = function (value, options) {
        if (options === void 0) { options = {}; }
        if (typeof value !== 'number' || (options.ignoreZero && value === 0) || value < 0) {
            return '';
        }
        if (value === 1) {
            return StringHelper.format(StringUtilities_resx_1.strings.fileSizeBytesSingular);
        }
        var info = this._getInfo(value);
        var numberString = this._trimNumber(info.value, options.trimDecimal);
        return StringHelper.format(info.template, numberString);
    };
    DriveSpaceHelper._getInfo = function (value) {
        // 1 byte is already handled
        // 0 bytes, 2 bytes - 1023 bytes
        if (value < oneKiloByte) {
            return { template: StringUtilities_resx_1.strings.fileSizeBytesPlural, value: value };
        }
        // 1KB - 999 KB
        if (value < 1000 * oneKiloByte) {
            return { template: StringUtilities_resx_1.strings.fileSizeKB, value: value / oneKiloByte };
        }
        // 0.97 MB - 999 MB
        if (value < 1000 * oneMegaByte) {
            return { template: StringUtilities_resx_1.strings.fileSizeMB, value: value / oneMegaByte };
        }
        // 0.97 GB - 999 GB
        if (value < 1000 * oneGigaByte) {
            return { template: StringUtilities_resx_1.strings.fileSizeGB, value: value / oneGigaByte };
        }
        // 0.97 TB ->
        return { template: StringUtilities_resx_1.strings.fileSizeTB, value: value / oneTeraByte };
    };
    DriveSpaceHelper._trimZeroes = function (value, decimalPlaces) {
        var str = value.toFixed(decimalPlaces);
        for (var i = 0; i < decimalPlaces; i++) {
            if (str[str.length - 1] === '0') {
                str = str.substring(0, str.length - 1);
            }
            else {
                break;
            }
        }
        if (str[str.length - 1] === '.') {
            str = str.substring(0, str.length - 1);
        }
        return str;
    };
    DriveSpaceHelper._trimNumber = function (value, trimDecimal) {
        // TODO: switch to toLocaleString for entire function when we update phantomJS
        var unformattedString;
        // 12.00 -> 12
        if (value === Math.floor(value)) {
            unformattedString = value.toFixed(0);
        }
        else if (value >= 100) {
            // Removes the mantissa from the value (ex: 456.789 -> 457)
            unformattedString = value.toFixed(0);
        }
        else if (value >= 10) {
            // 45.678 -> 45.7
            unformattedString = trimDecimal ? this._trimZeroes(value, 1) : value.toFixed(1);
        }
        else {
            // 4.5678 -> 4.57
            unformattedString = trimDecimal ? this._trimZeroes(value, 2) : value.toFixed(2);
        }
        // Since Number(num.toFixed) can trim decimals even when unwanted,
        // get the radix character and replace it manually
        var radix = (1.2).toLocaleString().replace(/\d+/g, '');
        return unformattedString.replace(".", radix);
    };
    return DriveSpaceHelper;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DriveSpaceHelper;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var HslColor_1 = __webpack_require__(152);
var RgbaColor_1 = __webpack_require__(24);
// Various constants used for generated shades of a color.
var WhiteShadeTable = [0.95, 0.85, 0.75, 0.65, 0.50];
var BlackTintTable = [0.50, 0.65, 0.75, 0.85, 0.95];
var ColorTintTable = [0.20, 0.40, 0.60];
var ColorShadeTable = [0.75, 0.50];
var LumTintTable = [0.10, 0.25, 0.50, 0.75, 0.90];
var LumShadeTable = [0.90, 0.75, 0.50, 0.25, 0.10];
var c_LuminanceLow = 0.2;
var c_LuminanceHigh = 0.8;
var rgbaMax = RgbaColor_1.default.maxComponent;
var rgbaWhite = RgbaColor_1.default.fromRgba(rgbaMax, rgbaMax, rgbaMax);
var rgbaBlack = RgbaColor_1.default.fromRgba(0, 0, 0);
/** Shades of a given color, from Lightest to Darkest. */
var Shades;
(function (Shades) {
    Shades[Shades["Unshaded"] = 0] = "Unshaded";
    Shades[Shades["Lightest"] = 1] = "Lightest";
    Shades[Shades["Lighter"] = 2] = "Lighter";
    Shades[Shades["Medium"] = 3] = "Medium";
    Shades[Shades["Darker"] = 4] = "Darker";
    Shades[Shades["Darkest"] = 5] = "Darkest";
})(Shades = exports.Shades || (exports.Shades = {}));
/**
 * Returns true if the argument is a valid Shades value
 * @param {Shades} shade The Shades value to validate.
 */
function _isValidShade(shade) {
    'use strict';
    return (shade >= Shades.Unshaded) && (shade <= Shades.Darkest);
}
/**
 * Given an RgbaColor and a shade specification, generates the requested shade of the color.
 * @param {RgbaColor} color The base color whose shades are to be computed
 * @param {Shades} shade The shade of the base color to compute.
 */
function getShade(color, shade) {
    'use strict';
    if (!color) {
        return null;
    }
    if (shade === Shades.Unshaded || !_isValidShade(shade)) {
        return RgbaColor_1.default.fromRgba(color.R, color.G, color.B, color.A);
    }
    var hsl = HslColor_1.default.fromRgba(color);
    var lum = hsl.lum;
    var tableIndex = shade - 1;
    if (RgbaColor_1.default.equals(color, rgbaWhite)) {
        hsl.darken(WhiteShadeTable[tableIndex]);
    }
    else if (RgbaColor_1.default.equals(color, rgbaBlack)) {
        hsl.lighten(BlackTintTable[tableIndex]);
    }
    else if (lum < c_LuminanceLow) {
        hsl.lighten(LumTintTable[tableIndex]);
    }
    else if (lum > c_LuminanceHigh) {
        hsl.darken(LumShadeTable[tableIndex]);
    }
    else {
        if (tableIndex < ColorTintTable.length) {
            hsl.lighten(ColorTintTable[tableIndex]);
        }
        else {
            hsl.darken(ColorShadeTable[tableIndex - ColorTintTable.length]);
        }
    }
    color = hsl.toRgbaColor();
    return color;
}
exports.getShade = getShade;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var RgbaColor_1 = __webpack_require__(24);
var ThemeCache_1 = __webpack_require__(153);
var Promise_1 = __webpack_require__(51);
var Engagement_event_1 = __webpack_require__(54);
var Qos_event_1 = __webpack_require__(33);
/**
 * Provides theme data, either from the local cache or from the server.
 */
var ThemeProvider = (function () {
    /**
     * Constructs a ThemeProvider which acts like the provided loadData function but with caching.
     * @param {() => Promise<IThemeData>} loadData Used to load data on a cache miss.
     */
    function ThemeProvider(loadData) {
        this._loadData = loadData;
    }
    /**
     * Given a URL, returns a string value which can be safely used as a
     * background-image value in a CSS rule. If the url is falsey, this
     * returns "none" to specify no background-image.
     * @param {string} url The URL of a background image.
     */
    ThemeProvider._makeCssUrl = function (url) {
        var cssUrlValue = "none";
        if (url) {
            cssUrlValue = 'url("' +
                ThemeProvider._escapeQuotesAndParentheses(url) +
                '")';
        }
        return cssUrlValue;
    };
    /**
     * Escapes single- and double-quotes along with parentheses so that the
     * resulting string is safe to use in a CSS background-image: url()
     * @param {string} str The string to escape.
     */
    ThemeProvider._escapeQuotesAndParentheses = function (str) {
        var replacements = { "'": "%27", '"': "%22", "(": "%28", ")": "%29" };
        var result = null;
        if (str != null) {
            result = str.replace(/(['"\(\)])/gm, function (match, capture) {
                return replacements[capture];
            });
        }
        return result;
    };
    /**
     * Loads the theme data and returns a map from theme tokens to replacement values.
     * Suitable for use with loadTheme in load-themed-styles.
     * @param {string} cacheToken Cache token used to validate cached data.
     * @param {boolean} forceUpdate Whether to force fresh data to be loaded and cached.
     */
    ThemeProvider.prototype.loadThemeTokenMap = function (cacheToken, forceUpdate) {
        return this.loadThemeData(cacheToken, forceUpdate).then(function (themeData) {
            var themeValues;
            if (themeData && themeData.palette) {
                themeValues = {};
                var palette = themeData.palette;
                for (var colorSlot in palette) {
                    var rgbaValue = palette[colorSlot];
                    themeValues[colorSlot] = rgbaValue ? RgbaColor_1.default.toHtmlString(rgbaValue) : null;
                }
                themeValues["backgroundImageUri"] =
                    ThemeProvider._makeCssUrl(themeData.backgroundImageUri);
            }
            return themeValues;
        }, function (error) { return null; }); // on error, return null
    };
    /**
     * Loads the theme data from the cache or via the a loadData method.
     * @param {string} cacheToken Cache token used to validate cached data.
     * @param {boolean} forceUpdate Whether to force fresh data to be loaded and cached.
     */
    ThemeProvider.prototype.loadThemeData = function (cacheToken, forceUpdate) {
        if (!forceUpdate && this._dataPromise) {
            return this._dataPromise;
        }
        var _this = this;
        var failureResultCode = null;
        var failureResultType = Qos_event_1.ResultTypeEnum.Failure;
        this._dataPromise = Qos_event_1.Qos.instrumentPromise(
        /*startSchema*/ { name: "ThemeProvider.LoadData" }, 
        /*createPromise*/ function () { return new Promise_1.default(function loadDataOnExecute(complete, error) {
            var previousData = null;
            if (!forceUpdate) {
                // Checks if we have valid cached data before returning it.
                previousData = ThemeCache_1.default.getCachedTheme(cacheToken);
            }
            // If we have previous data and an update is not forced, use that data.
            if (previousData) {
                Engagement_event_1.Engagement.logData({ name: "ThemeProvider.DataFromCache" });
                complete(previousData);
            }
            else {
                if (forceUpdate) {
                    Engagement_event_1.Engagement.logData({ name: "ThemeProvider.ForceUpdateData" });
                }
                Engagement_event_1.Engagement.logData({ name: "ThemeProvider.DataFromServer" });
                // Get updated data. Might result in a server call.
                _this._loadData(forceUpdate).done(function onComplete(themeData) {
                    if (themeData) {
                        if (themeData.cacheToken) {
                            ThemeCache_1.default.updateThemeCache(themeData, cacheToken);
                            complete(themeData);
                        }
                        else {
                            //TODO what happens if error() is undefined?
                            failureResultCode = "NoCacheToken";
                            if (error) {
                                error("Theme data with no CacheToken returned");
                            }
                        }
                    }
                    else {
                        failureResultCode = "NoData";
                        if (error) {
                            error("No model returned");
                        }
                    }
                }, function onError(err) {
                    if (Promise_1.default.isCanceled(error)) {
                        failureResultCode = "Canceled";
                        failureResultType = Qos_event_1.ResultTypeEnum.ExpectedFailure;
                    }
                    else {
                        failureResultCode = "ServerLoadFailure";
                    }
                    if (error) {
                        error(err);
                    }
                });
            }
        }); }, 
        /*getCompleteSchema*/ null, 
        /*getErrorSchema*/ function getErrorSchema(error) {
            if (Promise_1.default.isCanceled(error)) {
                failureResultType = Qos_event_1.ResultTypeEnum.ExpectedFailure;
                failureResultCode = "Canceled";
            }
            return {
                resultType: failureResultType,
                resultCode: failureResultCode || "Other",
                error: error
            };
        });
        return this._dataPromise;
    };
    return ThemeProvider;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ThemeProvider;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OneDrive:IgnoreCodeCoverage

var FabricTheming_1 = __webpack_require__(151);
var RgbaColor_1 = __webpack_require__(24);
var UriEncoding_1 = __webpack_require__(84);
/**
 * Utility methods which can be used to load the theme of a SharePoint site.
 */
var WebTheme = (function () {
    function WebTheme() {
    }
    /**
     * Constructs the URL of a REST endpoint which will return the web theme.
     * @param {IWebContextInfo} webContextInfo Context information about the web.
     * @param {string} cultureName Current UI culture.
     * @param {string} themeOverride URL to a temporary override theme (e.g. preview).
     */
    WebTheme.makeWebThemeRestUrl = function (webServerRelativeUrl, cultureName, themeOverride) {
        "use strict";
        var webUrl = webServerRelativeUrl;
        if (webUrl && webUrl[webUrl.length - 1] === '/') {
            // Trim trailing slash.
            webUrl = webUrl.substring(0, webUrl.length - 1);
        }
        webUrl = UriEncoding_1.default.escapeUrlForCallback(webUrl);
        var webThemeRestEndpoint = UriEncoding_1.default.escapeUrlForCallback(webUrl) +
            '/_api/SP.Web.GetContextWebThemeData?noImages=true&lcid=' +
            UriEncoding_1.default.encodeURIComponent(cultureName);
        if (themeOverride) {
            webThemeRestEndpoint += "&ThemeOverride=" + UriEncoding_1.default.encodeURIComponent(themeOverride);
        }
        return webThemeRestEndpoint;
    };
    /**
     * Constructs the URL of a REST endpoint which will return the web theme.
     * @param {IWebContextInfo} webContextInfo Context information about the web.
     */
    WebTheme.processWebThemeRestResponse = function (responseText) {
        // This could throw if the handler returns an HTML error page or invalis JSON.
        // DataSource will count that as an error and call the error callback.
        "use strict";
        var response = JSON.parse(responseText);
        var rawThemeData;
        if (response && response.d && response.d.GetContextWebThemeData) {
            rawThemeData = JSON.parse(response.d.GetContextWebThemeData);
        }
        var themeData = WebTheme.processRawThemeData(rawThemeData);
        return themeData;
    };
    /**
     * Converts an IThemeDataRaw into an IThemeData.
     * @param {IThemeDataRaw} themeData Raw theme data to process.
     */
    WebTheme.processRawThemeData = function (themeData) {
        "use strict";
        if (themeData) {
            var coerceToColor = WebTheme.coerceToColor;
            var colors = {};
            var inputColors = themeData.Palette ? themeData.Palette.Colors : {};
            colors = WebTheme.convertColorsToRgba(inputColors);
            var fabricColors = colors;
            if (!fabricColors['themePrimary']) {
                fabricColors = FabricTheming_1.default.generateFabricColors(colors['ContentAccent1'], themeData.IsInverted);
                var pageBG = coerceToColor(colors['PageBackground']) || null;
                var bgOverlay = coerceToColor(colors['BackgroundOverlay']) || null;
                var alpha40 = Math.round(0.4 * RgbaColor_1.default.maxComponent);
                fabricColors['white'] = pageBG;
                // RgbaColor.fromRgba and RgbaColor.clone both return new objects.
                // This is important for avoiding duplicate filtering logic in the caching layer.
                fabricColors['primaryBackground'] = RgbaColor_1.default.clone(pageBG);
                fabricColors['primaryText'] = fabricColors['primaryText'] || coerceToColor('#333');
                fabricColors['whiteTranslucent40'] = pageBG && RgbaColor_1.default.fromRgba(pageBG.R, pageBG.G, pageBG.B, alpha40);
                fabricColors['backgroundOverlay'] = bgOverlay;
                fabricColors['suiteBarBackground'] = coerceToColor(colors['SuiteBarBackground']) || null;
                fabricColors['suiteBarText'] = coerceToColor(colors['SuiteBarText']) || null;
                fabricColors['suiteBarDisabledText'] = coerceToColor(colors['SuiteBarDisabledText']) || null;
                fabricColors['topBarBackground'] = coerceToColor(colors['TopBarBackground']) || null;
                fabricColors['topBarText'] = coerceToColor(colors['TopBarText']) || null;
                fabricColors['topBarHoverText'] = coerceToColor(colors['TopBarHoverText']) || null;
                fabricColors['dialogBorder'] = coerceToColor(colors['DialogBorder']) || null;
            }
            return {
                backgroundImageUri: themeData.BackgroundImageUri,
                cacheToken: themeData.ThemeCacheToken,
                isDefault: themeData.IsDefault,
                isInverted: themeData.IsInverted,
                palette: fabricColors,
                version: themeData.Version
            };
        }
        return {
            backgroundImageUri: "",
            cacheToken: "",
            isDefault: true,
            isInverted: false,
            palette: {},
            version: ""
        };
    };
    WebTheme.convertColorsToRgba = function (colors) {
        var convertedColors = {};
        for (var colorKey in colors) {
            if (colors.hasOwnProperty(colorKey)) {
                var colorValue = WebTheme.coerceToColor(colors[colorKey]);
                // TODO: console.warn if colorValue is undefined?
                if (colorValue) {
                    convertedColors[colorKey] = colorValue;
                }
            }
        }
        return convertedColors;
    };
    /**
     * Coerces an HTML color string or a color object in raw web theme data into an RgbaColor.
     * @param {any} toColor Object to be converted into an RgbaColor.
     */
    WebTheme.coerceToColor = function (toColor) {
        "use strict";
        var resultColor;
        // Use duck typing to extract a color
        if (!toColor) {
            resultColor = null;
        }
        else if (typeof toColor === "string" || toColor instanceof String) {
            resultColor = RgbaColor_1.default.fromHtmlColor(String(toColor));
        }
        else if ("DefaultColor" in toColor) {
            resultColor = WebTheme.coerceToColor(toColor["DefaultColor"]);
        }
        else if ("R" in toColor && "G" in toColor && "B" in toColor) {
            resultColor = RgbaColor_1.default.fromRgba(toColor.R, toColor.G, toColor.B, toColor.A);
        }
        return resultColor;
    };
    return WebTheme;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = WebTheme;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Simplified implementation of a URI parser which does not attempt decoding of segments,
 * handling of query strings, or separation of the fragment.
 *
 * This class makes several assumptions about the format of input URLs:
 * - Absolute URLs begin with '<scheme>://<host>'
 * - Relative URLs being with '/'
 * - URLs never have a trailing '/'
 *
 * @class SimpleUri
 */
var SimpleUri = (function () {
    /**
     * Creates an instance of SimpleUri.
     *
     * @param {string} value
     */
    function SimpleUri(value) {
        if (value === void 0) { value = ''; }
        this._value = value;
    }
    Object.defineProperty(SimpleUri.prototype, "format", {
        /**
         * Determines the format of the URL.
         *
         * @readonly
         * @type {UriFormat}
         *
         * @example
         *  expect(new SimpleUri('/').format).to.equal(UriFormat.serverRelative);
         * @example
         *  expect(new SimpleUri('https://test').format).to.equal(UriFormat.absolute);
         * @example
         *  expact(new SimpleUri('test').format).to.equal(UriFormat.relative);
         */
        get: function () {
            return this._getFormat();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleUri.prototype, "authority", {
        /**
         * Gets the authority component of the URI, if the URI is fully-qualified.
         * The authority is formatted as
         * '<scheme>://<host>'
         * and never has a trailing '/'.
         *
         * @readonly
         * @type {string}
         *
         * @example
         *  expect(new SimpleUri('/').authority).to.equal('');
         * @example
         *  expect(new SimpleUri('https://test').authority).to.equal('https://test');
         * @example
         *  expect(new SimpleUri('https://test/').authority).to.equal('https://test');
         * @example
         *  expect(new SimpleUri('/bad/scheme://').authority).to.equal('');
         */
        get: function () {
            return this._getAuthority();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleUri.prototype, "domain", {
        /**
         * Gets the domain of the URI, which is everything in the authority after
         * the scheme and protocol.
         *
         * @readonly
         * @type {string}
         * @memberOf SimpleUri
         *
         * @example
         *  expect(new SimpleUri('/').domain).to.equal('');
         * @example
         *  expect(new SimpleUri('https://test').domain).to.equal('test');
         * @example
         *  expect(new SimpleUri('https://test/').domain).to.equal('test');
         */
        get: function () {
            return this._getDomain();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleUri.prototype, "path", {
        /**
         * Gets the path of the URI, which is everything after the authority.
         * If the URI has no authority, this returns the entire URI.
         * If there is only an authority, this returns ''.
         *
         * @readonly
         * @type {string}
         *
         * @example
         *  expect(new SimpleUri('https://test').path).to.equal('');
         * @example
         *  expect(new SimpleUri('/').path).to.equal('/');
         * @example
         *  expect(new SimpleUri('https://test/').path).to.equal('/');
         * @example
         *  expect(new SimpleUri('/bad/scheme://').path).to.equal('/bad/scheme://');
         */
        get: function () {
            return this._getPath();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleUri.prototype, "segments", {
        /**
         * Gets the segments of the path.
         * If there is no path, this is an empty array.
         * Otherwise, this returns all segments after the first '/'.
         *
         * @readonly
         * @type {string[]}
         *
         * @example
         *  expect(new SimpleUri('https://test').segments).to.deep.equal([]);
         * @example
         *  expect(new SimpleUri('/').segments).to.deep.equal(['']);
         * @example
         *  expect(new SimpleUri('/foo').segments).to.deep.equal(['foo']);
         * @example
         *  expect(new SimpleUri('/foo/').segments).to.deep.equal(['foo', '']);
         * @example
         *  expect(new SimpleUri('/foo/bar').segments).to.deep.equal(['foo', 'bar']);
         * @example
         *  expect(new SimpleUri('/bad/scheme://').segments).to.deep.equal(['bad', 'scheme:', '', '']);
         */
        get: function () {
            return this._getSegments();
        },
        enumerable: true,
        configurable: true
    });
    SimpleUri.prototype._getFormat = function () {
        var format;
        if (this._getAuthority()) {
            format = 0 /* absolute */;
        }
        else {
            var path = this._getPath();
            if (path.indexOf('/') === 0) {
                format = 2 /* serverRelative */;
            }
            else {
                format = 1 /* relative */;
            }
        }
        this._getFormat = function () { return format; };
        return format;
    };
    SimpleUri.prototype._getAuthority = function () {
        var authority;
        var endIndexOfRootDelimeter = this._getEndIndexOfRootDelimeter();
        if (endIndexOfRootDelimeter > -1) {
            var indexOfNextSegment = this._value.indexOf('/', endIndexOfRootDelimeter);
            if (indexOfNextSegment > -1) {
                authority = this._value.substring(0, indexOfNextSegment);
            }
            else {
                authority = this._value;
            }
        }
        else {
            authority = '';
        }
        this._getAuthority = function () { return authority; };
        return authority;
    };
    SimpleUri.prototype._getDomain = function () {
        var domain;
        var authority = this._getAuthority();
        if (authority) {
            var endIndexOfRootDelimeter = this._getEndIndexOfRootDelimeter();
            domain = authority.substring(endIndexOfRootDelimeter);
        }
        else {
            domain = '';
        }
        this._getDomain = function () { return domain; };
        return domain;
    };
    SimpleUri.prototype._getPath = function () {
        var path;
        var endIndexOfSchemeDelimeter = this._getEndIndexOfRootDelimeter();
        if (endIndexOfSchemeDelimeter > -1) {
            var indexOfNextSegment = this._value.indexOf('/', endIndexOfSchemeDelimeter);
            if (indexOfNextSegment > -1) {
                path = this._value.substring(indexOfNextSegment);
            }
            else {
                path = '';
            }
        }
        else {
            path = this._value;
        }
        this._getPath = function () { return path; };
        return path;
    };
    SimpleUri.prototype._getSegments = function () {
        var path = this._getPath();
        var segments = path.split('/');
        this._getSegments = function () { return segments; };
        return segments;
    };
    SimpleUri.prototype._getEndIndexOfRootDelimeter = function () {
        var endIndexOfRootDelimeter;
        var rootDelimeter = '//';
        var indexOfRootDelimeter = this._value.indexOf(rootDelimeter);
        var indexOfPathDelimeter = this._value.indexOf('/');
        if (indexOfRootDelimeter > -1 && indexOfRootDelimeter <= indexOfPathDelimeter) {
            endIndexOfRootDelimeter = indexOfRootDelimeter + rootDelimeter.length;
        }
        else {
            endIndexOfRootDelimeter = -1;
        }
        this._getEndIndexOfRootDelimeter = function () { return endIndexOfRootDelimeter; };
        return endIndexOfRootDelimeter;
    };
    return SimpleUri;
}());
exports.SimpleUri = SimpleUri;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SimpleUri;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Async_1 = __webpack_require__(15);
var ErrorHelper_1 = __webpack_require__(9);
var ObjectUtil_1 = __webpack_require__(17);
var XHR = (function () {
    function XHR(options) {
        this._async = new Async_1.default(this);
        var url = options.url, _a = options.requestTimeoutInMS, requestTimeoutInMS = _a === void 0 ? XHR.DEFAULT_TIMEOUT_MS : _a, postData = options.json, _b = options.headers, headers = _b === void 0 ? {} : _b, _c = options.withCredentials, withCredentials = _c === void 0 ? false : _c, _d = options.needsCors, needsCors = _d === void 0 ? false : _d, progressCallback = options.onProgress, uploadProgressCallback = options.onUploadProgress;
        var _e = options.method, method = _e === void 0 ? postData ? 'POST' : 'GET' : _e;
        this._url = url;
        this._requestTimeoutInMS = requestTimeoutInMS;
        this._postData = postData;
        this._headers = headers;
        this._method = method;
        this._withCredentials = withCredentials;
        this._needsCors = needsCors;
        this._progressCallback = progressCallback;
        this._uploadProgressCallback = uploadProgressCallback;
    }
    XHR.prototype.abort = function (isCancelled) {
        var aborted = this._abortRequest();
        if (aborted && !isCancelled) {
            this._callFailureCallback(this._request, -3 /* abort */, false);
        }
    };
    XHR.prototype.start = function (successCallback, failureCallback) {
        var _this = this;
        this._successCallback = successCallback;
        this._failureCallback = failureCallback;
        var _a = this, method = _a._method, headers = _a._headers;
        try {
            this._request = this._getRequest();
            var _b = this, progressCallback_1 = _b._progressCallback, uploadProgressCallback_1 = _b._uploadProgressCallback, request_1 = _b._request;
            if (progressCallback_1) {
                request_1.onprogress = function (event) {
                    try {
                        progressCallback_1(event);
                    }
                    catch (error) {
                        ErrorHelper_1.default.logError(error);
                    }
                };
            }
            if (uploadProgressCallback_1) {
                request_1.upload.onprogress = function (event) {
                    try {
                        uploadProgressCallback_1(event);
                    }
                    catch (error) {
                        ErrorHelper_1.default.logError(error);
                    }
                };
            }
            this._async.setTimeout(function () {
                // Check if we havent logged this event already
                if (!_this._completed) {
                    _this._timeoutCallback();
                }
            }, this._requestTimeoutInMS);
            // Report Qos on the actual qos calls
            request_1.onreadystatechange = function () {
                // Check if we havent logged this event in a timeout
                if (!_this._completed) {
                    var DONE = 4; // Default done readystate
                    try {
                        DONE = request_1.DONE || 4;
                    }
                    catch (e) {
                    }
                    if (request_1.readyState === DONE) {
                        _this._requestEndCallback();
                    }
                }
            };
            request_1.open(method, this._url, true);
            if ("withCredentials" in request_1) {
                request_1.withCredentials = this._withCredentials;
            }
            // Headers have to be set after open is called
            for (var x in headers) {
                request_1.setRequestHeader(x, headers[x]);
            }
            request_1.send(this._postData);
        }
        catch (error) {
            ErrorHelper_1.default.logError(error, {
                origin: location ? location.origin : 'unknown',
                withCredentials: this._withCredentials,
                requestUrl: this._url,
                headers: ObjectUtil_1.safeSerialize(headers),
                method: method
            });
            // abort the request and set the exception status code
            this._abortRequest();
            this._callFailureCallback(this._request, -1 /* exception */, false);
        }
    };
    XHR.prototype._getRequest = function () {
        var _this = this;
        if (!this._needsCors || !window['XDomainRequest']) {
            return new XMLHttpRequest();
        }
        // This is only needed for IE 9 to support CORS requests
        // Note: we can not set headers on XDomainRequest
        var request = new XDomainRequest();
        request.setRequestHeader = function () { };
        request.onprogress = function () { };
        request.ontimeout = function () { };
        request.onload = function () {
            _this._requestEndCallback();
        };
        return request;
    };
    XHR.prototype._abortRequest = function () {
        var actuallyAborted = false;
        if (!this._completed) {
            this._completed = true;
            // Clear the timeout for the request
            this._async.dispose();
            // Cancel the request
            try {
                if (this._request) {
                    this._request.abort();
                }
            }
            catch (error) {
            }
            actuallyAborted = true;
        }
        return actuallyAborted;
    };
    XHR.prototype._timeoutCallback = function () {
        if (!this._completed) {
            this._abortRequest();
            this._callFailureCallback(this._request, -2 /* timeout */, true);
        }
    };
    XHR.prototype._callSuccessCallback = function (xhr, statusCode) {
        try {
            if (this._successCallback) {
                this._successCallback(xhr, statusCode);
            }
        }
        catch (error) {
            ErrorHelper_1.default.log(error);
        }
    };
    XHR.prototype._callFailureCallback = function (xhr, statusCode, timeout) {
        try {
            if (this._failureCallback) {
                this._failureCallback(xhr, statusCode, timeout);
            }
        }
        catch (error) {
            ErrorHelper_1.default.log(error);
        }
    };
    XHR.prototype._requestEndCallback = function () {
        if (!this._completed) {
            this._completed = true;
            var status_1 = -1 /* exception */;
            try {
                // Clear the timeout for the request
                this._async.dispose();
                try {
                    status_1 = this._request.status;
                }
                catch (error) {
                }
            }
            catch (error) {
                status_1 = -1 /* exception */;
                ErrorHelper_1.default.log(error);
            }
            if (status_1 < 400 && status_1 > 0) {
                this._callSuccessCallback(this._request, status_1);
            }
            else {
                this._callFailureCallback(this._request, status_1, false);
            }
        }
    };
    return XHR;
}());
XHR.DEFAULT_TIMEOUT_MS = 30000;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = XHR;


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (exports) {'use strict';
  //shared pointer
  var i;
  //shortcuts
  var defineProperty = Object.defineProperty, is = function(a,b) { return (a === b) || (a !== a && b !== b) };


  //Polyfill global objects
  if (typeof WeakMap == 'undefined') {
    exports.WeakMap = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakMap#clear():
      clear: sharedClear,
      // WeakMap#get(key:void*):void*
      get: sharedGet,
      // WeakMap#has(key:void*):boolean
      has: mapHas,
      // WeakMap#set(key:void*, value:void*):void
      set: sharedSet
    }, true);
  }

  if (typeof Map == 'undefined' || typeof ((new Map).values) !== 'function' || !(new Map).values().next) {
    exports.Map = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      //:was Map#get(key:void*[, d3fault:void*]):void*
      // Map#has(key:void*):boolean
      has: mapHas,
      // Map#get(key:void*):boolean
      get: sharedGet,
      // Map#set(key:void*, value:void*):void
      set: sharedSet,
      // Map#keys(void):Iterator
      keys: sharedKeys,
      // Map#values(void):Iterator
      values: sharedValues,
      // Map#entries(void):Iterator
      entries: mapEntries,
      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
      forEach: sharedForEach,
      // Map#clear():
      clear: sharedClear
    });
  }

  if (typeof Set == 'undefined' || typeof ((new Set).values) !== 'function' || !(new Set).values().next) {
    exports.Set = createCollection({
      // Set#has(value:void*):boolean
      has: setHas,
      // Set#add(value:void*):boolean
      add: sharedAdd,
      // Set#delete(key:void*):boolean
      'delete': sharedDelete,
      // Set#clear():
      clear: sharedClear,
      // Set#keys(void):Iterator
      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
      // Set#values(void):Iterator
      values: sharedValues,
      // Set#entries(void):Iterator
      entries: setEntries,
      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
      forEach: sharedForEach
    });
  }

  if (typeof WeakSet == 'undefined') {
    exports.WeakSet = createCollection({
      // WeakSet#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakSet#add(value:void*):boolean
      add: sharedAdd,
      // WeakSet#clear():
      clear: sharedClear,
      // WeakSet#has(value:void*):boolean
      has: setHas
    }, true);
  }


  /**
   * ES6 collection constructor
   * @return {Function} a collection class
   */
  function createCollection(proto, objectOnly){
    function Collection(a){
      if (!this || this.constructor !== Collection) return new Collection(a);
      this._keys = [];
      this._values = [];
      this._itp = []; // iteration pointers
      this.objectOnly = objectOnly;

      //parse initial iterable argument passed
      if (a) init.call(this, a);
    }

    //define size for non object-only collections
    if (!objectOnly) {
      defineProperty(proto, 'size', {
        get: sharedSize
      });
    }

    //set prototype
    proto.constructor = Collection;
    Collection.prototype = proto;

    return Collection;
  }


  /** parse initial iterable argument passed */
  function init(a){
    var i;
    //init Set argument, like `[1,2,3,{}]`
    if (this.add)
      a.forEach(this.add, this);
    //init Map argument like `[[1,2], [{}, 4]]`
    else
      a.forEach(function(a){this.set(a[0],a[1])}, this);
  }


  /** delete */
  function sharedDelete(key) {
    if (this.has(key)) {
      this._keys.splice(i, 1);
      this._values.splice(i, 1);
      // update iteration pointers
      this._itp.forEach(function(p) { if (i < p[0]) p[0]--; });
    }
    // Aurora here does it while Canary doesn't
    return -1 < i;
  };

  function sharedGet(key) {
    return this.has(key) ? this._values[i] : undefined;
  }

  function has(list, key) {
    if (this.objectOnly && key !== Object(key))
      throw new TypeError("Invalid value used as weak collection key");
    //NaN or 0 passed
    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);){}
    else i = list.indexOf(key);
    return -1 < i;
  }

  function setHas(value) {
    return has.call(this, this._values, value);
  }

  function mapHas(value) {
    return has.call(this, this._keys, value);
  }

  /** @chainable */
  function sharedSet(key, value) {
    this.has(key) ?
      this._values[i] = value
      :
      this._values[this._keys.push(key) - 1] = value
    ;
    return this;
  }

  /** @chainable */
  function sharedAdd(value) {
    if (!this.has(value)) this._values.push(value);
    return this;
  }

  function sharedClear() {
    (this._keys || 0).length =
    this._values.length = 0;
  }

  /** keys, values, and iterate related methods */
  function sharedKeys() {
    return sharedIterator(this._itp, this._keys);
  }

  function sharedValues() {
    return sharedIterator(this._itp, this._values);
  }

  function mapEntries() {
    return sharedIterator(this._itp, this._keys, this._values);
  }

  function setEntries() {
    return sharedIterator(this._itp, this._values, this._values);
  }

  function sharedIterator(itp, array, array2) {
    var p = [0], done = false;
    itp.push(p);
    return {
      next: function() {
        var v, k = p[0];
        if (!done && k < array.length) {
          v = array2 ? [array[k], array2[k]]: array[k];
          p[0]++;
        } else {
          done = true;
          itp.splice(itp.indexOf(p), 1);
        }
        return { done: done, value: v };
      }
    };
  }

  function sharedSize() {
    return this._values.length;
  }

  function sharedForEach(callback, context) {
    var it = this.entries();
    for (;;) {
      var r = it.next();
      if (r.done) break;
      callback.call(context, r.value[1], r.value[0], this);
    }
  }

})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var require;var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.1.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = __webpack_require__(207);
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
      var parent = this;
      var state = parent._state;

      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
        return this;
      }

      var child = new this.constructor(lib$es6$promise$$internal$$noop);
      var result = parent._result;

      if (state) {
        var callback = arguments[state - 1];
        lib$es6$promise$asap$$asap(function(){
          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
        });
      } else {
        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }
    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
      if (maybeThenable.constructor === promise.constructor &&
          then === lib$es6$promise$then$$default &&
          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: lib$es6$promise$then$$default,

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (Array.isArray(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._result = new Array(this.length);

        if (this.length === 0) {
          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(this.promise, this._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var input   = this._input;

      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      var resolve = c.resolve;

      if (resolve === lib$es6$promise$promise$resolve$$default) {
        var then = lib$es6$promise$$internal$$getThen(entry);

        if (then === lib$es6$promise$then$$default &&
            entry._state !== lib$es6$promise$$internal$$PENDING) {
          this._settledAt(entry._state, i, entry._result);
        } else if (typeof then !== 'function') {
          this._remaining--;
          this._result[i] = entry;
        } else if (c === lib$es6$promise$promise$$default) {
          var promise = new c(lib$es6$promise$$internal$$noop);
          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
          this._willSettleAt(promise, i);
        } else {
          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
        }
      } else {
        this._willSettleAt(resolve(entry), i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        this._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          this._result[i] = value;
        }
      }

      if (this._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, this._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(199), __webpack_require__(48)))

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(334),
    hashDelete = __webpack_require__(335),
    hashGet = __webpack_require__(336),
    hashHas = __webpack_require__(337),
    hashSet = __webpack_require__(338);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(26),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 269 */
/***/ (function(module, exports) {

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;


/***/ }),
/* 270 */
/***/ (function(module, exports) {

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;


/***/ }),
/* 271 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 272 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(167);

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;


/***/ }),
/* 274 */
/***/ (function(module, exports) {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 275 */
/***/ (function(module, exports) {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(38),
    keys = __webpack_require__(11);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

module.exports = baseCreate;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(160),
    isArray = __webpack_require__(3);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 279 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

module.exports = baseGetTag;


/***/ }),
/* 280 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),
/* 281 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(165);

/**
 * The base implementation of `_.invert` and `_.invertBy` which inverts
 * `object` with values transformed by `iteratee` and set by `setter`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform values.
 * @param {Object} accumulator The initial inverted object.
 * @returns {Function} Returns `accumulator`.
 */
function baseInverter(object, setter, iteratee, accumulator) {
  baseForOwn(object, function(value, key, object) {
    setter(accumulator, iteratee(value), key, object);
  });
  return accumulator;
}

module.exports = baseInverter;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(57),
    equalArrays = __webpack_require__(172),
    equalByTag = __webpack_require__(327),
    equalObjects = __webpack_require__(328),
    getTag = __webpack_require__(39),
    isArray = __webpack_require__(3),
    isHostObject = __webpack_require__(67),
    isTypedArray = __webpack_require__(107);

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(57),
    baseIsEqual = __webpack_require__(98);

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 285 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(105),
    isHostObject = __webpack_require__(67),
    isMasked = __webpack_require__(344),
    isObject = __webpack_require__(1),
    toSource = __webpack_require__(181);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(1);

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObject(value) && objectToString.call(value) == regexpTag;
}

module.exports = baseIsRegExp;


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var isLength = __webpack_require__(106),
    isObjectLike = __webpack_require__(19);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(41),
    nativeKeys = __webpack_require__(179);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(162),
    isArrayLike = __webpack_require__(12);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(284),
    getMatchData = __webpack_require__(331),
    matchesStrictComparable = __webpack_require__(178);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(98),
    get = __webpack_require__(184),
    hasIn = __webpack_require__(392),
    isKey = __webpack_require__(40),
    isStrictComparable = __webpack_require__(177),
    matchesStrictComparable = __webpack_require__(178),
    toKey = __webpack_require__(44);

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(57),
    arrayEach = __webpack_require__(93),
    assignMergeValue = __webpack_require__(161),
    baseKeysIn = __webpack_require__(166),
    baseMergeDeep = __webpack_require__(294),
    isArray = __webpack_require__(3),
    isObject = __webpack_require__(1),
    isTypedArray = __webpack_require__(107);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = baseKeysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

module.exports = baseMerge;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(161),
    baseClone = __webpack_require__(95),
    copyArray = __webpack_require__(102),
    isArguments = __webpack_require__(46),
    isArray = __webpack_require__(3),
    isArrayLikeObject = __webpack_require__(27),
    isFunction = __webpack_require__(105),
    isObject = __webpack_require__(1),
    isPlainObject = __webpack_require__(186),
    isTypedArray = __webpack_require__(107),
    toPlainObject = __webpack_require__(415);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(58),
    baseIteratee = __webpack_require__(18),
    baseMap = __webpack_require__(290),
    baseSortBy = __webpack_require__(298),
    baseUnary = __webpack_require__(63),
    compareMultiple = __webpack_require__(315),
    identity = __webpack_require__(72);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(96);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 297 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;


/***/ }),
/* 298 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),
/* 299 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

module.exports = baseSum;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(58);

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

module.exports = baseToPairs;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(92),
    arrayIncludes = __webpack_require__(157),
    arrayIncludesWith = __webpack_require__(158),
    cacheHas = __webpack_require__(171),
    createSet = __webpack_require__(324),
    setToArray = __webpack_require__(42);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(96),
    baseSet = __webpack_require__(168);

/**
 * The base implementation of `_.update`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to update.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseUpdate(object, path, updater, customizer) {
  return baseSet(object, path, updater(baseGet(object, path)), customizer);
}

module.exports = baseUpdate;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(58);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(72);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(97);

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsEndIndex;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(97);

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsStartIndex;


/***/ }),
/* 307 */
/***/ (function(module, exports) {

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(101);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var addMapEntry = __webpack_require__(269),
    arrayReduce = __webpack_require__(94),
    mapToArray = __webpack_require__(70);

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;


/***/ }),
/* 310 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var addSetEntry = __webpack_require__(270),
    arrayReduce = __webpack_require__(94),
    setToArray = __webpack_require__(42);

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(101);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(47);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending = __webpack_require__(314);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(38),
    getSymbols = __webpack_require__(175);

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(12);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 319 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var castSlice = __webpack_require__(64),
    hasUnicode = __webpack_require__(66),
    stringToArray = __webpack_require__(43),
    toString = __webpack_require__(8);

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(94),
    deburr = __webpack_require__(379),
    words = __webpack_require__(425);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var baseInverter = __webpack_require__(282);

/**
 * Creates a function like `_.invertBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} toIteratee The function to resolve iteratees.
 * @returns {Function} Returns the new inverter function.
 */
function createInverter(setter, toIteratee) {
  return function(object, iteratee) {
    return baseInverter(object, setter, toIteratee(iteratee), {});
  };
}

module.exports = createInverter;


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(28),
    toNumber = __webpack_require__(109),
    toString = __webpack_require__(8);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = nativeMin(toInteger(precision), 292);
    if (precision) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

module.exports = createRound;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(155),
    noop = __webpack_require__(188),
    setToArray = __webpack_require__(42);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var baseToPairs = __webpack_require__(300),
    getTag = __webpack_require__(39),
    mapToArray = __webpack_require__(70),
    setToPairs = __webpack_require__(359);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag(object);
    if (tag == mapTag) {
      return mapToArray(object);
    }
    if (tag == setTag) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

module.exports = createToPairs;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(99);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    Uint8Array = __webpack_require__(156),
    eq = __webpack_require__(45),
    equalArrays = __webpack_require__(172),
    mapToArray = __webpack_require__(70),
    setToArray = __webpack_require__(42);

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var keys = __webpack_require__(11);

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(99);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(278),
    getSymbols = __webpack_require__(175),
    keys = __webpack_require__(11);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(177),
    keys = __webpack_require__(11);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 332 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 333 */
/***/ (function(module, exports) {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(71);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

module.exports = hashClear;


/***/ }),
/* 335 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

module.exports = hashDelete;


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(71);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(71);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(71);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 339 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(101),
    cloneDataView = __webpack_require__(308),
    cloneMap = __webpack_require__(309),
    cloneRegExp = __webpack_require__(310),
    cloneSet = __webpack_require__(311),
    cloneSymbol = __webpack_require__(312),
    cloneTypedArray = __webpack_require__(313);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(277),
    getPrototype = __webpack_require__(174),
    isPrototype = __webpack_require__(41);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    isArguments = __webpack_require__(46),
    isArray = __webpack_require__(3);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 343 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(317);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 345 */
/***/ (function(module, exports) {

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;


/***/ }),
/* 346 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

module.exports = listCacheClear;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(60);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(60);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(60);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(60);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(266),
    ListCache = __webpack_require__(56),
    Map = __webpack_require__(90);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(65);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

module.exports = mapCacheDelete;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(65);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(65);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(65);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 356 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 357 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 358 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 359 */
/***/ (function(module, exports) {

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

module.exports = setToPairs;


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(56);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

module.exports = stackClear;


/***/ }),
/* 361 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

module.exports = stackDelete;


/***/ }),
/* 362 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 363 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(56),
    Map = __webpack_require__(90),
    MapCache = __webpack_require__(91);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

module.exports = stackSet;


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var asciiSize = __webpack_require__(273),
    hasUnicode = __webpack_require__(66),
    unicodeSize = __webpack_require__(368);

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(399),
    toString = __webpack_require__(8);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(99);

/** Used to map HTML entities to characters. */
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'",
  '&#96;': '`'
};

/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

module.exports = unescapeHtmlChar;


/***/ }),
/* 368 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    result++;
  }
  return result;
}

module.exports = unicodeSize;


/***/ }),
/* 369 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 370 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(59),
    copyObject = __webpack_require__(38),
    createAssigner = __webpack_require__(103),
    isArrayLike = __webpack_require__(12),
    isPrototype = __webpack_require__(41),
    keys = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(38),
    createAssigner = __webpack_require__(103),
    keysIn = __webpack_require__(108);

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

module.exports = assignIn;


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(28);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var capitalize = __webpack_require__(375),
    createCompounder = __webpack_require__(321);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(8),
    upperFirst = __webpack_require__(422);

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice = __webpack_require__(169),
    isIterateeCall = __webpack_require__(69),
    toInteger = __webpack_require__(28);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

module.exports = chunk;


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(95);

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, false, true);
}

module.exports = clone;


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(95);

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

module.exports = cloneDeep;


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

var deburrLetter = __webpack_require__(326),
    toString = __webpack_require__(8);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0';

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(61),
    baseFlatten = __webpack_require__(37),
    baseRest = __webpack_require__(25),
    isArrayLikeObject = __webpack_require__(27);

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(61),
    baseFlatten = __webpack_require__(37),
    baseIteratee = __webpack_require__(18),
    baseRest = __webpack_require__(25),
    isArrayLikeObject = __webpack_require__(27),
    last = __webpack_require__(187);

/**
 * This method is like `_.difference` except that it accepts `iteratee` which
 * is invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var differenceBy = baseRest(function(array, values) {
  var iteratee = last(values);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee, 2))
    : [];
});

module.exports = differenceBy;


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(61),
    baseFlatten = __webpack_require__(37),
    baseRest = __webpack_require__(25),
    isArrayLikeObject = __webpack_require__(27),
    last = __webpack_require__(187);

/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. Result values
 * are chosen from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith = baseRest(function(array, values) {
  var comparator = last(values);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
    : [];
});

module.exports = differenceWith;


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(388);


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

var escapeHtmlChar = __webpack_require__(329),
    toString = __webpack_require__(8);

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the
 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(372);


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(163),
    baseIteratee = __webpack_require__(18),
    toInteger = __webpack_require__(28);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(37);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(93),
    baseEach = __webpack_require__(162),
    baseIteratee = __webpack_require__(18),
    isArray = __webpack_require__(3);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _([1, 2]).forEach(function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = forEach;


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(164),
    baseIteratee = __webpack_require__(18),
    keysIn = __webpack_require__(108);

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, baseIteratee(iteratee, 3), keysIn);
}

module.exports = forIn;


/***/ }),
/* 390 */
/***/ (function(module, exports) {

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs ? pairs.length : 0,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

module.exports = fromPairs;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(280),
    hasPath = __webpack_require__(176);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(281),
    hasPath = __webpack_require__(176);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(182),
    createInverter = __webpack_require__(322),
    identity = __webpack_require__(72);

/**
 * Creates an object composed of the inverted keys and values of `object`.
 * If `object` contains duplicate values, subsequent values overwrite
 * property assignments of previous values.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Object
 * @param {Object} object The object to invert.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 1 };
 *
 * _.invert(object);
 * // => { '1': 'c', '2': 'b' }
 */
var invert = createInverter(function(result, value, key) {
  result[value] = key;
}, constant(identity));

module.exports = invert;


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var isObjectLike = __webpack_require__(19),
    isPlainObject = __webpack_require__(186);

/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
}

module.exports = isElement;


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(39),
    isArguments = __webpack_require__(46),
    isArray = __webpack_require__(3),
    isArrayLike = __webpack_require__(12),
    isBuffer = __webpack_require__(185),
    isPrototype = __webpack_require__(41),
    nativeKeys = __webpack_require__(179);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' ||
        typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (nonEnumShadows || isPrototype(value)) {
    return !nativeKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(98);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsRegExp = __webpack_require__(287),
    baseUnary = __webpack_require__(63),
    nodeUtil = __webpack_require__(180);

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(3),
    isObjectLike = __webpack_require__(19);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(91);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(293),
    createAssigner = __webpack_require__(103);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var before = __webpack_require__(373);

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(167),
    basePropertyDeep = __webpack_require__(296),
    isKey = __webpack_require__(40),
    toKey = __webpack_require__(44);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(297),
    isIterateeCall = __webpack_require__(69),
    toFinite = __webpack_require__(189);

/** Built-in method references without a dependency on `root`. */
var freeParseFloat = parseFloat;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min,
    nativeRandom = Math.random;

/**
 * Produces a random number between the inclusive `lower` and `upper` bounds.
 * If only one argument is provided a number between `0` and the given number
 * is returned. If `floating` is `true`, or either `lower` or `upper` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @example
 *
 * _.random(0, 5);
 * // => an integer between 0 and 5
 *
 * _.random(5);
 * // => also an integer between 0 and 5
 *
 * _.random(5, true);
 * // => a floating-point number between 0 and 5
 *
 * _.random(1.2, 5.2);
 * // => a floating-point number between 1.2 and 5.2
 */
function random(lower, upper, floating) {
  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
    upper = floating = undefined;
  }
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper;
      upper = undefined;
    }
    else if (typeof lower == 'boolean') {
      floating = lower;
      lower = undefined;
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0;
    upper = 1;
  }
  else {
    lower = toFinite(lower);
    if (upper === undefined) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  }
  return baseRandom(lower, upper);
}

module.exports = random;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

var createRound = __webpack_require__(323);

/**
 * Computes `number` rounded to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * _.round(4.006);
 * // => 4
 *
 * _.round(4.006, 2);
 * // => 4.01
 *
 * _.round(4060, -2);
 * // => 4100
 */
var round = createRound('round');

module.exports = round;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var baseSet = __webpack_require__(168);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(37),
    baseOrderBy = __webpack_require__(295),
    baseRest = __webpack_require__(25),
    isIterateeCall = __webpack_require__(69);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, function(o) { return o.user; });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 *
 * _.sortBy(users, 'user', function(o) {
 *   return Math.floor(o.age / 10);
 * });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),
/* 408 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 409 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(18),
    baseSum = __webpack_require__(299);

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 *
 * // The `_.property` iteratee shorthand.
 * _.sumBy(objects, 'n');
 * // => 20
 */
function sumBy(array, iteratee) {
  return (array && array.length)
    ? baseSum(array, baseIteratee(iteratee, 2))
    : 0;
}

module.exports = sumBy;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(183),
    isObject = __webpack_require__(1);

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(18),
    baseTimes = __webpack_require__(170),
    toInteger = __webpack_require__(28);

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH,
      length = nativeMin(n, MAX_ARRAY_LENGTH);

  iteratee = baseIteratee(iteratee);
  n -= MAX_ARRAY_LENGTH;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

module.exports = times;


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    copyArray = __webpack_require__(102),
    getTag = __webpack_require__(39),
    isArrayLike = __webpack_require__(12),
    isString = __webpack_require__(398),
    iteratorToArray = __webpack_require__(345),
    mapToArray = __webpack_require__(70),
    setToArray = __webpack_require__(42),
    stringToArray = __webpack_require__(43),
    values = __webpack_require__(423);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var iteratorSymbol = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (iteratorSymbol && value[iteratorSymbol]) {
    return iteratorToArray(value[iteratorSymbol]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

var createToPairs = __webpack_require__(325),
    keys = __webpack_require__(11);

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

module.exports = toPairs;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(38),
    keysIn = __webpack_require__(108);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(62),
    castSlice = __webpack_require__(64),
    charsEndIndex = __webpack_require__(305),
    stringToArray = __webpack_require__(43),
    toString = __webpack_require__(8);

/** Used to match leading and trailing whitespace. */
var reTrimEnd = /\s+$/;

/**
 * Removes trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimEnd('  abc  ');
 * // => '  abc'
 *
 * _.trimEnd('-_-abc-_-', '_-');
 * // => '-_-abc'
 */
function trimEnd(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrimEnd, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

  return castSlice(strSymbols, 0, end).join('');
}

module.exports = trimEnd;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(62),
    castSlice = __webpack_require__(64),
    charsStartIndex = __webpack_require__(306),
    stringToArray = __webpack_require__(43),
    toString = __webpack_require__(8);

/** Used to match leading and trailing whitespace. */
var reTrimStart = /^\s+/;

/**
 * Removes leading whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimStart('  abc  ');
 * // => 'abc  '
 *
 * _.trimStart('-_-abc-_-', '_-');
 * // => 'abc-_-'
 */
function trimStart(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrimStart, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      start = charsStartIndex(strSymbols, stringToArray(chars));

  return castSlice(strSymbols, start).join('');
}

module.exports = trimStart;


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(62),
    castSlice = __webpack_require__(64),
    hasUnicode = __webpack_require__(66),
    isObject = __webpack_require__(1),
    isRegExp = __webpack_require__(397),
    stringSize = __webpack_require__(365),
    stringToArray = __webpack_require__(43),
    toInteger = __webpack_require__(28),
    toString = __webpack_require__(8);

/** Used as default options for `_.truncate`. */
var DEFAULT_TRUNC_LENGTH = 30,
    DEFAULT_TRUNC_OMISSION = '...';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH,
      omission = DEFAULT_TRUNC_OMISSION;

  if (isObject(options)) {
    var separator = 'separator' in options ? options.separator : separator;
    length = 'length' in options ? toInteger(options.length) : length;
    omission = 'omission' in options ? baseToString(options.omission) : omission;
  }
  string = toString(string);

  var strLength = string.length;
  if (hasUnicode(string)) {
    var strSymbols = stringToArray(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize(omission);
  if (end < 1) {
    return omission;
  }
  var result = strSymbols
    ? castSlice(strSymbols, 0, end).join('')
    : string.slice(0, end);

  if (separator === undefined) {
    return result + omission;
  }
  if (strSymbols) {
    end += (result.length - end);
  }
  if (isRegExp(separator)) {
    if (string.slice(end).search(separator)) {
      var match,
          substring = result;

      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
      }
      separator.lastIndex = 0;
      while ((match = separator.exec(substring))) {
        var newEnd = match.index;
      }
      result = result.slice(0, newEnd === undefined ? end : newEnd);
    }
  } else if (string.indexOf(baseToString(separator), end) != end) {
    var index = result.lastIndexOf(separator);
    if (index > -1) {
      result = result.slice(0, index);
    }
  }
  return result + omission;
}

module.exports = truncate;


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(8),
    unescapeHtmlChar = __webpack_require__(367);

/** Used to match HTML entities and HTML characters. */
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);

/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */
function unescape(string) {
  string = toString(string);
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, unescapeHtmlChar)
    : string;
}

module.exports = unescape;


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq = __webpack_require__(301);

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

module.exports = uniq;


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

var baseUpdate = __webpack_require__(302),
    castFunction = __webpack_require__(304);

/**
 * This method is like `_.set` except that accepts `updater` to produce the
 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
 * is invoked with one argument: (value).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
 * console.log(object.a[0].b.c);
 * // => 9
 *
 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
 * console.log(object.x[0].y.z);
 * // => 0
 */
function update(object, path, updater) {
  return object == null ? object : baseUpdate(object, path, castFunction(updater));
}

module.exports = update;


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

var createCaseFirst = __webpack_require__(320);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(303),
    keys = __webpack_require__(11);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

module.exports = values;


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(61),
    baseRest = __webpack_require__(25),
    isArrayLikeObject = __webpack_require__(27);

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var asciiWords = __webpack_require__(275),
    hasUnicodeWord = __webpack_require__(333),
    toString = __webpack_require__(8),
    unicodeWords = __webpack_require__(370);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(110)(module), __webpack_require__(48)))

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(427);
exports.encode = exports.stringify = __webpack_require__(428);


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(426);
var util = __webpack_require__(431);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(429);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 432 */
/***/ (function(module, exports) {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DateTime = __webpack_require__(232);
exports.DateTime = DateTime;
var StringHelper = __webpack_require__(23);
exports.StringHelper = StringHelper;
var StringUtilities = __webpack_require__(150);
exports.StringUtilities = StringUtilities;
var HashtagUtilities = __webpack_require__(238);
exports.HashtagUtilities = HashtagUtilities;
var IconSelector = __webpack_require__(236);
exports.IconSelector = IconSelector;
var SharingTypeHelper = __webpack_require__(131);
exports.SharingTypeHelper = SharingTypeHelper;
var SingleEventBase = __webpack_require__(7);
exports.SingleEventBase = SingleEventBase;
var Signal = __webpack_require__(81);
exports.Signal = Signal;
var ObjectUtil = __webpack_require__(17);
exports.ObjectUtil = ObjectUtil;
var AddressParser = __webpack_require__(253);
exports.AddressParser = AddressParser;
var SPAlternativeUrls = __webpack_require__(225);
exports.SPAlternativeUrls = SPAlternativeUrls;
var Api_event_1 = __webpack_require__(134);
exports.Api = Api_event_1.Api;
var PLT_event_1 = __webpack_require__(88);
exports.PLT = PLT_event_1.PLT;
var ABExperiment_1 = __webpack_require__(240);
exports.ABExperiment = ABExperiment_1.ABExperiment;
var Killswitch_1 = __webpack_require__(237);
exports.Killswitch = Killswitch_1.Killswitch;
var Modules_1 = __webpack_require__(252);
exports.loadModule = Modules_1.loadModule;
var Async_1 = __webpack_require__(15);
exports.Async = Async_1.default;
var Component_1 = __webpack_require__(228);
exports.Component = Component_1.default;
var BaseDataStore_1 = __webpack_require__(55);
exports.DataStore = BaseDataStore_1.default;
var DataStoreCachingType_1 = __webpack_require__(35);
exports.DataStoreCachingType = DataStoreCachingType_1.default;
var EventGroup_1 = __webpack_require__(127);
exports.EventGroup = EventGroup_1.default;
var FabricTheming_1 = __webpack_require__(151);
exports.FabricTheming = FabricTheming_1.default;
var Features_1 = __webpack_require__(52);
exports.Features = Features_1.default;
var GroupDataSource_1 = __webpack_require__(230);
exports.GroupDataSource = GroupDataSource_1.default;
var Guid_1 = __webpack_require__(128);
exports.Guid = Guid_1.default;
var HtmlEncoding_1 = __webpack_require__(234);
exports.HtmlEncoding = HtmlEncoding_1.default;
var Locale_1 = __webpack_require__(132);
exports.Locale = Locale_1.default;
var Manager_1 = __webpack_require__(16);
exports.Manager = Manager_1.default;
var PerformanceCollection_1 = __webpack_require__(146);
exports.PerformanceCollection = PerformanceCollection_1.default;
var PlatformDetection_1 = __webpack_require__(82);
exports.PlatformDetection = PlatformDetection_1.default;
var Promise_1 = __webpack_require__(51);
exports.Promise = Promise_1.default;
var ProtocolHandlerHelper_1 = __webpack_require__(254);
exports.ProtocolHandlerHelper = ProtocolHandlerHelper_1.default;
exports.ProtocolHandlerEncodeOption = ProtocolHandlerHelper_1.ProtocolHandlerEncodeOption;
var RgbaColor_1 = __webpack_require__(24);
exports.RgbaColor = RgbaColor_1.default;
var SiteHeaderLogoAcronym_1 = __webpack_require__(229);
exports.SiteHeaderLogoAcronym = SiteHeaderLogoAcronym_1.default;
var ThemeCache_1 = __webpack_require__(153);
exports.ThemeCache = ThemeCache_1.default;
var ThemeProvider_1 = __webpack_require__(259);
exports.ThemeProvider = ThemeProvider_1.default;
var Uri_1 = __webpack_require__(154);
exports.Uri = Uri_1.default;
var SimpleUri_1 = __webpack_require__(261);
exports.SimpleUri = SimpleUri_1.default;
var UriEncoding_1 = __webpack_require__(84);
exports.UriEncoding = UriEncoding_1.default;
var WebTheme_1 = __webpack_require__(260);
exports.WebTheme = WebTheme_1.default;
var ItemType_1 = __webpack_require__(85);
exports.ItemType = ItemType_1.default;
var DriveSpaceHelper_1 = __webpack_require__(257);
exports.DriveSpaceHelper = DriveSpaceHelper_1.default;
var ShortcutUtilities_1 = __webpack_require__(239);
exports.ShortcutUtilities = ShortcutUtilities_1.default;
var FileTypeIconMap_1 = __webpack_require__(129);
exports.FileTypeIconMap = FileTypeIconMap_1.default;
var SharingType_1 = __webpack_require__(130);
exports.SharingType = SharingType_1.default;
var Sanitize_1 = __webpack_require__(235);
exports.Sanitize = Sanitize_1.default;


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EventBase_1 = __webpack_require__(22);
exports.ClonedEventType = EventBase_1.ClonedEventType;
exports.ValidationErrorType = EventBase_1.ValidationErrorType;
exports.AccountType = EventBase_1.AccountType;
exports.EventBase = EventBase_1.EventBase;
var Engagement_event_1 = __webpack_require__(54);
exports.Engagement = Engagement_event_1.Engagement;
var Nav_event_1 = __webpack_require__(244);
exports.Nav = Nav_event_1.Nav;
var PLTHttpRequest_event_1 = __webpack_require__(135);
exports.PLTHttpRequest = PLTHttpRequest_event_1.PLTHttpRequest;
var Qos_event_1 = __webpack_require__(33);
exports.Qos = Qos_event_1.Qos;
var ResultTypeEnum_1 = __webpack_require__(34);
exports.ResultTypeEnum = ResultTypeEnum_1.ResultTypeEnum;
var APICallPerformanceData_1 = __webpack_require__(248);
exports.APICallPerformanceData = APICallPerformanceData_1.default;
var AriaLoggerCore_1 = __webpack_require__(226);
exports.AriaLoggerCore = AriaLoggerCore_1.default;
var Beacon_1 = __webpack_require__(246);
exports.Beacon = Beacon_1.default;
var BeaconCache_1 = __webpack_require__(141);
exports.BeaconCache = BeaconCache_1.default;
var ControlPerformanceData_1 = __webpack_require__(249);
exports.ControlPerformanceData = ControlPerformanceData_1.default;
var CorrelationVector_1 = __webpack_require__(133);
exports.CorrelationVector = CorrelationVector_1.default;
var ErrorHelper_1 = __webpack_require__(9);
exports.ErrorHelper = ErrorHelper_1.default;
var PageTransitionType_1 = __webpack_require__(143);
exports.PageTransitionType = PageTransitionType_1.default;
var RUMOneLogger_1 = __webpack_require__(89);
exports.RumOneLogger = RUMOneLogger_1.default;
var RUMOneSLAPI_1 = __webpack_require__(144);
exports.RumOneSLAPI = RUMOneSLAPI_1.default;


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var odsp_utilities_bundle_1 = __webpack_require__(20);
var BeaconHandlers = (function () {
    function BeaconHandlers() {
    }
    BeaconHandlers._getResultTypeSuffix = function (resultType) {
        'use strict';
        if (resultType === odsp_utilities_bundle_1.ResultTypeEnum.Success) {
            return '.Success';
        }
        else if (resultType === odsp_utilities_bundle_1.ResultTypeEnum.Failure) {
            return '.Failure';
        }
        else if (resultType === odsp_utilities_bundle_1.ResultTypeEnum.ExpectedFailure) {
            return '.ExpectedFailure';
        }
        return '';
    };
    BeaconHandlers.prototype.ignoredEventsHandler = function (event) {
        return odsp_utilities_bundle_1.Nav.isTypeOf(event) || odsp_utilities_bundle_1.PLTHttpRequest.isTypeOf(event);
    };
    BeaconHandlers.prototype.qosEventNameHandler = function (event, currentName) {
        var name = currentName;
        if (event.data) {
            if (event.eventType === odsp_utilities_bundle_1.ClonedEventType.Start) {
                name += '.Start';
            }
            else if (event.eventType === odsp_utilities_bundle_1.ClonedEventType.End) {
                if (event.data.resultCode) {
                    name += '.' + event.data.resultCode;
                }
                name += BeaconHandlers._getResultTypeSuffix(event.data.resultType);
            }
            else {
                name += '.no_EventType';
            }
        }
        return name;
    };
    BeaconHandlers.prototype.qosEventExtraDataHandler = function (event, qosData) {
        return;
    };
    return BeaconHandlers;
}());
exports.default = BeaconHandlers;


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CircularBuffer = (function () {
    function CircularBuffer(size) {
        this._head = -1;
        this._count = 0;
        this._isIterating = false;
        if (size <= 0) {
            throw new Error('Size must be positive');
        }
        this._size = size;
        this._buffer = new Array(size);
    }
    CircularBuffer.prototype.push = function (item) {
        this._ensureNotIterating();
        this._head++;
        this._count++;
        if (this._head === this._size) {
            this._head = 0;
        }
        this._buffer[this._head] = item;
    };
    CircularBuffer.prototype.forEach = function (handle) {
        if (this._count === 0) {
            return;
        }
        this._isIterating = true;
        try {
            var current = this._tail;
            for (var i = 0; i < this._size; i++) {
                handle(this._buffer[current]);
                if (current === this._head) {
                    break;
                }
                current = this._getNext(current);
            }
        }
        finally {
            this._isIterating = false;
        }
    };
    CircularBuffer.prototype.removeAll = function () {
        this._ensureNotIterating();
        this._head = -1;
        this._count = 0;
    };
    Object.defineProperty(CircularBuffer.prototype, "_tail", {
        get: function () {
            if (this._isNotWrapped()) {
                return 0;
            }
            return this._getNext(this._head);
        },
        enumerable: true,
        configurable: true
    });
    CircularBuffer.prototype._isNotWrapped = function () {
        return this._count === (this._head + 1);
    };
    CircularBuffer.prototype._getNext = function (index) {
        var nextIndex = index + 1;
        if (nextIndex === this._size) {
            nextIndex = 0;
        }
        return nextIndex;
    };
    CircularBuffer.prototype._ensureNotIterating = function () {
        if (this._isIterating) {
            throw new Error('Circular buffer cannot be modified during iteration');
        }
    };
    return CircularBuffer;
}());
exports.default = CircularBuffer;


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultEngagementHandler = (function () {
    function DefaultEngagementHandler() {
    }
    DefaultEngagementHandler.prototype.logData = function (data) {
        console.log("TagName: " + data.name + ", Action Name: " + data.extraData);
    };
    return DefaultEngagementHandler;
}());
exports.default = DefaultEngagementHandler;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogFeature_1 = __webpack_require__(439);
var LogType_1 = __webpack_require__(193);
var LogEntry = (function () {
    function LogEntry(moduleName, logFeature, logType, logProperties) {
        if (logFeature === void 0) { logFeature = LogFeature_1.default.None; }
        if (logType === void 0) { logType = LogType_1.default.Trace; }
        if (moduleName) {
            this.moduleName = moduleName;
            this.logFeature = logFeature;
            this.logType = logType;
            this.logProperties = logProperties;
        }
        else {
            throw new Error('moduleName is invalid');
        }
    }
    LogEntry.prototype.toString = function () {
        var serializedLogProps = undefined;
        if (this.logProperties) {
            try {
                serializedLogProps = JSON.stringify(this.logProperties);
            }
            catch (e) {
                console.log('Error happens in toString():' + e);
            }
        }
        return this.moduleName + " | " + this.logFeature + " | " + this.logType + " | " + serializedLogProps;
    };
    return LogEntry;
}());
exports.default = LogEntry;


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogFeature = (function () {
    function LogFeature() {
    }
    return LogFeature;
}());
LogFeature.None = 'None';
exports.default = LogFeature;


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var odsp_utilities_bundle_1 = __webpack_require__(20);
var sp_core_library_1 = __webpack_require__(0);
var TraceLogger_1 = __webpack_require__(73);
var QosMonitor = (function () {
    function QosMonitor(scenarioName) {
        if (!scenarioName || scenarioName.length === 0) {
            throw new Error('scenario name is invalid');
        }
        this._qos = new odsp_utilities_bundle_1.Qos({ name: scenarioName });
        this._hasEnded = false;
    }
    QosMonitor.prototype.writeSuccess = function ( extraData
 ) {
        if (!this._qos) {
            throw new Error('monitor instance is null or undefined');
        }
        if (this._shouldSkip(odsp_utilities_bundle_1.ResultTypeEnum.Success)) {
            return;
        }
        this._qos.end({
            resultType: odsp_utilities_bundle_1.ResultTypeEnum.Success,
            extraData: extraData
        });
    };
    QosMonitor.prototype.writeUnexpectedFailure = function (tagNameSuffix, ex, 
        extraData
 ) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultUnexpected'; }
        if (!this._qos) {
            throw new Error('monitor instance is null or undefined');
        }
        if (this._shouldSkip(odsp_utilities_bundle_1.ResultTypeEnum.Failure)) {
            return;
        }
        if (ex) {
            this._qos.end({
                resultCode: tagNameSuffix,
                resultType: odsp_utilities_bundle_1.ResultTypeEnum.Failure,
                error: ex.message,
                extraData: extraData
            });
        }
        else {
            this._qos.end({
                resultCode: tagNameSuffix,
                resultType: odsp_utilities_bundle_1.ResultTypeEnum.Failure,
                extraData: extraData
            });
        }
    };
    QosMonitor.prototype.writeExpectedFailure = function (tagNameSuffix, ex, 
        extraData
 ) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultExpected'; }
        if (!this._qos) {
            throw new Error('monitor instance is null or undefined');
        }
        if (this._shouldSkip(odsp_utilities_bundle_1.ResultTypeEnum.ExpectedFailure)) {
            return;
        }
        if (ex) {
            this._qos.end({
                resultCode: tagNameSuffix,
                resultType: odsp_utilities_bundle_1.ResultTypeEnum.ExpectedFailure,
                error: ex.message,
                extraData: extraData
            });
        }
        else {
            this._qos.end({
                resultCode: tagNameSuffix,
                resultType: odsp_utilities_bundle_1.ResultTypeEnum.ExpectedFailure,
                extraData: extraData
            });
        }
    };
    Object.defineProperty(QosMonitor.prototype, "name", {
        get: function () {
            return this._qos.data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "enabled", {
        get: function () {
            return this._qos.enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "shortEventName", {
        get: function () {
            return this._qos.shortEventName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "hasEnded", {
        get: function () {
            return this._hasEnded;
        },
        enumerable: true,
        configurable: true
    });
    QosMonitor.prototype._shouldSkip = function (result) {
        if (this._hasEnded && (this._endResult !== undefined)) {
            var message = sp_core_library_1.Text.format(QosMonitor.qosMonitorHasEndedErrorString, this._qos.data.name, odsp_utilities_bundle_1.ResultTypeEnum[this._endResult], odsp_utilities_bundle_1.ResultTypeEnum[result]);
            if (this._endResult !== result) {
                TraceLogger_1.default.logError(QosMonitor.logSource, new Error(message));
            }
            if (true) {
                TraceLogger_1.default.logVerbose(QosMonitor.logSource, message, 'skipEnd');
            }
            return true;
        }
        else {
            this._hasEnded = true;
            this._endResult = result;
            return false;
        }
    };
    return QosMonitor;
}());
QosMonitor.logSource = {
    id: 'QosMonitor'
};
QosMonitor.qosMonitorHasEndedErrorString = 'QoS monitor \'{0}\' has ended with \'{1}\' already. Ignoring \'{2}\' tag.';
exports.default = QosMonitor;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultTraceHandler = (function () {
    function DefaultTraceHandler() {
    }
    DefaultTraceHandler.prototype.log = function (error, eventName, resultCode) {
        if (true) {
            console.log("Error: " + error + ", Event Name: " + eventName + ", Result Code: " + resultCode);
        }
    };
    DefaultTraceHandler.prototype.verbose = function (error, eventName) {
        if (true) {
            console.log("Error: " + error + ", Event Name: " + eventName);
        }
    };
    return DefaultTraceHandler;
}());
exports.default = DefaultTraceHandler;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var odsp_utilities_bundle_1 = __webpack_require__(20);
var AriaLogger = (function () {
    function AriaLogger() {
    }
    AriaLogger.initialize = function (tenantToken, context) {
        __webpack_require__.e/* require.ensure */(2).then((function (require) {
            var aria = __webpack_require__(201);
            odsp_utilities_bundle_1.AriaLoggerCore.Init(tenantToken, context, aria);
        }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
    };
    return AriaLogger;
}());
exports.default = AriaLogger;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogEvent_1 = __webpack_require__(191);
var LogLevel_1 = __webpack_require__(192);
var SPTelemetryLogHandler = (function () {
    function SPTelemetryLogHandler() {
    }
    SPTelemetryLogHandler.prototype.verbose = function (source, message, scope) {
        var event = LogEvent_1.default.log(source, message, LogLevel_1.LogLevel.Verbose, scope);
        if (true) {
            console.log(event.toString()); 
        }
    };
    SPTelemetryLogHandler.prototype.info = function (source, message, scope) {
        var event = LogEvent_1.default.log(source, message, LogLevel_1.LogLevel.Info, scope);
        if (true) {
            console.info(event.toString()); 
        }
    };
    SPTelemetryLogHandler.prototype.warn = function (source, message, scope) {
        var event = LogEvent_1.default.log(source, message, LogLevel_1.LogLevel.Warning, scope);
        if (true) {
            console.warn(event.toString()); 
        }
    };
    SPTelemetryLogHandler.prototype.error = function (source, error, scope) {
        var event = LogEvent_1.default.log(source, error, LogLevel_1.LogLevel.Error, scope);
        if (true) {
            console.error(event.toString()); 
        }
    };
    return SPTelemetryLogHandler;
}());
exports.default = SPTelemetryLogHandler;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var odsp_utilities_bundle_1 = __webpack_require__(20);
var AriaLogger_1 = __webpack_require__(442);
var EngagementLogger_1 = __webpack_require__(190);
var TraceLogger_1 = __webpack_require__(73);
var BeaconHandlers_1 = __webpack_require__(435);
var Telemetry = (function () {
    function Telemetry() {
    }
    Telemetry.initialize = function (workloadName, settings) {
        if (!Telemetry._isInitialized) {
            var beaconHandler = new BeaconHandlers_1.default();
            odsp_utilities_bundle_1.BeaconCache.addToLoggingManager(workloadName, beaconHandler);
            odsp_utilities_bundle_1.Beacon.addToLoggingManager();
            EngagementLogger_1.default._initialize(odsp_utilities_bundle_1.Engagement);
            TraceLogger_1.default._initialize(odsp_utilities_bundle_1.ErrorHelper);
            Telemetry._initializeAria(workloadName, settings);
            Telemetry._isInitialized = true;
            TraceLogger_1.default.shouldWriteToConsole = settings.enableConsoleLog;
        }
    };
    Telemetry._initializeAria = function (workloadName, settings) {
        if (settings && Telemetry._shouldEnableAria(settings.environment)) {
            var token = Telemetry._getAriaToken(settings.environment);
            if (token) {
                var authenticated = !!settings.loginName;
                AriaLogger_1.default.initialize(token, {
                    isAuthenticated: authenticated,
                    accountType: authenticated ? odsp_utilities_bundle_1.AccountType.Business : odsp_utilities_bundle_1.AccountType.BusinessAnonymous,
                    market: settings.currentUICultureName,
                    session: settings.correlationId,
                    version: settings.version,
                    manifest: settings.clientSideApplicationId,
                    userId: settings.systemUserKey,
                    siteSubscriptionId: settings.siteSubscriptionId,
                    farmLabel: settings.farmLabel,
                    environment: settings.environment,
                    workload: workloadName
                });
            }
        }
    };
    Telemetry._shouldEnableAria = function (env) {
        return !!env && location.hostname !== 'localhost';
    };
    Telemetry._getAriaToken = function (env) {
        var token;
        switch (env.toLowerCase()) {
            case 'edog':
            case 'prodbubble':
                token = '930040d5f2d14c649c8f4a22a062a2af-a8806003-7416-4799-9a3a-31de703592e5-6968';
                break;
            default:
                token = '28f004ff2be44e8997a6f113043d583d-3f663b9a-4911-45b4-be6d-e450ca91e808-7336';
                break;
        }
        return token;
    };
    return Telemetry;
}());
Telemetry._isInitialized = false;
exports.default = Telemetry;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Version_1 = __webpack_require__(194);
var Browser;
(function (Browser) {
    Browser[Browser["Other"] = 0] = "Other";
    Browser[Browser["Chrome"] = 1] = "Chrome";
    Browser[Browser["Edge"] = 2] = "Edge";
    Browser[Browser["Firefox"] = 3] = "Firefox";
    Browser[Browser["IE"] = 4] = "IE";
    Browser[Browser["Safari"] = 5] = "Safari";
})(Browser = exports.Browser || (exports.Browser = {}));
var OS;
(function (OS) {
    OS[OS["Other"] = 0] = "Other";
    OS[OS["Android"] = 1] = "Android";
    OS[OS["IOS"] = 2] = "IOS";
    OS[OS["Linux"] = 3] = "Linux";
    OS[OS["Mac"] = 4] = "Mac";
    OS[OS["Windows"] = 5] = "Windows";
    OS[OS["WindowsPhone"] = 6] = "WindowsPhone";
})(OS = exports.OS || (exports.OS = {}));
var BrowserDetection = (function () {
    function BrowserDetection() {
    }
    BrowserDetection.getBrowserInformation = function (userAgent) {
        var agent = userAgent || BrowserDetection.getUserAgent();
        return BrowserDetection.buildBrowserInformation(agent);
    };
    BrowserDetection.getUserAgent = function () {
        return (window && window.navigator && navigator.userAgent) || '';
    };
    BrowserDetection.buildBrowserInformation = function (userAgent) {
        var agent = userAgent.toLowerCase();
        var browserInfo = {
            browser: Browser.Other,
            browserVersion: undefined,
            os: OS.Other,
            osVersion: undefined,
            userAgent: userAgent
        };
        browserInfo = BrowserDetection.fillBrowser(browserInfo, agent);
        browserInfo = BrowserDetection.fillOS(browserInfo, agent);
        return browserInfo;
    };
    BrowserDetection.fillBrowser = function (browserInfo, userAgent) {
        var browser = Browser.Other;
        var browserVersion = undefined;
        var match;
        if (match = /msie (\d+)([\d.]*)/.exec(userAgent)) {
            browser = Browser.IE;
        }
        else if (match = /trident.*rv:(\d+)([\d.]*)/.exec(userAgent)) {
            browser = Browser.IE;
        }
        else if (match = /edge\/(\d+)([\d.]*)/.exec(userAgent)) {
            browser = Browser.Edge;
        }
        else if (match = /(?:firefox|fxios)\/(\d+)([\d.]*)/.exec(userAgent)) {
            browser = Browser.Firefox;
        }
        else if (match = /(?:chrome|crios)\/(\d+)([\d.]*)/.exec(userAgent)) {
            browser = Browser.Chrome;
        }
        else if (match = /safari\/(\d+)/.exec(userAgent)) {
            browser = Browser.Safari;
            match = /version\/(\d+)([\d.]*)/.exec(userAgent);
        }
        if (match) {
            var browserMajor = parseInt(match[1], 10) || 0;
            var browserMinor = '0';
            var browserMinorVersion = match[2];
            if (browserMinorVersion) {
                var minorStart = browserMinorVersion.indexOf('.');
                if (minorStart >= 0 && minorStart < browserMinorVersion.length - 1) {
                    browserMinor = browserMinorVersion.substr(minorStart + 1);
                }
            }
            browserVersion = Version_1.default.parse(browserMajor + "." + browserMinor);
        }
        browserInfo.browser = browser;
        browserInfo.browserVersion = browserVersion;
        return browserInfo;
    };
    BrowserDetection.fillOS = function (browserInfo, userAgent) {
        var os = OS.Other;
        var osVersion = undefined;
        var osVersionMatch = /[\s\(](os|os x|windows phone|windows nt|android) ([\d._]+)/.exec(userAgent);
        osVersion = osVersionMatch ? osVersionMatch[2] : undefined;
        var deviceMatch = userAgent.match(/windows phone|wpdesktop/) || userAgent.match(/ipad|iphone|ipod|android/);
        if (deviceMatch) {
            var device = deviceMatch[0];
            if (device === 'windows phone' || device === 'wpdesktop') {
                os = OS.WindowsPhone;
            }
            if (device === 'android') {
                os = OS.Android;
            }
            if (device === 'ipad' || device === 'ipod' || device === 'iphone') {
                os = OS.IOS;
            }
        }
        else {
            if (userAgent.indexOf('macintosh') !== -1) {
                os = OS.Mac;
            }
            if (userAgent.indexOf('windows nt') !== -1) {
                os = OS.Windows;
            }
            if (/(windows 8\.1|windows nt 6\.3)/.test(userAgent)) {
                os = OS.Windows;
                osVersion = '8.1';
            }
            if (userAgent.indexOf('windows nt 10') !== -1) {
                os = OS.Windows;
                osVersion = '10';
            }
            if (userAgent.indexOf('windows nt 6.1') !== -1) {
                os = OS.Windows;
                osVersion = '7';
            }
        }
        browserInfo.os = os;
        browserInfo.osVersion = osVersion;
        return browserInfo;
    };
    return BrowserDetection;
}());
exports.default = BrowserDetection;


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DisplayMode;
(function (DisplayMode) {
    DisplayMode[DisplayMode["Read"] = 1] = "Read";
    DisplayMode[DisplayMode["Edit"] = 2] = "Edit";
})(DisplayMode || (DisplayMode = {}));
exports.default = DisplayMode;


/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Validate_1 = __webpack_require__(14);
var StringsProxy_1 = __webpack_require__(13);
var EnvironmentType;
(function (EnvironmentType) {
    EnvironmentType[EnvironmentType["Test"] = 0] = "Test";
    EnvironmentType[EnvironmentType["Local"] = 1] = "Local";
    EnvironmentType[EnvironmentType["SharePoint"] = 2] = "SharePoint";
    EnvironmentType[EnvironmentType["ClassicSharePoint"] = 3] = "ClassicSharePoint";
})(EnvironmentType = exports.EnvironmentType || (exports.EnvironmentType = {}));
var Environment = (function () {
    function Environment() {
    }
    Environment._initialize = function (data) {
        Validate_1.default.isNotNullOrUndefined(data, 'data');
        Environment._type = data.type;
        Validate_1.default.isNotNullOrUndefined(Environment._type, 'environmentType');
        if (!EnvironmentType.hasOwnProperty(data.type.toString())) {
            throw new Error(StringsProxy_1.default.invalidEnvironmentTypeError);
        }
    };
    Object.defineProperty(Environment, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    return Environment;
}());
exports.default = Environment;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BrowserSupportLevel;
(function (BrowserSupportLevel) {
    BrowserSupportLevel[BrowserSupportLevel["None"] = 0] = "None";
    BrowserSupportLevel[BrowserSupportLevel["FullFunctionality"] = 1] = "FullFunctionality";
    BrowserSupportLevel[BrowserSupportLevel["Readable"] = 2] = "Readable";
    BrowserSupportLevel[BrowserSupportLevel["Blocked"] = 3] = "Blocked";
})(BrowserSupportLevel = exports.BrowserSupportLevel || (exports.BrowserSupportLevel = {}));


/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var JsonUtilities = (function () {
    function JsonUtilities() {
    }
    JsonUtilities.encode = function (json) {
        if (!json) {
            return undefined;
        }
        JsonUtilities._escapableChars.lastIndex = 0;
        return JsonUtilities._escapableChars.test(json) ? json.replace(this._escapableChars, function (a) {
            var c = JsonUtilities._substibuteChars[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) : json;
    };
    return JsonUtilities;
}());
JsonUtilities._escapableChars = /[\\\"\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
JsonUtilities._substibuteChars = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"': '\\"',
    '\'': '\\\'',
    '\\': '\\\\'
};
exports.default = JsonUtilities;


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Validate_1 = __webpack_require__(14);
var StringsProxy_1 = __webpack_require__(13);
var SPError = (function (_super) {
    __extends(SPError, _super);
    function SPError(errorCode, message, logProperties) {
        var _this = _super.call(this, message) || this;
        _this.__proto__ = SPError.prototype; 
        Validate_1.default.isNonemptyString(errorCode, 'errorCode');
        Validate_1.default.isNonemptyString(message, 'message');
        _this._errorCode = errorCode;
        _this.message = message;
        _this._logProperties = logProperties;
        _this.stack = (new Error()).stack || SPError._generateErrorStackForIE();
        return _this;
    }
    Object.defineProperty(SPError.prototype, "id", {
        get: function () {
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPError.prototype, "category", {
        get: function () {
            return 'SPError';
        },
        enumerable: true,
        configurable: true
    });
    SPError._generateErrorStackForIE = function () {
        try {
            throw new Error();
        }
        catch (e) {
            return e.stack;
        }
    };
    SPError.prototype.toStringForUI = function () {
        return this._toString(true);
    };
    SPError.prototype.toString = function () {
        return this._toString();
    };
    SPError.prototype._toString = function (logDebug) {
        if (!this._errorString) {
            var errorMessageArray = [
                "[" + this.category + "." + this._errorCode + "]:",
                "" + this.message,
                ''
            ];
            if (logDebug || true) {
                if (this.innerError) {
                    errorMessageArray = errorMessageArray.concat([
                        StringsProxy_1.default.spErrorInnerErrorText,
                        this.innerError.message
                    ]);
                }
                if (this.stack) {
                    errorMessageArray = errorMessageArray.concat([
                        StringsProxy_1.default.spErrorCallStackText,
                        this.stack
                    ]);
                }
                if (this._logProperties) {
                    errorMessageArray = errorMessageArray.concat([
                        StringsProxy_1.default.spErrorLogPropertiesText,
                        JSON.stringify(this._logProperties)
                    ]);
                }
            }
            this._errorString = errorMessageArray.join('\r\n');
        }
        return this._errorString;
    };
    return SPError;
}(Error));
exports.default = SPError;


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UrlQueryParameterCollection_1 = __webpack_require__(114);
var SPFlight = (function () {
    function SPFlight() {
    }
    SPFlight.initialize = function (flights, allowQueryFlights) {
        this._isInitialized = true;
        this._enabledFlightsMap = flights || [];
        if (allowQueryFlights) {
            try {
                var queryParams = new UrlQueryParameterCollection_1.default(window.location.href);
                var debugFlights = queryParams.getValue('debugFlights');
                if (debugFlights) {
                    this._debugFlights = debugFlights.split(',').map(function (value) { return parseInt(value, 10); });
                }
            }
            catch (error) {
                this._debugFlights = [];
                console.log("Error parsing debugFlights query string parameter: " + error);
            }
        }
    };
    SPFlight.isEnabled = function (flight) {
        if (!this._isInitialized && !false) {
            throw new Error("Flights are not initialized. Flight requested: " + flight);
        }
        if (!flight || flight < 0) {
            return false;
        }
        if (this._debugFlights.indexOf(flight) !== -1) {
            return true;
        }
        var enabledFlightsIndex = flight >> 5;
        if (enabledFlightsIndex < 0 || enabledFlightsIndex >= this._enabledFlightsMap.length) {
            return false;
        }
        var bitMask = 1 << (flight & 31);
        return (this._enabledFlightsMap[enabledFlightsIndex] & bitMask) !== 0;
    };
    return SPFlight;
}());
SPFlight._isInitialized = false;
SPFlight._debugFlights = [];
SPFlight._enabledFlightsMap = [];
exports.default = SPFlight;


/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Guid_1 = __webpack_require__(112);
var UrlQueryParameterCollection_1 = __webpack_require__(114);
var SPKillSwitch = (function () {
    function SPKillSwitch() {
    }
    SPKillSwitch.initialize = function (killSwitchGuids, allowQueryKillSwitch) {
        this._isInitialized = true;
        this._activatedKillSwitches = new Map();
        if (killSwitchGuids) {
            for (var _i = 0, _a = Object.keys(killSwitchGuids); _i < _a.length; _i++) {
                var killSwitchGuid = _a[_i];
                var normalizedKillSwitchGuid = Guid_1.default.tryParse(killSwitchGuid);
                if (normalizedKillSwitchGuid) {
                    this._activatedKillSwitches.set(normalizedKillSwitchGuid.toString(), true);
                }
            }
        }
        if (allowQueryKillSwitch) {
            try {
                var queryParams = new UrlQueryParameterCollection_1.default(window.location.href);
                var killSwitches = queryParams.getValue('debugKillSwitches');
                if (killSwitches && killSwitches.length) {
                    for (var killSwitch in killSwitches.split(',').map(function (value) { return Guid_1.default.tryParse(value); })) {
                        if (killSwitch) {
                            this._activatedKillSwitches.set(killSwitch.toString(), true);
                        }
                    }
                }
            }
            catch (error) {
                console.log("Error parsing killSwitches query string parameter: " + error);
            }
        }
    };
    SPKillSwitch.isActivated = function (killSwitchGuid, date, featureName) {
        if (!this._isInitialized && !false) {
            throw new Error("Killswitches are not initialized. Killswitch requested: " + killSwitchGuid);
        }
        if (!killSwitchGuid) {
            return false;
        }
        return this._activatedKillSwitches.get(killSwitchGuid.toString());
    };
    return SPKillSwitch;
}());
SPKillSwitch._isInitialized = false;
SPKillSwitch._activatedKillSwitches = new Map();
exports.default = SPKillSwitch;


/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Guid_1 = __webpack_require__(112);
var Validate_1 = __webpack_require__(14);
var Log_1 = __webpack_require__(195);
var Session = (function () {
    function Session() {
    }
    Session._initialize = function (data) {
        Validate_1.default.isNotNullOrUndefined(data, 'data');
        Session._applicationId = Guid_1.default.tryParse(data.applicationId) || Guid_1.default.empty;
        var pageIdGuid = Guid_1.default.tryParse(data.pageId);
        if (!pageIdGuid) {
            Log_1.default.warn('Session', 'The pageId parameter was undefined or invalid. Generating a new Guid', undefined);
            pageIdGuid = Guid_1.default.newGuid();
        }
        Session._pageId = pageIdGuid;
    };
    Session._changePage = function () {
        Session._pageId = Guid_1.default.newGuid();
    };
    Object.defineProperty(Session, "applicationId", {
        get: function () {
            return this._applicationId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session, "pageId", {
        get: function () {
            return this._pageId;
        },
        enumerable: true,
        configurable: true
    });
    return Session;
}());
exports.default = Session;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Text_1 = __webpack_require__(29);
var StringsProxy_1 = __webpack_require__(13);
var DefaultLogHandler = (function () {
    function DefaultLogHandler() {
    }
    DefaultLogHandler.prototype.verbose = function (source, message, scope) {
        if (true) {
            console.log(Text_1.default.format(StringsProxy_1.default.logVerboseLevelMessage, source));
        }
    };
    DefaultLogHandler.prototype.info = function (source, message, scope) {
        if (true) {
            console.info(Text_1.default.format(StringsProxy_1.default.logInfoLevelMessage, source));
        }
    };
    DefaultLogHandler.prototype.warn = function (source, message, scope) {
        if (true) {
            console.warn(Text_1.default.format(StringsProxy_1.default.logWarningLevelMessage, source));
        }
    };
    DefaultLogHandler.prototype.error = function (source, error, scope) {
        if (true) {
            console.error(Text_1.default.format(StringsProxy_1.default.logErrorLevelMessage, source, error.message));
        }
    };
    return DefaultLogHandler;
}());
exports.default = DefaultLogHandler;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var StringsProxy_1 = __webpack_require__(13);
var Text_1 = __webpack_require__(29);
var ServiceScope = (function () {
    function ServiceScope(parent) {
        this._parent = parent;
        this._registrations = {};
        this._pendingCallbacks = [];
        this._finished = false;
        this._autocreating = false;
    }
    ServiceScope.startNewRoot = function () {
        return new ServiceScope(undefined);
    };
    ServiceScope.prototype.createAndProvide = function (serviceKey, simpleServiceClass) {
        return this.provide(serviceKey, new simpleServiceClass(this));
    };
    ServiceScope.prototype.createDefaultAndProvide = function (serviceKey) {
        var service = serviceKey.defaultCreator(this);
        return this.provide(serviceKey, service);
    };
    ServiceScope.prototype.consume = function (serviceKey) {
        if (!this._finished) {
            throw new Error(StringsProxy_1.default.serviceScopeConsumingBeforeFinished);
        }
        if (this._autocreating) {
            throw new Error(StringsProxy_1.default.serviceScopeConsumingDuringAutoCreation);
        }
        var registration = this._registrations[serviceKey.id];
        if (registration) {
            return registration.service;
        }
        if (this._parent) {
            return this._parent.consume(serviceKey);
        }
        var autocreatedService = undefined;
        this._autocreating = true;
        try {
            autocreatedService = serviceKey.defaultCreator(this);
            this._registrations[serviceKey.id] = { serviceKey: serviceKey, service: autocreatedService };
        }
        finally {
            this._autocreating = false;
        }
        if (autocreatedService === undefined) {
            throw Error('ServiceKey must have an type');
        }
        this._processPendingCallbacks();
        return autocreatedService;
    };
    ServiceScope.prototype.finish = function () {
        if (this._finished) {
            throw new Error(StringsProxy_1.default.serviceScopeAlreadyFinishedError);
        }
        this._finished = true;
        this._processPendingCallbacks();
    };
    ServiceScope.prototype.getParent = function () {
        return this._parent;
    };
    ServiceScope.prototype.whenFinished = function (callback) {
        if (this._finished && !this._autocreating) {
            callback();
        }
        else {
            this._pendingCallbacks.push(callback);
        }
    };
    ServiceScope.prototype.provide = function (serviceKey, service) {
        if (this._finished) {
            throw new Error(StringsProxy_1.default.serviceScopeProvideServiceAfterFinishedError);
        }
        if (this._registrations[serviceKey.id]) {
            throw new Error(Text_1.default.format(StringsProxy_1.default.serviceScopeProvideServiceThatAlreadyExists, serviceKey.name));
        }
        this._registrations[serviceKey.id] = { serviceKey: serviceKey, service: service };
        return service;
    };
    ServiceScope.prototype.startNewChild = function () {
        return new ServiceScope(this);
    };
    ServiceScope.prototype._processPendingCallbacks = function () {
        var pendingCallbacks = this._pendingCallbacks;
        this._pendingCallbacks = [];
        for (var _i = 0, pendingCallbacks_1 = pendingCallbacks; _i < pendingCallbacks_1.length; _i++) {
            var pendingCallback = pendingCallbacks_1[_i];
            pendingCallback();
        }
    };
    return ServiceScope;
}());
exports.default = ServiceScope;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ServiceKey_1 = __webpack_require__(113);
var RandomNumberGenerator = (function () {
    function RandomNumberGenerator(serviceScope) {
    }
    RandomNumberGenerator.prototype.generate = function () {
        return Math.random();
    };
    return RandomNumberGenerator;
}());
RandomNumberGenerator.serviceKey = ServiceKey_1.default.create('sp-core-library:RandomNumberGenerator', RandomNumberGenerator);
exports.default = RandomNumberGenerator;


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ServiceKey_1 = __webpack_require__(113);
var TimeProvider = (function () {
    function TimeProvider(serviceScope) {
    }
    TimeProvider.prototype.getDate = function () {
        return new Date();
    };
    TimeProvider.prototype.getTimestamp = function () {
        return performance.now();
    };
    return TimeProvider;
}());
TimeProvider.serviceKey = ServiceKey_1.default.create('sp-core-library:TimeProvider', TimeProvider);
exports.default = TimeProvider;


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var lodash = __webpack_require__(49);
var Validate_1 = __webpack_require__(14);
var UrlUtilities = (function () {
    function UrlUtilities() {
    }
    UrlUtilities.removeEndSlash = function (url) {
        return lodash.trimEnd(url, '/');
    };
    UrlUtilities.convertToODataStringLiteral = function (value) {
        Validate_1.default.isNotNullOrUndefined(value, 'value');
        value = value.replace(/'/g, "''");
        value = "'" + value + "'";
        return value;
    };
    return UrlUtilities;
}());
exports.default = UrlUtilities;


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var URLSearchParams_1 = __webpack_require__(196);
// 'window' isn't defined in mocha test
var currentWindowUrl = (typeof window !== 'undefined') ? window.URL : undefined;
/**
 * This class contains functionality that is common between the smaller "URL" class and the experimental
 *  complete "URL" class.
 */
var BaseURL = (function () {
    function BaseURL(url, base) {
    }
    BaseURL.createObjectURL = function (object, options) {
        if (currentWindowUrl && currentWindowUrl.createObjectURL) {
            // Passthrough to the existing currentWindowUrl if the browser supports it
            return currentWindowUrl.createObjectURL(object, options);
        }
        else {
            throw new Error('createObjectURL not supported');
        }
    };
    BaseURL.revokeObjectURL = function (objectUrl) {
        if (currentWindowUrl && currentWindowUrl.revokeObjectURL) {
            // Passthrough to the existing revokeObjectURL if the browser supports it
            currentWindowUrl.revokeObjectURL(objectUrl);
        }
        else {
            throw new Error('revokeObjectURL not supported');
        }
    };
    Object.defineProperty(BaseURL.prototype, "search", {
        get: function () {
            return this._query || '';
        },
        set: function (newValue) {
            this._invalidate();
            // Trim the leading "?" and serialize "null" or "undefined" as a weird caveat of the spec
            var queryMatches = ("" + newValue).match(/^\??(.*)/);
            if (queryMatches && !!queryMatches[1]) {
                this._query = queryMatches[1];
            }
            else {
                this._query = null; // tslint:disable-line:no-null-keyword
            }
            var existingSearchParams = this._searchParams.toString();
            if (existingSearchParams !== this.search && "?" + existingSearchParams !== this.search) {
                // Update searchParams
                this._searchParams._initialize(this.search); // tslint:disable-line:no-any
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseURL.prototype, "searchParams", {
        get: function () {
            return this._searchParams;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseURL.prototype, "searchparams", {
        // Need to include this because the TypeScript lib.d.ts typings have the incorrect case
        // Remove when the TS typings are fixed. VSO#339963
        get: function () {
            throw new Error('This function does not exist.');
        },
        enumerable: true,
        configurable: true
    });
    BaseURL.prototype.toJson = function () {
        // Same behavior as "href"
        return this.href;
    };
    BaseURL.prototype._initializeSearchParams = function () {
        this._searchParams = new URLSearchParams_1.default(this.search);
        // Ensure searchParams has a pointer to this object.
        this._searchParams._url = this; // tslint:disable-line:no-any
    };
    return BaseURL;
}());
exports.default = BaseURL;



/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * This is an incomplete implementation of a URL polyfill. These things are not supported, or not fully supported:
 *  - baseURLString constructor property
 *      This means that `new URL('http://contoso.com/path/to/something', 'http://fabrikam.com')` will not work,
 *        but the same thing can be accomplished with:
 *      const url = new new URL('http://contoso.com/path/to/something');
 *      url.host = 'fabrikam.com';
 *
 *  - Username
 *      The username property is not supported and will always return the empty string. Setting the username has
 *        no effect.
 *
 *  - Password
 *      The password property is not supported and will always return the empty string. Setting the password has
 *        no effect.
 *
 *  - Setting the pathname property with a value containing encoded values will double-encode the encoded values.
 *      For example. myUrl.pathname = "path%2Bto/resource.json" => myUrl.pathname === "/path%252Bto/resource.json"
 *      To set the pathname to a value that contains a special character, set it with the un-encoded character.
 *      The encoded "/" character (%2F) is not supported
 *
 * MDN documentation: https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * WhatWG Spec: https://url.spec.whatwg.org/
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseURL_1 = __webpack_require__(459);
var SPECIAL_SCHEMES_AND_PORTS = {
    'ftp:': '21',
    'gopher:': '70',
    'http:': '80',
    'https:': '443',
    'ws:': '80',
    'wss:': '443'
};
/**
 * Ensures the URL has a scheme
 */
function urlIsValid(url) {
    return !!url.match(/^.+\:/);
}
var URL = (function (_super) {
    __extends(URL, _super);
    function URL(url, baseURLString) {
        var _this = this;
        if (!urlIsValid(url)) {
            throw new TypeError('Invalid URL');
        }
        _this = _super.call(this, url, baseURLString) || this;
        _this._shadowDocument = document.implementation.createHTMLDocument('');
        _this._innerAnchorElement = _this._shadowDocument.createElement('a');
        if (baseURLString) {
            throw new Error('baseURLString parameter is not supported by the URL polyfill.');
        }
        _this._innerAnchorElement.href = url;
        _this._initializeSearchParams();
        return _this;
    }
    Object.defineProperty(URL.prototype, "href", {
        get: function () {
            var result = this._innerAnchorElement.href;
            if (this._hashHashBeenCleared) {
                if (result.match(/\#$/)) {
                    result = result.substr(0, result.length - 1);
                }
                if (this._searchHasBeenCleared && result.match(/\?$/)) {
                    result = result.substr(0, result.length - 1);
                }
            }
            else if (this._searchHasBeenCleared) {
                var firstIndexOfHash = result.indexOf('#');
                if (firstIndexOfHash === -1) {
                    // No fragment
                    if (result.match(/\?$/)) {
                        result = result.substr(0, result.length - 1);
                    }
                }
                else if (result.charAt(firstIndexOfHash - 1) === '?') {
                    result = result.substring(0, firstIndexOfHash - 1) + result.substr(firstIndexOfHash);
                }
            }
            return result;
        },
        set: function (newValue) {
            if (!urlIsValid(newValue)) {
                throw new TypeError('Invalid URL');
            }
            this._invalidate();
            this._innerAnchorElement.href = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "origin", {
        get: function () {
            if (SPECIAL_SCHEMES_AND_PORTS.hasOwnProperty(this.protocol)) {
                if (!this.port || SPECIAL_SCHEMES_AND_PORTS[this.protocol] === this.port) {
                    // Standard port, don't serialize the port
                    return this.protocol + "//" + this._innerAnchorElement.hostname;
                }
                else {
                    // Non-standard port, serialize the port
                    return this.protocol + "//" + this._innerAnchorElement.hostname + ":" + this.port;
                }
            }
            else {
                return 'null';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "protocol", {
        get: function () {
            return this._innerAnchorElement.protocol;
        },
        set: function (newValue) {
            // Trim the trailing ":" and serialize "null" or "undefined" as a weird caveat of the spec
            var protocolMatches = ("" + newValue).match(/^([^\:]+):?$/);
            if (protocolMatches) {
                this._invalidate();
                this._innerAnchorElement.protocol = protocolMatches[1] + ":";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "username", {
        get: function () {
            return ''; // Not supported
        },
        set: function (newValue) {
            // Not supported
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "password", {
        get: function () {
            return ''; // Not supported
        },
        set: function (newValue) {
            // Not supported
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "host", {
        get: function () {
            return this._innerAnchorElement.host;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.host = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "hostname", {
        get: function () {
            return this._innerAnchorElement.hostname;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.hostname = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "port", {
        get: function () {
            return this._innerAnchorElement.port;
        },
        set: function (newValue) {
            this._invalidate();
            if (newValue) {
                this._innerAnchorElement.port = newValue;
            }
            else {
                this._innerAnchorElement.port = SPECIAL_SCHEMES_AND_PORTS[this.protocol] || newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "pathname", {
        get: function () {
            return this._innerAnchorElement.pathname;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.pathname = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "hash", {
        get: function () {
            return this._innerAnchorElement.hash;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.hash = '';
            // Trim the leading "#" and serialize "null" or "undefined" as a weird caveat of the spec
            var fragmentMatches = ("" + newValue).match(/^#?(.*)/);
            if (fragmentMatches && !!fragmentMatches[1]) {
                this._innerAnchorElement.hash = fragmentMatches[1];
                this._hashHashBeenCleared = false;
            }
            else {
                this._hashHashBeenCleared = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "_query", {
        get: function () {
            return this._innerAnchorElement.search;
        },
        set: function (newValue) {
            this._innerAnchorElement.search = '';
            if (!!newValue) {
                this._innerAnchorElement.search = newValue;
                this._searchHasBeenCleared = false;
            }
            else {
                this._searchHasBeenCleared = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    URL.prototype._invalidate = function () { };
    return URL;
}(BaseURL_1.default));
exports.default = URL;



/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function urlIsPresent() {
    if (typeof window.URL === 'undefined') {
        return false;
    }
    try {
        var url = new window.URL('http://contoso.com?a=b');
        return url.searchParams.get('a') === 'b';
    }
    catch (e) {
        return false;
    }
}
function urlSearchParamsIsPresent() {
    if (typeof window['URLSearchParams'] === 'undefined') {
        return false;
    }
    try {
        new URLSearchParams('?a=b&c=d');
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Fills the window.URL class if it doesn't already exist or if its implementation is incorrect
 */
function fillUrlIfNecessary(URL) {
    // 'window' isn't defined in mocha test
    if (typeof window !== 'undefined' && (!urlIsPresent() || !urlSearchParamsIsPresent())) {
        window.URL = URL();
    }
}
exports.fillUrlIfNecessary = fillUrlIfNecessary;
/**
 * Fills the window.URLSearchParams class if it doesn't already exist or if its implementation is incorrect
 */
// tslint:disable-next-line:no-any variable-name
function fillUrlSearchParamsIfNecessary(URLSearchParams) {
    if (typeof window !== 'undefined' && (!urlIsPresent() || !urlSearchParamsIsPresent())) {
        window['URLSearchParams'] = URLSearchParams(); // tslint:disable-line:no-string-literal
    }
}
exports.fillUrlSearchParamsIfNecessary = fillUrlSearchParamsIfNecessary;



/***/ }),
/* 462 */
/***/ (function(module, exports) {

module.exports = {
	"id": "cc2cc925-b5be-41bb-880a-f0f8030c6aff",
	"alias": "OdspUtilitiesBundle",
	"componentType": "Library",
	"version": "1.1.0",
	"manifestVersion": 2,
	"loaderConfig": {
		"entryModuleId": "odsp-utilities-bundle",
		"internalModuleBaseUrls": [
			"http://localhost:4321/"
		],
		"scriptResources": {
			"odsp-utilities-bundle": {
				"type": "path",
				"path": "dist/odsp-utilities-bundle.js"
			}
		}
	}
};

/***/ }),
/* 463 */
/***/ (function(module, exports) {

module.exports = {
	"id": "8217e442-8ed3-41fd-957d-b112e841286a",
	"alias": "SPTelemetry",
	"componentType": "Library",
	"version": "0.2.2",
	"manifestVersion": 2,
	"loaderConfig": {
		"entryModuleId": "sp-telemetry",
		"internalModuleBaseUrls": [
			"https://localhost:4321/"
		],
		"scriptResources": {
			"sp-telemetry": {
				"type": "path",
				"path": "dist/sp-telemetry.js"
			},
			"@microsoft/sp-core-library": {
				"type": "component",
				"version": "1.1.0",
				"id": "7263c7d0-1d6a-45ec-8d85-d4d1d234171b"
			},
			"@ms/odsp-utilities-bundle": {
				"type": "component",
				"version": "1.1.0",
				"id": "cc2cc925-b5be-41bb-880a-f0f8030c6aff"
			}
		}
	}
};

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var result = window.spModuleLoader; 
if (!result) {
    __webpack_require__(197);
    result = __webpack_require__(115).default;
}
module.exports = result;


/***/ })
/******/ ])}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));;


/***/ })
/******/ ]);
//# sourceMappingURL=sp-loader_en-us.js.map
(function(){
if (!window.__setWebpackPublicPathLoaderSrcRegistry__) window.__setWebpackPublicPathLoaderSrcRegistry__={};
var scripts = document.getElementsByTagName('script');
if (scripts && scripts.length) {
  for (var i = 0; i < scripts.length; i++) {
    if (!scripts[i]) continue;
    var path = scripts[i].getAttribute('src');
    if (path) window.__setWebpackPublicPathLoaderSrcRegistry__[path]=true;
  }
}
})();